<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何照江的博客</title>
  
  
  <link href="http://github.hezhaojiang.io/atom.xml" rel="self"/>
  
  <link href="http://github.hezhaojiang.io/"/>
  <updated>2021-01-08T17:09:58.900Z</updated>
  <id>http://github.hezhaojiang.io/</id>
  
  <author>
    <name>何照江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>音视频日记 - ffmpeg 关键结构体</title>
    <link href="http://github.hezhaojiang.io/post/2021/e03178b1/"/>
    <id>http://github.hezhaojiang.io/post/2021/e03178b1/</id>
    <published>2021-01-08T08:53:09.000Z</published>
    <updated>2021-01-08T17:09:58.900Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><code>AVFormatContext</code> : 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息</li><li><code>AVInputFormat</code> : 每种封装格式（例如 FLV, MKV, MP4, AVI）对应一个该结构体</li><li><code>AVStream</code> : 视频文件中每个视频（音频）流对应一个该结构体</li><li><code>AVCodecContext</code> : 编码器上下文结构体，保存了视频（音频）编解码相关信息</li><li><code>AVCodec</code> : 每种视频（音频）编解码器 (例如 H.264 解码器) 对应一个该结构体</li><li><code>AVPacket</code> : 存储一帧压缩编码数据</li><li><code>AVFrame</code> : 存储一帧解码后像素（采样）数据</li></ul><h2 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h2><h3 id="AVFormatContext-相关函数"><a href="#AVFormatContext-相关函数" class="headerlink" title="AVFormatContext 相关函数"></a>AVFormatContext 相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate an AVFormatContext.</span></span><br><span class="line"><span class="comment"> * avformat_free_context() can be used to free the context and everything</span></span><br><span class="line"><span class="comment"> * allocated by the framework within it. */</span></span><br><span class="line"><span class="function">AVFormatContext *<span class="title">avformat_alloc_context</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open an input stream and read the header. The codecs are not opened.</span></span><br><span class="line"><span class="comment"> * The stream must be closed with avformat_close_input().</span></span><br><span class="line"><span class="comment"> * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).</span></span><br><span class="line"><span class="comment"> *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this</span></span><br><span class="line"><span class="comment"> *           function and written into ps.</span></span><br><span class="line"><span class="comment"> * @param url URL of the stream to open.</span></span><br><span class="line"><span class="comment"> * @return 0 on success, a negative AVERROR on failure. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, ff_const59 AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read packets of a media file to get stream information.</span></span><br><span class="line"><span class="comment"> * @param ic media file handle</span></span><br><span class="line"><span class="comment"> * @param options  If non-NULL, an ic.nb_streams long array of pointers to</span></span><br><span class="line"><span class="comment"> *                 dictionaries, where i-th member contains options for</span></span><br><span class="line"><span class="comment"> *                 codec corresponding to i-th stream.</span></span><br><span class="line"><span class="comment"> *                 On return each dictionary will be filled with options that were not found.</span></span><br><span class="line"><span class="comment"> * @return &gt;=0 if OK, AVERROR_xxx on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="AVFormatContext-成员变量"><a href="#AVFormatContext-成员变量" class="headerlink" title="AVFormatContext 成员变量"></a>AVFormatContext 成员变量</h3><ul><li><code>iformat</code> : 输入 / 输出 视频的 <code>AVInputFormat</code></li><li><code>nb_streams</code> : 输入 / 输出 视频的 <code>AVStream</code> 个数</li><li><code>streams</code> : 输入 / 输出 视频的 <code>AVStream[]</code> 数组</li><li><code>duration</code> : 输入 / 输出 视频的时长（以微秒为单位）</li><li><code>bit_rate</code> : 输入 / 输出 视频的码率</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
    <category term="音视频" scheme="http://github.hezhaojiang.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - ffmpeg 命令行</title>
    <link href="http://github.hezhaojiang.io/post/2021/4765df61/"/>
    <id>http://github.hezhaojiang.io/post/2021/4765df61/</id>
    <published>2021-01-04T06:38:32.000Z</published>
    <updated>2021-01-08T17:09:58.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>ffmpeg</code> 是一个基于 <code>ffmpeg</code> 库的经典转码程序，几乎被所有的知名系统、软件工具、服务器后台等静默使用，通过命令行启动转码，这里主要以命令行语法讲解为主。</p><a id="more"></a><h2 id="查看-ffmpeg-帮助命令"><a href="#查看-ffmpeg-帮助命令" class="headerlink" title="查看 ffmpeg 帮助命令"></a>查看 ffmpeg 帮助命令</h2><p>在学习任何一个命令行程序前，首先要知道如何查看对应命令的帮助，在一般情况下，<code>linux</code> 平台下程序的帮助信息是通过 <code>程序名 -h</code> 的方式进行输出，<code>ffmpeg</code> 亦是如此。</p><p>精简帮助命令：<code>ffmpeg –h</code><br>更多帮助命令：<code>ffmpeg –h long</code><br>完整帮助命令：<code>ffmpeg –h full</code></p><h2 id="ffmpeg-的语法格式"><a href="#ffmpeg-的语法格式" class="headerlink" title="ffmpeg 的语法格式"></a>ffmpeg 的语法格式</h2><p>ffmpeg 的语法格式如下所示</p><pre><code>ffmpeg [输入源参数] -i [输入 URL] [输出参数] [输出 URL]其中 [输入源参数] 和 [输出参数] 的语法格式为：[options] [value(可以省略)] ... ...</code></pre><p>示例 1：</p><pre><code>ffmpeg -f mpegts -i &quot;http://AVTestFile/AVNormal/52&quot; -vcodec x264Encoder -r 15 -b:v 256000 -vf scale=800:600 -an -copyts -y &quot;51.avi&quot;* 输入源使用 mpegts 容器 http 协议的 URL* -vcodec x264Encoder 使用 x264Encoder 视频编码器* -r 15 视频帧率 15 fps* -b:v 256000 视频编码码率 265Kbps* -vf scale=800:600 使用视频滤器 scale 进行缩放到 800x600 尺寸* -an 禁用音频* -copyts 时间戳拷贝* -y 覆盖输出文件* 输出 URL 默认使用 file 协议，输出到文件 51.avi</code></pre><p>示例 2：</p><pre><code>ffmpeg -i BaiCaoYuan.mp4 -ss 00:00:19 -t 00:06:48 -dcodec copy -b:v 4000K -y cut.mp4* 输入源使用 file 协议，为 BaiCaoYuan.mp4 文件* -dcodec copy 使用与源视频一致的编解码器* -b:v 4000K 视频编码码率 4000Kbps* -y 覆盖输出文件* 输出 URL 默认使用 file 协议，输出到文件 cut.mp4</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><div class="table-container"><table><thead><tr><th>参数</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>-t duration</td><td>-t 00:06:48</td><td>设置处理时间，格式为hh:mm:ss</td></tr><tr><td>-ss position</td><td>-ss 00:00:19</td><td>设置起始时间，格式为hh:mm:ss</td></tr><tr><td>-b:v bitrate</td><td>-b:v 256000</td><td>设置视频码率</td></tr><tr><td>-b:a bitrate</td><td>-b:a 320000</td><td>设置音频码率</td></tr><tr><td>-r fps</td><td>-r 25</td><td>设置帧率</td></tr><tr><td>-s wxh</td><td>-s 800x600</td><td>设置帧大小，格式为WxH</td></tr><tr><td>-c:v codec</td><td>-c:v h264</td><td>设置视频编码器</td></tr><tr><td>-c:a codec</td><td>-c:a aac</td><td>设置音频编码器</td></tr><tr><td>-ar freq</td><td>-ar 44100</td><td>设置音频采样率</td></tr></tbody></table></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] 基于 FFmpeg + SDL 的视频播放器的制作 — 雷霄骅</li><li>[2] 多媒体编程开发之 FFmpeg 基础库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ffmpeg&lt;/code&gt; 是一个基于 &lt;code&gt;ffmpeg&lt;/code&gt; 库的经典转码程序，几乎被所有的知名系统、软件工具、服务器后台等静默使用，通过命令行启动转码，这里主要以命令行语法讲解为主。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
    <category term="音视频" scheme="http://github.hezhaojiang.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - YUV 格式详解</title>
    <link href="http://github.hezhaojiang.io/post/2021/a4daf22d/"/>
    <id>http://github.hezhaojiang.io/post/2021/a4daf22d/</id>
    <published>2021-01-03T05:07:20.000Z</published>
    <updated>2021-01-08T16:40:01.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>YUV 是一种彩色编码系统，主要用在视频、图形处理流水线中 (pipeline)。相对于 RGB 颜色空间，设计 YUV 的目的就是为了编码、传输的方便，减少带宽占用和信息出错。</p><p>人眼的视觉特点是对亮度更铭感，对位置、色彩相对来说不铭感。在视频编码系统中为了降低带宽，可以保存更多的亮度信息 (luma)，保存较少的色差信息 (chroma)。</p><a id="more"></a><h2 id="YUV-的相似概念"><a href="#YUV-的相似概念" class="headerlink" title="YUV 的相似概念"></a>YUV 的相似概念</h2><p><code>Y’UV</code>、<code>YUV</code>、<code>YCbCr</code>、<code>YPbPr</code> 几个概念其实是一回事儿。</p><p>由于历史关系，<code>Y’UV</code>、<code>YUV</code> 主要是用在彩色电视中，用于模拟信号表示。</p><p><code>YCbCr</code> 是用在数字视频、图像的压缩和传输，如 <code>MPEG</code>、<code>JPEG</code>。</p><p>今天大家所讲的 <code>YUV</code> 其实就是指 <code>YCbCr</code>。<code>Y</code> 表示亮度（luma），<code>CbCr</code> 表示色度（chroma）。</p><p>luminance 亮度，<code>luma</code> 是在视频编码系统中指亮度值；chrominance 色度，<code>chroma</code> 是在视频编码系统中指色度值。</p><p><code>Y’UV</code> 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是 (<code>UV</code>)，那么在彩色电视显示的时候指显示亮度信息。</p><p><code>Y’UV</code> 不是 <code>Absolute Color Space</code>，只是一种 <code>RGB</code> 的信息编码，实际的显示还是通过 <code>RGB</code> 来显示。<code>Y’,U,V</code> 叫做不同的 component。</p><h2 id="YUV-后数字的含义"><a href="#YUV-后数字的含义" class="headerlink" title="YUV 后数字的含义"></a>YUV 后数字的含义</h2><pre><code>我们一般理解为 yuv444，yuv422，yuv420 的解释是后面三个数字分别对应前面三个字母。拿 yuv422 来说：y 对应 4，表示 4 个图形像素中，每个都有亮度值u 对应 2，表示 4 个图形像素中，Cb 占用两个像素v 对应 2，表示 4 个图形像素中，Cr 占用两个像素但是对于 yuv420 解释就不对了，不能说 4 个图形像素中，Cr 占用 0 个像素吧？</code></pre><p>我们通过下图来理解一下 <code>yuv</code> 各种格式后面数字的含义。图来源于 <a href="https://link.zhihu.com/?target=http%3A//dougkerr.net/Pumpkin/articles/Subsampling.pdf">Chrominance Subsampling in Digital Images</a></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210103211447.png" alt="YUV"></p><p>如上图中所示，左侧一列，每一个小矩形是图形像素表示，黑框矩形是色度像素表示，小黑点是表示色度像素值 (Cb + Cr)，表示图形像素和色度像素在水平和垂直方向的比例关系。比如，</p><pre><code>- 4:4:0 水平方向是 1/1，垂直方向是 1/2，表示 1 个色度像素对应了 2 个图形像素。- 4:2:2 水平方向是 1/2，垂直方向是 1/1，表示 1 个色度像素对应了 2 个图形像素。- 4:2:0 水平方向是 1/2，垂直方向是 1/2，表示 1 个色度像素对应了 4 个图形像素。</code></pre><p>右侧一列是二次采样模式记号表示, 是 <code>J:a:b</code> 模式，即 YUV 后数字表示的模式。图中实心黑色圆圈表示包含色度像素 (Cb + Cr），空心圆圈表示不包含色度像素。</p><pre><code>对于 J:a:b 模式，定义了一个 J x 2 的矩形参考块J 通常是 4，此参考块就是宽度有 4 个像素、高度有 2 个像素的矩形a 表示参考块的第一行包含的色度像素样本数b 表示在参考块的第二行包含的色度像素样本数- 4:4:0 参考块第 1 行包含 4 个色度样本，第 2 行没有包含色度样本。- 4:2:2 参考块第 1 行包含 2 个色度样本，第 2 行也包含 2 个色度样本，他们是交替出现。- 4:2:0 参考块第 1 行包含 2 个色度样本，第 2 行没有包含色度样本。</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://zhuanlan.zhihu.com/p/85620611">如何理解 YUV ？ - 知乎</a></li><li>[2] 多媒体编程开发之 FFmpeg 基础库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;YUV 是一种彩色编码系统，主要用在视频、图形处理流水线中 (pipeline)。相对于 RGB 颜色空间，设计 YUV 的目的就是为了编码、传输的方便，减少带宽占用和信息出错。&lt;/p&gt;
&lt;p&gt;人眼的视觉特点是对亮度更铭感，对位置、色彩相对来说不铭感。在视频编码系统中为了降低带宽，可以保存更多的亮度信息 (luma)，保存较少的色差信息 (chroma)。&lt;/p&gt;</summary>
    
    
    
    
    <category term="音视频" scheme="http://github.hezhaojiang.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - Windows 安装 ffmpeg</title>
    <link href="http://github.hezhaojiang.io/post/2021/a1b64acb/"/>
    <id>http://github.hezhaojiang.io/post/2021/a1b64acb/</id>
    <published>2021-01-03T04:00:27.000Z</published>
    <updated>2021-01-08T16:52:22.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <code>Windows</code> 上编译 <code>ffmpeg</code> 没有在 <code>linux</code> 上简单方便，在此记录编译过程</p><a id="more"></a><h2 id="配置-MSVC-编译环境"><a href="#配置-MSVC-编译环境" class="headerlink" title="配置 MSVC 编译环境"></a>配置 MSVC 编译环境</h2><p>配置环境变量如下（VS2019）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PATH</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\bin\Hostx64\x64\</span><br><span class="line"><span class="comment"># INCLUDE</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\winrt</span><br><span class="line"><span class="comment"># LIB</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\lib\x64</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.18362.0\um\x64</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.18362.0\ucrt\x64</span><br></pre></td></tr></table></figure><h2 id="MSYS2-的安装与配置"><a href="#MSYS2-的安装与配置" class="headerlink" title="MSYS2 的安装与配置"></a>MSYS2 的安装与配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到以下内容</span></span><br><span class="line">rem <span class="built_in">set</span> MSYS2_PATH_TYPE=inherit</span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line"><span class="built_in">set</span> MSYS2_PATH_TYPE=inherit</span><br></pre></td></tr></table></figure><p>执行 <code>cl</code> 命令查看输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cl</span></span><br><span class="line">用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29335 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">用法: cl [ 选项... ] 文件名... [ /link 链接选项... ]</span><br></pre></td></tr></table></figure><p>如果是以上返回则配置成功</p><p>如果提示 <code>bash: cl: 未找到命令</code> 则需要检查是不是上述配置出了问题，或者重启电脑再试一下。</p><h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果网络连接不上，可以尝试使用代理</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;127.0.0.1:10809&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;127.0.0.1:10809&quot;</span></span><br><span class="line"><span class="comment"># 安装以下依赖</span></span><br><span class="line">pacman -S nasm</span><br><span class="line">pacman -S yasm</span><br><span class="line">pacman -S make cmake</span><br><span class="line">pacman -S diffutils</span><br><span class="line">pacman -S pkg-config</span><br><span class="line">pacman -S git</span><br><span class="line">pacman -S mingw-w64-x86_64-SDL2</span><br></pre></td></tr></table></figure><h2 id="编译-x264"><a href="#编译-x264" class="headerlink" title="编译 x264"></a>编译 x264</h2><h2 id="编译-x265"><a href="#编译-x265" class="headerlink" title="编译 x265"></a>编译 x265</h2><h2 id="编译-ffmpeg"><a href="#编译-ffmpeg" class="headerlink" title="编译 ffmpeg"></a>编译 ffmpeg</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="built_in">enable</span>-yasm --<span class="built_in">enable</span>-asm --toolchain=msvc --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-static</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;code&gt;Windows&lt;/code&gt; 上编译 &lt;code&gt;ffmpeg&lt;/code&gt; 没有在 &lt;code&gt;linux&lt;/code&gt; 上简单方便，在此记录编译过程&lt;/p&gt;</summary>
    
    
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
    <category term="音视频" scheme="http://github.hezhaojiang.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 libevent - 时间管理</title>
    <link href="http://github.hezhaojiang.io/post/2020/39d8a9e7/"/>
    <id>http://github.hezhaojiang.io/post/2020/39d8a9e7/</id>
    <published>2020-12-30T08:24:28.000Z</published>
    <updated>2021-01-01T17:19:15.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了支持定时器，<code>libevent</code> 必须和系统时间打交道，z 在 <code>event_add</code> 时，用户制定了一个超时时间，这个超时时间是一个相对时间，但在 <code>event_add</code> 函数内部，<code>libevent</code> 将其转换为了绝对时间，这就带来了一个问题：在系统时间改变时，<code>libevent</code> 需要修改 <code>event</code> 的绝对时间，为此 <code>libevent</code> 内部有以下几种解决方案：</p><ol><li>使用单调时间 <code>monotonic time</code></li><li>使用系统时间生成 <code>fake monotonic time</code></li><li>使用系统时间（已弃用）</li></ol><a id="more"></a><h2 id="使用-monotonic-时间"><a href="#使用-monotonic-时间" class="headerlink" title="使用 monotonic 时间"></a>使用 monotonic 时间</h2><h3 id="什么是-monotonic-时间"><a href="#什么是-monotonic-时间" class="headerlink" title="什么是 monotonic 时间"></a>什么是 monotonic 时间</h3><p><code>monotonic time</code> 字面意思是单调时间，实际上它指的是系统启动以后流逝的时间，这是由变量 <code>jiffies</code> 来记录的。</p><p>系统每次启动时 <code>jiffies</code> 初始化为 0，每来一个 <code>timer interrupt</code>，<code>jiffies</code> 加 <code>1</code>，也就是说它代表系统启动后流逝的 <code>tick</code> 数</p><h3 id="是否使用-monotonic-时间"><a href="#是否使用-monotonic-时间" class="headerlink" title="是否使用 monotonic 时间"></a>是否使用 monotonic 时间</h3><p>决定 <code>libevent</code> 是否使用 <code>monotonic</code> 时间取决于系统是否支持 <code>monotonic</code> 时间，<code>libevent</code> 对其有两处判断，一处在编译时判断，一处在运行时判断：</p><h4 id="编译时判断"><a href="#编译时判断" class="headerlink" title="编译时判断"></a>编译时判断</h4><p>通过 <code>Cmake</code> 判断系统环境，来确定获取 <code>monotonic</code> 时间的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMakeLists.txt:</span></span><br><span class="line">CHECK_FUNCTION_EXISTS_EX(clock_gettime EVENT__HAVE_CLOCK_GETTIME)</span><br><span class="line">CHECK_FUNCTION_EXISTS_EX(mach_absolute_time EVENT__HAVE_MACH_ABSOLUTE_TIME)</span><br><span class="line"></span><br><span class="line"><span class="comment">// time-internal.h:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(EVENT__HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_POSIX_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(EVENT__HAVE_MACH_ABSOLUTE_TIME)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MACH_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_WIN32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_WIN32_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_FALLBACK_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>根据 <code>time-internal.h</code> 中的四个不同的宏定义，<code>libevent</code> 定义了四个 <code>evutil_configure_monotonic_time_</code> 函数，本文主要分析 <code>HAVE_POSIX_MONOTONIC</code> 宏定义下的 <code>evutil_configure_monotonic_time_</code> 函数。</p><h4 id="运行时判断"><a href="#运行时判断" class="headerlink" title="运行时判断"></a>运行时判断</h4><p><code>libevent</code> 会在 <code>event_base</code> 创建时对 <code>monotonic</code> 时间的支持进行判断，判断方式为：调用不同平台下的 <code>monotonic</code> 时间获取函数，如果能正确返回，则代表该平台支持 <code>monotonic</code> 时间，<code>libevent</code> 后续使用 <code>gettime</code> 获取时间均会使用 <code>monotonic</code> 时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The POSIX clock_gettime() interface provides a few ways to get at a monotonic clock.</span></span><br><span class="line"><span class="comment">   CLOCK_MONOTONIC is most widely supported.</span></span><br><span class="line"><span class="comment">   Linux also provides a CLOCK_MONOTONIC_COARSE with accuracy of about 1-4 msec.</span></span><br><span class="line"><span class="comment">   On all platforms I&#x27;m aware of, CLOCK_MONOTONIC really is monotonic.</span></span><br><span class="line"><span class="comment">   Platforms don&#x27;t agree about whether it should jump on a sleep/resume. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_configure_monotonic_time_</span><span class="params">(struct evutil_monotonic_timer *base, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* CLOCK_MONOTONIC exists on FreeBSD, Linux, and Solaris.  You need to check for it at runtime,</span></span><br><span class="line"><span class="comment">     * because some older kernel versions won&#x27;t have it working. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> fallback = flags &amp; EV_MONOT_FALLBACK;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fallback &amp;&amp; clock_gettime(CLOCK_MONOTONIC, &amp;ts) == <span class="number">0</span>) &#123;</span><br><span class="line">        base-&gt;monotonic_clock = CLOCK_MONOTONIC;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CLOCK_MONOTONIC &lt; <span class="number">0</span>) event_errx(<span class="number">1</span>,<span class="string">&quot;I didn&#x27;t expect CLOCK_MONOTONIC to be &lt; 0&quot;</span>);</span><br><span class="line">    base-&gt;monotonic_clock = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>libevent</code> 所在的系统支持 <code>monotonic</code> 时间，那么根本就不用考虑用户手动修改系统时间这坑爹的事情。但如果所在的系统没有支持 <code>monotonic</code> 时间，那么 <code>libevent</code> 就只能使用 <code>evutil_gettimeofday</code> 获取一个用户能修改的时间。</p><h2 id="使用-fake-monotonic-时间"><a href="#使用-fake-monotonic-时间" class="headerlink" title="使用 fake monotonic 时间"></a>使用 fake monotonic 时间</h2><p>从上述分析中可以看到，在平台不支持 <code>base-&gt;monotonic_clock</code> 会被 <code>libevent</code> 置为 <code>-1</code>，此时调用 <code>gettime</code> 就会调用 <code>evutil_gettimeofday</code> 来获取系统时间，并通过 <code>adjust_monotonic_time</code> 将获取到的系统时间调整为一个单调递增的时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_gettime_monotonic_</span><span class="params">(struct evutil_monotonic_timer *base, struct timeval *tp)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;monotonic_clock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (evutil_gettimeofday(tp, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// evutil_gettimeofday 调用 gettimeofday 函数</span></span><br><span class="line">        adjust_monotonic_time(base, tp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(base-&gt;monotonic_clock, &amp;ts) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    tp-&gt;tv_sec = ts.tv_sec;</span><br><span class="line">    tp-&gt;tv_usec = ts.tv_nsec / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettime</span><span class="params">(struct event_base *base, struct timeval *tp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;tv_cache.tv_sec) &#123;</span><br><span class="line">        *tp = base-&gt;tv_cache;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (evutil_gettime_monotonic_(&amp;base-&gt;monotonic_timer, tp) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统时间到-fake-monotonic-时间的转化"><a href="#系统时间到-fake-monotonic-时间的转化" class="headerlink" title="系统时间到 fake monotonic 时间的转化"></a>系统时间到 fake monotonic 时间的转化</h3><p><code>libevent</code> 获取到系统时间后，会调用 <code>adjust_monotonic_time</code> 生成 <code>fake monotonic</code> 时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function assumes it&#x27;s called repeatedly with a not-actually-so-monotonic time source whose outputs</span></span><br><span class="line"><span class="comment">   are in &#x27;tv&#x27;. It implements a trivial ratcheting mechanism so that the values never go backwards. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust_monotonic_time</span><span class="params">(struct evutil_monotonic_timer *base, struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* tv 输入的是 real time，输出为 fake monotonic time */</span></span><br><span class="line">    evutil_timeradd(tv, &amp;base-&gt;adjust_monotonic_clock, tv); <span class="comment">// evutil_timeradd(a,b,c) &lt;--&gt; c = a + b</span></span><br><span class="line">    <span class="comment">// 如果 tv &lt; last_time 表明用户向前调整时间了，需要校正时间</span></span><br><span class="line">    <span class="keyword">if</span> (evutil_timercmp(tv, &amp;base-&gt;last_time, &lt;)) &#123; <span class="comment">// evutil_timercmp(a,b,op) &lt;--&gt; a op b</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">adjust</span>;</span> <span class="comment">// 保存差值</span></span><br><span class="line">        evutil_timersub(&amp;base-&gt;last_time, tv, &amp;adjust); <span class="comment">// evutil_timersub(a,b,c) &lt;--&gt; c = a - b</span></span><br><span class="line">        evutil_timeradd(&amp;adjust, &amp;base-&gt;adjust_monotonic_clock, &amp;base-&gt;adjust_monotonic_clock);</span><br><span class="line">        *tv = base-&gt;last_time;</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;last_time = *tv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出，如果用户没有向前调整时间，则 <code>adjust_monotonic_time</code> 函数返回的就是真实的时间，如果用户向前调整了时间，<code>libevent</code> 会将用户向前调整的时间累计到 <code>base-&gt;adjust_monotonic_clock</code> 参数中，再之后获取的时间就都会被 <code>adjust_monotonic_time</code> 函数加上 <code>base-&gt;adjust_monotonic_clock</code> 再返回出来，从而实现时间的单调递增，即 <code>fake monotonic</code> 时间</p><h2 id="使用系统时间"><a href="#使用系统时间" class="headerlink" title="使用系统时间"></a>使用系统时间</h2><p>该部分内容已被 <code>libevent</code> 于 <code>2012</code> 年弃用，如读者有兴趣，可以查看 <a href="https://blog.csdn.net/luotuo44/article/details/38661787">参考资料[2]</a> 中的分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Revision: f5e4eb05e5bdf61b0a1b11f99effaf835a8796ce</span><br><span class="line">Author: Nick Mathewson &lt;nickm@torproject.org&gt;</span><br><span class="line">Date: 2012&#x2F;4&#x2F;21 1:14:10</span><br><span class="line">Message:</span><br><span class="line">Refactor monotonic timer handling into a new type and set of functions; add a gettimeofday-based ratcheting implementation</span><br><span class="line">Now, event.c can always assume that we have a monotonic timer; thismakes event.c easier to write.</span><br><span class="line">----</span><br><span class="line">Modified: event-internal.h</span><br><span class="line">Modified: event.c</span><br><span class="line">Modified: evutil_time.c</span><br><span class="line">Modified: time-internal.h</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li><li>[2] <a href="https://blog.csdn.net/luotuo44/article/details/38661787">Libevent 源码分析 - Libevent 时间管理 luotuo44 的专栏 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了支持定时器，&lt;code&gt;libevent&lt;/code&gt; 必须和系统时间打交道，z 在 &lt;code&gt;event_add&lt;/code&gt; 时，用户制定了一个超时时间，这个超时时间是一个相对时间，但在 &lt;code&gt;event_add&lt;/code&gt; 函数内部，&lt;code&gt;libevent&lt;/code&gt; 将其转换为了绝对时间，这就带来了一个问题：在系统时间改变时，&lt;code&gt;libevent&lt;/code&gt; 需要修改 &lt;code&gt;event&lt;/code&gt; 的绝对时间，为此 &lt;code&gt;libevent&lt;/code&gt; 内部有以下几种解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用单调时间 &lt;code&gt;monotonic time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用系统时间生成 &lt;code&gt;fake monotonic time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用系统时间（已弃用）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="源码" scheme="http://github.hezhaojiang.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 libevent - 优先级管理</title>
    <link href="http://github.hezhaojiang.io/post/2020/27de5435/"/>
    <id>http://github.hezhaojiang.io/post/2020/27de5435/</id>
    <published>2020-12-30T05:15:02.000Z</published>
    <updated>2020-12-30T16:24:53.547Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>event_base</code> 允许用户对它里面的 <code>event</code> 设置优先级，这样可以使得有些更重要的 <code>event</code> 能够得到优先处理。</p><a id="more"></a><h2 id="实现优先级"><a href="#实现优先级" class="headerlink" title="实现优先级"></a>实现优先级</h2><p><code>libevent</code> 实现优先级功能的方法是：用一个激活队列数组来存放激活 <code>event</code>。即数组的元素是一个激活队列，所以有多个激活队列。并且规定不同的队列有不同的优先级。</p><p>可以通过 <code>event_base_priority_init</code> 函数设置 <code>event_base</code> 的优先级个数，该函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_priority_init</span><span class="params">(struct event_base *base, <span class="keyword">int</span> npriorities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, r = <span class="number">-1</span>;</span><br><span class="line">    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">if</span> (N_ACTIVE_CALLBACKS(base) || npriorities &lt; <span class="number">1</span> || npriorities &gt;= EVENT_MAX_PRIORITIES) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">if</span> (npriorities == base-&gt;nactivequeues) <span class="keyword">goto</span> ok;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;nactivequeues) &#123;</span><br><span class="line">        mm_free(base-&gt;activequeues);</span><br><span class="line">        base-&gt;nactivequeues = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Allocate our priority queues */</span></span><br><span class="line">    base-&gt;activequeues = (struct evcallback_list *)mm_calloc(npriorities, <span class="keyword">sizeof</span>(struct evcallback_list));</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;activequeues == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        event_warn(<span class="string">&quot;%s: calloc&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;nactivequeues = npriorities;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; base-&gt;nactivequeues; ++i) TAILQ_INIT(&amp;base-&gt;activequeues[i]);</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">return</span> (r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面一个判断可知，因为 <code>event_base_dispatch</code> 函数会改动激活事件的个数，即会使得 <code>N_ACTIVE_CALLBACKS(base)</code> 为真。所以 <code>event_base_priority_init</code> 函数要在 <code>event_base_dispatch</code> 函数之前调用。此外要设置的优先级个数，要小于 <code>EVENT_MAX_PRIORITIES</code>。这个宏是在 <code>event.h</code> 文件中定义，在 <code>2.1.11</code> 版本中，该宏被定义成 <code>256</code>。在调用 <code>event_base_new</code> 得到的 <code>event_base</code> 只有一个优先级，也就是所有 <code>event</code> 都是同级的。</p><p>上面的代码调用 <code>mm_alloc</code> 分配了一个优先级数组。不同优先级的 <code>event</code> 会被放到数组的不同位置上 (下面可以看到这一点)。这样就可以区分不同 <code>event</code> 的优先级了。以后处理 <code>event</code> 时，就可以从高优先级到低优先级处理 <code>event</code>。</p><h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><p>上面是设置 <code>event_base</code> 的优先级个数。现在来看一下怎么设置 <code>event</code> 的优先级。可以通过 <code>event_priority_set</code> 函数设置，该函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set&#x27;s the priority of an event - if an event is already scheduled changing the priority is going to fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *ev, <span class="keyword">int</span> pri)</span> </span>&#123;</span><br><span class="line">    event_debug_assert_is_setup_(ev);</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_ACTIVE) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (pri &lt; <span class="number">0</span> || pri&gt;= ev-&gt;ev_base-&gt;nactivequeues) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    ev-&gt;ev_pri = pri;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码的第一个判断中，可以知道当 <code>event</code> 的状态是 <code>EVLIST_ACTIVE</code> 时，就不能对这个 <code>event</code> 进行优先级设置了。因此，如果要对 <code>event</code> 进行优先级设置，那么得在调用 <code>event_base_dispatch</code> 函数之前。因为一旦调用了 <code>event_base_dispatch</code>，那么 <code>event</code> 就随时可能变成 <code>EVLIST_ACTIVE</code> 状态。</p><h2 id="按优先级激活队列"><a href="#按优先级激活队列" class="headerlink" title="按优先级激活队列"></a>按优先级激活队列</h2><p>现在看一下一个 <code>event</code> 是怎么插入到 <code>event_base</code> 的优先级数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_queue_insert_active</span><span class="params">(struct event_base *base, struct event_callback *evcb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* #define ev_pri ev_evcallback.evcb_pri 事件优先级 */</span></span><br><span class="line">    EVUTIL_ASSERT(evcb-&gt;evcb_pri &lt; base-&gt;nactivequeues);</span><br><span class="line">    <span class="comment">/* 插入到对应优先级的激活队列尾部 */</span></span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;base-&gt;activequeues[evcb-&gt;evcb_pri], evcb, evcb_active_next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>event</code> 插入到 <code>event_base</code> 的优先级数组中后，会被按照优先级顺序被调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">event_process_active</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* 按优先级遍历激活队列中的事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; base-&gt;nactivequeues; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TAILQ_FIRST(&amp;base-&gt;activequeues[i]) != <span class="literal">NULL</span>) &#123; <span class="comment">/* 同一个优先级下可以有多个事件 */</span></span><br><span class="line">            base-&gt;event_running_priority = i; <span class="comment">/* 设置当前的优先级 */</span></span><br><span class="line">            activeq = &amp;base-&gt;activequeues[i]; <span class="comment">/* 获取优先级 i 下的所有 event 组成的链表 */</span></span><br><span class="line">            <span class="comment">/* 遍历 activeq 链表，调用其中每个 event 的回调函数 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; limit_after_prio) c = event_process_active_single_queue(base, activeq, INT_MAX, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span> c = event_process_active_single_queue(base, activeq, maxcb, endtime);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="keyword">goto</span> done; <span class="comment">/* c 是执行的非内部事件数目 */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c&gt; <span class="number">0</span>) <span class="comment">/* Processed a real event; do not consider lower-priority events */</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* If we get here, all of the events we processed were internal. Continue. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认优先级"><a href="#默认优先级" class="headerlink" title="默认优先级"></a>默认优先级</h2><p>默认优先级是在新建 <code>event</code> 结构体时设置的。不错，看下面的 <code>event_assign</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_assign</span><span class="params">(struct event *ev, struct event_base *base, <span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">short</span> events, <span class="keyword">void</span> (*callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* by default, we put new events into the middle priority */</span></span><br><span class="line">        ev-&gt;ev_pri = base-&gt;nactivequeues / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li><li>[2] <a href="https://blog.csdn.net/luotuo44/article/details/38512719">Libevent源码分析 event优先级设置 luotuo44的专栏 - CSDN博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;event_base&lt;/code&gt; 允许用户对它里面的 &lt;code&gt;event&lt;/code&gt; 设置优先级，这样可以使得有些更重要的 &lt;code&gt;event&lt;/code&gt; 能够得到优先处理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="源码" scheme="http://github.hezhaojiang.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hexo - 换机指导</title>
    <link href="http://github.hezhaojiang.io/post/2020/6a28acc4/"/>
    <id>http://github.hezhaojiang.io/post/2020/6a28acc4/</id>
    <published>2020-12-20T00:22:19.000Z</published>
    <updated>2020-12-30T14:16:21.674Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于最近更换电脑，需要将旧电脑的一些资料转移至新电脑，其中 <code>Hexo</code> 的资料转移过程中踩了不少坑，所以在此记录以下，防止后续换机时继续踩坑。</p><a id="more"></a><h2 id="安装-Hexo-环境"><a href="#安装-Hexo-环境" class="headerlink" title="安装 Hexo 环境"></a>安装 Hexo 环境</h2><p>首先需要在新电脑上安装 <code>Hexo</code> 环境</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>这里是第一个坑，安装的 <code>Node.js</code> 建议版本为 12.14，如果安装的版本过高，后续 <code>hexo</code> 命令执行时可能会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(node:2396) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</span><br><span class="line">(Use &#96;node --trace-warnings ...&#96; to show where the warning was created)</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency</span><br></pre></td></tr></table></figure><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装好 <code>Node.js</code> 后直接安装 <code>Hexo</code>，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>安装完发现无法运行 <code>Hexo</code> 命令，需要进行如下设置：</p><ol><li><p>以管理员身份运行 <code>powershell</code></p></li><li><p>执行 <code>set-executionpolicy remotesigned</code></p></li></ol><h2 id="拷贝-Hexo-资料文件夹"><a href="#拷贝-Hexo-资料文件夹" class="headerlink" title="拷贝 Hexo 资料文件夹"></a>拷贝 Hexo 资料文件夹</h2><p>拷贝除 .deploy_git 和 public 文件夹以外的所有内容</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201220200545.png" alt="Hexo文件夹"></p><p>此时即可用 <code>hexo g</code> 等命令正常使用 <code>Hexo</code> 了~~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于最近更换电脑，需要将旧电脑的一些资料转移至新电脑，其中 &lt;code&gt;Hexo&lt;/code&gt; 的资料转移过程中踩了不少坑，所以在此记录以下，防止后续换机时继续踩坑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="http://github.hezhaojiang.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - MP4 封装格式</title>
    <link href="http://github.hezhaojiang.io/post/2020/e90af351/"/>
    <id>http://github.hezhaojiang.io/post/2020/e90af351/</id>
    <published>2020-11-29T07:39:12.000Z</published>
    <updated>2020-12-03T16:12:58.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>mp4</code> 文件封装格式，对应的标准为 <code>ISO/IEC 14496-12</code> 和 <code>ISO/IEC 14496-14</code>。</p><p><code>ISO/IEC 14496-12</code> 定义了一种封装媒体数据的基础文件格式，<code>mp4</code>、<code>3gp</code>、<code>ismv</code> 等我们常见媒体封装格式都是以这种基础文件格式为基础衍生的。</p><p><code>ISO/IEC 14496-14</code> 基于 <code>ISO-14496-12</code> 定义了 <code>mp4</code> 文件格式。</p><a id="more"></a><h2 id="基础文件格式-Box"><a href="#基础文件格式-Box" class="headerlink" title="基础文件格式 - Box"></a>基础文件格式 - Box</h2><p>按照 <code>ISO-14496-12</code>，文件由一系列对象 <code>Box</code> 构成, <code>Box</code> 可以嵌套包含其他 <code>Box</code></p><p><code>Box</code> 分为两类: 一类是元数据 <code>Box</code>，一类是媒体数据 <code>Box</code></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130213738.png" alt="Box"></p><p><code>Box Header</code> 的格式可用如下代码表示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">Box</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) boxtype, optional <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>)[<span class="number">16</span>] extended_type)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">size</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> type </span>= boxtype;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> largesize</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// box extends to end of file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (boxtype == <span class="string">&quot;uuid&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>)[<span class="number">16</span>] usertype = extended_type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些 <code>Box</code> 对象的 <code>Box Header</code> 可能会包含有版本号和标志域:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">FullBox</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) boxtype, <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>) v, <span class="built_in">bit</span>(<span class="number">24</span>) f)</span> extends <span class="title">Box</span><span class="params">(boxtype)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> version </span>= v;</span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">24</span>) flags = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MP4-格式介绍"><a href="#MP4-格式介绍" class="headerlink" title="MP4 格式介绍"></a>MP4 格式介绍</h2><p><code>Box</code> 种类非常多，下图中例举了一些重要的 <code>Box</code> 类型:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130214743.png" alt="MP4"></p><ol><li>分析时会从外到里进行分析，先分析第一层的 <code>Box</code> 各个字段，再分析第二层 <code>Box</code> 各个字段，以此类推</li><li><code>Box</code> 由于种类非常多，这里只分析一个标准的 <code>mp4</code> 文件的 <code>Box</code> 含义</li><li><code>Box</code> 里面字段也不是所有的都需要关注，我们只需要关注核心和有用的，对于一些不太用的就可以忽略不计了</li></ol><h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><p>使用 <code>mp4info</code> 打开一个 <code>mp4</code> 文件，可以看到，该 <code>mp4</code> 文件第一层 <code>Box</code> 有 <code>4</code> 种:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130215440.png" alt="第一层"></p><ol><li><code>ftyp</code></li><li><code>free</code></li><li><code>mdat</code></li><li><code>moov</code></li></ol><p>我们逐个分析该 <code>4</code> 种 <code>Box</code> 的含义和内容。</p><h3 id="ftyp"><a href="#ftyp" class="headerlink" title="ftyp"></a>ftyp</h3><p><code>ftyp</code> 是 <code>mp4</code> 文件的第一个 <code>Box</code>，包含了视频文件使用的编码格式、标准等，这个 <code>Box</code> 作用基本就是 <code>mp4</code> 这种封装格式的标识，同时在一份 <code>mp4</code> 文件中只有一个这样的 <code>Box</code>。<code>ftyp box</code> 通常放在文件的开始，通过对该 <code>Box</code> 解析可以让我们的软件（播放器、demux、解析器）知道应该使用哪种协议对这该文件解析，是后续解读文件基础。</p><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130234447.png" alt="ftyp box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class FileTypeBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;ftyp&quot;</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> major_brand</span>;           <span class="comment">// 不同厂商要实现这种规范都要向 ISO 注册的一个四字节的标识码</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> minor_version</span>;         <span class="comment">// 商标版本号</span></span><br><span class="line">    unsigned int(32) compatible_brands[];   // 兼容其他的版本号，表示可以兼容和遵从那些协议标准，是一个列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 1C</code> 表示该 <code>Box</code> 长度为 <code>28</code> 字节</li><li>Box type: <code>0x66 74 79 70</code> 是 <code>ftyp</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>major brand: <code>0x69 73 6F 6D</code> 是 <code>isom</code> 的 <code>ASCII</code> 值，说明本文件是符合这个规范的。</li><li>minor version: <code>0x00 00 02 00</code> 代表 <code>isom</code> 的版本号</li><li>compatible brand: <code>0x69 73 6F 6D 69 73 6F 32 6D 70 34 31</code> <code>ASCII</code> 值为 <code>iosmios2mp4l</code> 表示本文件可以兼容的协议和标准</li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130235834.png" alt="ftyp Mp4Explorer"></p><h3 id="moov"><a href="#moov" class="headerlink" title="moov"></a>moov</h3><ul><li><code>Container</code>: <code>File</code></li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p><code>moov Box</code> 这个 <code>Box</code> 也是 <code>MP4</code> 文件中必须有但是只存在一个的 <code>Box</code>, 这个 <code>Box</code> 里面一般存的是媒体文件的元数据，这个 <code>Box</code> 本身是很简单的，是一种 Container <code>Box</code>，里面的数据是子 <code>Box</code>, 自己更像是一个分界标识。</p><p>所谓的媒体元数据主要包含类似 <code>SPS</code>、<code>PPS</code> 的编解码参数信息，还有音视频的时间戳等信息。对于 <code>MP4</code> 还有一个重要的采样表 <code>stbl</code> 信息，这里面定义了采样 <code>Sample</code>、<code>Chunk</code>、<code>Track</code> 的映射关系，是 <code>MP4</code> 能够进行随机拖动和播放的关键，也是需要好好理解的部分，对于实现一些音视频特殊操作很有帮助。</p><p>根据 <code>ISO-14496-12</code>，文件中必须要包括唯一一个元数据容器: <code>Movie Box(moov)</code>，该 <code>Box</code> 一般在文件的头部或尾部，方便定位。</p><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201000619.png" alt="moov box"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MovieBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;moov&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 2E 49</code> 表示该 <code>Box</code> 长度为 <code>11849</code> 字节</li><li>Box type: <code>0x6D 6F 6F 76</code> 就是 <code>moov</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#mvhd">第二层 - mvhd</a></li><li>参见: <a href="#iods">第二层 - iods</a></li><li>参见: <a href="#trak">第二层 - trak</a></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201000000.png" alt="moov Mp4Explorer"></p><h3 id="mdat"><a href="#mdat" class="headerlink" title="mdat"></a>mdat</h3><p><code>mdat Box</code> 这个 <code>Box</code> 是存储音视频数据的 <code>Box</code>，要从这个 <code>Box</code> 解封装出真实的媒体数据。当然这个 <code>Box</code> 一般都会存在，但是不是必须的。</p><p>说明:</p><ol><li><code>mdat Box</code> 基本组成还是有头部和数据两部分组成，但是这里注意如果 <code>Box length</code> 长度不够时，要用后面 <code>8</code> 字节的扩展长度字段，<code>Box Type</code> 还是 <code>mdat</code> 的 <code>ASCII</code> 码值</li><li>真实的数据字段是一个个 <code>NALU header</code> + <code>NALU Data</code>，但是没有用 <code>NALU</code> 的分解符 <code>00 00 00 01</code>, 是在每个 <code>NALU</code> 前面加了长度字段，和 <code>RTP</code> 打包类似</li><li>这里的 <code>NLAU</code> 一般不再包含 <code>SPS</code> <code>PPS</code> 等数据，这些数据已经放到 <code>moov Box</code> 里面了，至于是如何放到 <code>moov Box</code> 的，下面文章会讲解。这里一般 <code>NALU</code> 类型就是 <code>I\B\P</code> 帧数据以及 <code>SEI</code> 用户增强信息</li></ol><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201001516.png" alt="mdat box"></p><ul><li>Box Header<ul><li>Box Length: <code>0x00 25 4B F7</code> 表示该 <code>Box</code> 长度为 <code>2444279</code> 字节，即后面的 <code>NALU</code> 整个长度为 <code>2444279 - 8 = 2444271</code> 字节</li><li>Box type: <code>0x6D 64 61 74</code> 这就是 <code>mdat</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><code>free Box</code> 中的内容是无关紧要的，可以被忽略即该 <code>Box</code> 被删除后，不会对播放产生任何影响。这种类型的 <code>Box</code> 也不是必须的，可有可无，类似的 <code>Box</code> 还有 <code>sikp Box</code>. 虽然在解析是可以忽略，但是需要注意该 <code>Box</code> 的删除对其它 <code>Box</code> 的偏移量影响，特别是当 <code>moov Box</code> 放到 <code>mdat Box</code> 后面的情况。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201222436.png" alt="free box"></p><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 08</code> 表示该 <code>Box</code> 长度为 <code>9</code> 字节</li><li>Box type: <code>0x66 72 65 65</code> 这就是 <code>free</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data</li></ul><h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><p>从第二层开始，后续的每一层基本都封装于 <code>moov Box</code>。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201224431.png" alt="moov Box"></p><h3 id="mvhd"><a href="#mvhd" class="headerlink" title="mvhd"></a>mvhd</h3><p>这个 Box 也是全文件唯一的一个 Box, 一般处于 moov Box 的第一个子 Box, 这个 Box 对整个媒体文件所包含的媒体数据（包含 Video track 和 Audio Track 等）进行全面的描述。其中包含了媒体的创建和修改时间，默认音量、色域、时长等信息。</p><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201231209.png" alt="mvhd Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MovieHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;mvhd&quot;</span>, version, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 文件媒体在 1 秒时间内的刻度值，可以理解为 1 秒长度的时间单元数，这个只用来计算了该 Mp4 文件的长度，但是没有参与 PTS 和 DTS 的计算。</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 文件媒体在 1 秒时间内的刻度值，可以理解为 1 秒长度的时间单元数，这个只用来计算了该 Mp4 文件的长度，但是没有参与 PTS 和 DTS 的计算。</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> rate </span>= <span class="number">0x00010000</span>; <span class="comment">// 推荐播放速率，[16.16] 格式，1.0 表示 1 倍速播放</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> volume </span>= <span class="number">0x0100</span>;   <span class="comment">// 与 rate 类似，[8.8] 格式，1.0 表示最大音量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">bit</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">    const unsigned int(32)[2] reserved = 0;</span><br><span class="line">    template int(32)[9] matrix =</span><br><span class="line">    &#123;<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x40000000</span>&#125;; <span class="comment">// Unity matrix</span></span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">32</span>)[<span class="number">6</span>] pre_defined = <span class="number">0</span>;     <span class="comment">// 预览相关的信息，一般都是填充 0，所以不用太关心</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> next_track_ID</span>; <span class="comment">// 下一个 Track 使用的 id 号，通过该值减去 1 可以判断当前文件的 Track 数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 6c</code> 表示该 <code>Box</code> 长度为 <code>108</code> 字节</li><li>Box type: <code>0x6d 76 68 64</code> 这就是 <code>mvhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>creation time: <code>0x00 00 00 00</code></li><li>modification time: <code>0x00 00 00 00</code></li><li>time_scale: <code>0x00 00 03 E8</code> 代表 <code>1</code> 秒的时间单位是 <code>1000</code>，即把 <code>1</code> 秒划分为 <code>1000</code> 份，这样描述的更精确</li><li>duration: <code>0x00 00 46 68</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>18024/1000</code> 即 <code>18.024</code> 秒</li><li>rate: <code>0x00 01 00 00</code> 推荐采样原始倍速播放，一般就是 <code>1</code> 倍速进行播放该视频</li><li>volume: <code>01 00</code> 推荐采样原始视频音量进行播放</li><li>next_track_id: <code>0x00 00 00 03</code> 这个值表示如果要增加下一个 <code>Track</code> 时，需要的编号是 <code>3</code>，那同时也就说明本文件里面有 <code>2</code> 个 <code>Track</code>，实际发现刚好是 <code>2</code> 个 <code>Track</code></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201224755.png" alt="mvhd Mp4Explorer"></p><h3 id="iods"><a href="#iods" class="headerlink" title="iods"></a>iods</h3><p>这个 <code>Box</code> 也是非必须 <code>Box</code>，不算核心 <code>Box</code>, 实际也是 <code>24</code> 字节的固定值，解析时直接跳过即可。封装直接给填写固定 <code>24</code> 字节即可，注意该 <code>Box</code> 也是 Full <code>Box</code> 意味这 <code>Header</code> 里面有 <code>1</code> 字节的 <code>Version</code> 和 <code>3</code> 字节的 <code>Flag</code> 字段。</p><p>定义的内容应该是 <code>Audio</code> 和 <code>Video ProfileLevel</code> 方面的描述。但是现在没有用。</p><h3 id="trak"><a href="#trak" class="headerlink" title="trak"></a>trak</h3><p><code>trak Box</code> 定义了媒体文件中媒体中一个 <code>Track</code> 的信息，视频有 <code>Video Track</code>, 音频有 <code>Audio Track</code>，媒体文件中可以有多个 <code>Track</code>，每个 <code>Track</code> 具有自己独立的时间和空间的信息，可以进行独立操作。</p><p>每个 <code>trak Box</code> 都需要有一个 <code>tkhd Box</code> 和 <code>mdia Box</code>，其它的 <code>Box</code> 都是可选择的</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201233103.png" alt="trak Box"></p><p><code>Trak Box</code> 这里自身只是一个分界符，属于 <code>Container Box</code>，它的 <code>Box Data</code> 其实是其他的 <code>Box</code> 类型。</p><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 10 1E</code> 表示该 <code>Box</code> 长度为 <code>4126</code> 字节</li><li>Box type: <code>0x74 72 61 6B</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#tkhd">第三层 - tkhd</a></li><li>参见: <a href="#edts">第三层 - edts</a></li><li>参见: <a href="#mdia">第三层 - mdia</a></li></ul></li></ul><h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><h3 id="tkhd"><a href="#tkhd" class="headerlink" title="tkhd"></a>tkhd</h3><p><code>Container</code>: <code>Track Box</code> (<code>&quot;trak&quot;</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>该 <code>Box</code> 描述了该 <code>Track</code> 的媒体整体信息包括时长、图像的宽度和高度等，实际比较重要，同时该 <code>Box</code> 是 <code>Full Box</code> 即 <code>Box Header</code> 后面有 <code>Version</code> 和 <code>Flag</code> 字段。</p><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201234750.png" alt="tkhd Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class TrackHeaderBox extends <span class="title">FullBox</span><span class="params">(‘tkhd’, version, flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> track_ID</span>;          <span class="comment">// 唯一标识该 Track 的一个非零值</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> track_ID</span>;          <span class="comment">// 唯一标识该 Track 的一个非零值</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    const unsigned int(32)[2] reserved = 0;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> layer </span>= <span class="number">0</span>;             <span class="comment">// 视频层，值小的在上层</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> alternate_group </span>= <span class="number">0</span>;   <span class="comment">// Track 分组信息，一般默认为 0，表示该 Track 和其它 Track 没有建立群组关系</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> volume </span>= &#123;<span class="keyword">if</span> track_is_audio <span class="number">0x0100</span> <span class="keyword">else</span> <span class="number">0</span>&#125;; <span class="comment">// [8.8] 格式，1.0 表示最大音量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">    template int(32)[9] matrix=</span><br><span class="line">    &#123;<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x40000000</span>&#125;;</span><br><span class="line">    <span class="comment">// unity matrix</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">width</span></span>;     <span class="comment">// 如果该 Track 为 Video Track，则表示图像的宽度（16.16 浮点表示）</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">height</span></span>;    <span class="comment">// 如果该 Track 为 Video Track，则表示图像的高度（16.16 浮点表示）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 5c</code> 表示该 <code>Box</code> 长度为 <code>92</code> 字节</li><li>Box type: <code>0x74 6B 68 64</code> 这就是 <code>tkhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 03</code></li></ul></li><li>Box Data<ul><li>creation time: <code>0x00 00 00 00</code></li><li>modification time: <code>0x00 00 00 00</code></li><li>track_id: <code>0x00 00 00 01</code> 这是该 <code>Track</code> 的唯一标识</li><li>duration: <code>0x00 00 46 50</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>18000/1000</code> 即 <code>18</code> 秒</li><li>layer: <code>0x00 00</code></li><li>alternate_group: <code>0x00 00</code></li><li>volume: <code>00 00</code></li><li>width: <code>0x03 55 55 55</code> 表示该视频图像的宽度是 <code>853.21845</code></li><li>height: <code>0x01 e0 00 00</code> 表示该视频图像的宽度是 <code>480.0</code></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201235125.png" alt="tkhd Mp4Explorer"></p><h3 id="edts"><a href="#edts" class="headerlink" title="edts"></a>edts</h3><h3 id="mdia"><a href="#mdia" class="headerlink" title="mdia"></a>mdia</h3><ul><li><code>Container</code>: <code>Track Box</code> (<code>trak</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p>这个 <code>Box</code> 也是 <code>Container Box</code>，里面包含子 <code>Box</code>，一般必须有 <code>mdhd Box</code>、<code>hdlr Box</code>、<code>minf Box</code>。基本就是当前 <code>Track</code> 媒体头信息和媒体句柄以及媒体信息。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001301.png" alt="mdia Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;mdia&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 10 1E</code> 表示该 <code>Box</code> 长度为 <code>4126</code> 字节</li><li>Box type: <code>0x74 72 61 6B</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#hdlr">第四层 - mdhd</a></li><li>参见: <a href="#hdlr">第四层 - hdlr</a></li><li>参见: <a href="#minf">第四层 - minf</a></li></ul></li></ul><h2 id="第四层"><a href="#第四层" class="headerlink" title="第四层"></a>第四层</h2><h3 id="mdhd"><a href="#mdhd" class="headerlink" title="mdhd"></a>mdhd</h3><ul><li><code>Container</code>: <code>Media Box</code> (<code>mdia</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p>这个 <code>Box</code> 是 <code>Full Box</code>，意味这 <code>Box Header</code> 有 <code>Version</code> 和 <code>Flag</code> 字段，该 <code>Box</code> 里面主要定义了该 <code>Track</code> 的媒体头信息，其中我们最关心的两个字段是 <code>Time scale</code> 和 <code>Duration</code>，分别表示了该 <code>Track</code> 的时间戳和时长信息，这个时间戳信息也是 <code>PTS</code> 和 <code>DTS</code> 的单位。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001857.png" alt="mdhd Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;mdhd&quot;</span>, version, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 当前 Track 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 当前 Track 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 当前 Track 的时间计算单位</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 当前 Track 的播放时长，需要参考前面的 timescale 计算</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 当前 Track 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 当前 Track 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 当前 Track 的时间计算单位</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 当前 Track 的播放时长，需要参考前面的 timescale 计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">1</span>) pad = <span class="number">0</span>;</span><br><span class="line">    unsigned int(5)[3] language;            // 媒体语言码，参考 ISO-639-2/T</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> pre_defined </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 20</code> 表示该 <code>Box</code> 长度为 <code>32</code> 字节</li><li>Box type: <code>0x6d 64 68 64</code> 这就是 <code>mdhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>creation time: <code>0x00 00 00 00</code></li><li>modification time: <code>0x00 00 00 00</code></li><li>timescale: <code>0x00 00 30 00</code> 表示当前 <code>Track</code> 的时间戳单位是 <code>12288</code></li><li>duration: <code>0x00 03 60 00</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>221184/12288</code> 即 <code>18</code> 秒</li><li>language: <code>0x55 c4</code> 最高位为 <code>0</code>，后面 <code>15</code> 位代表三个字符<ul><li><code>0x55 c4</code> 转为二进制 <code>BIN: 01010101 11000100</code> 去掉首位 <code>0</code> 得到 <code>15</code> 位二进制数字</li><li>每 <code>5</code> 位二进制一组: <code>10101 01110 00100</code> 代表三个数字 <code>21</code>、<code>15</code>、<code>4</code></li><li>三个数字对应从 <code>a</code> 开始的第 <code>21</code>、<code>15</code>、<code>4</code> 个字母，即 <code>u</code>、<code>n</code>、<code>d</code>，查询 <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes">ISO 639-2/T</a> 可知其含义</li></ul></li><li>qualiiy: <code>0x00 00</code></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001924.png" alt="mdhd Mp4Explorer"></p><h3 id="hdlr"><a href="#hdlr" class="headerlink" title="hdlr"></a>hdlr</h3><p><code>Container</code>: <code>Media Box</code> (<code>mdia</code>) or <code>Meta Box</code> (<code>meta</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 <code>Box</code> 是 <code>Full Box</code>，该 <code>Box</code> 解释了媒体的播放过程信息，用来设置不同 <code>Track</code> 的处理方式，标识了该 <code>Track</code> 的类型。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202003746.png" alt="hdlr Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class HandlerBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;hdlr&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> pre_defined </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> handler_type</span>;  <span class="comment">// Handle 的类型: 视频: &#x27;vide&#x27;，音频: &#x27;soun&#x27;</span></span><br><span class="line">    const unsigned int(32)[3] reserved = 0;</span><br><span class="line">    <span class="built_in">string</span> name; <span class="comment">// 这个 component 的名字，其实这里就是你给该 Track 其的名字，打包时填写一个有意义字符串就可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 2d</code> 表示该 <code>Box</code> 长度为 <code>45</code> 字节</li><li>Box type: <code>0x68 64 6c 72</code> 这就是 <code>hdlr</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>handle type: <code>0x76 69 64 65</code> 即’vide’，代表当前 Track 为视频数据</li><li>name: <code>VideoHandler</code></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202003621.png" alt="hdlr Mp4Explorer"></p><h3 id="minf"><a href="#minf" class="headerlink" title="minf"></a>minf</h3><p><code>Container</code>: <code>Media Box</code> (<code>mdia</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 <code>Box</code> 是我认为 moov <code>Box</code> 里面最重要最复杂的 <code>Box</code>，内部还有子 <code>Box</code>。该 <code>Box</code> 建立了时间到真实音视频 <code>Sample</code> 的映射关系，对于音视频数据操作时很有帮助的。</p><p>同时该 <code>Box</code> 是 <code>Container Box</code>，下面一般含有三大必须的子 <code>Box</code>:</p><ul><li>媒体信息头 <code>Box</code>: <code>vmhd Box</code> 或者 <code>smhd Box</code>;</li><li>数据信息 <code>Box</code>: <code>dinf Box</code></li><li>采样表 <code>Box</code>:<code>stbl Box</code></li></ul><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202124113.png" alt="minf Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaInformationBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;minf&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 0f 41</code> 表示该 <code>Box</code> 长度为 <code>3905</code> 字节</li><li>Box type: <code>0x6d 69 6e 66</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#vmhd">第五层 - vmhd</a></li><li>参见: <a href="#smhd">第五层 - smhd</a></li><li>参见: <a href="#dinf">第五层 - dinf</a></li><li>参见: <a href="#stbl">第五层 - stbl</a></li></ul></li></ul><h2 id="第五层"><a href="#第五层" class="headerlink" title="第五层"></a>第五层</h2><h3 id="vmhd"><a href="#vmhd" class="headerlink" title="vmhd"></a>vmhd</h3><ul><li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p>这个 <code>Box</code> 的大小是固定的，大小是 <code>24</code> 字节，一般都是用默认值填充。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202125231.png" alt="vmhd Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class VideoMediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;vmhd&quot;</span>, version = <span class="number">0</span>, <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> graphicsmode </span>= <span class="number">0</span>; <span class="comment">// 视频合成模式，为 0 时拷贝原始图像，否则与 opcolor 进行合成</span></span><br><span class="line">    template unsigned int(16)[3] opcolor = &#123;0, 0, 0&#125;; // 颜色值，RGB 颜色值，&#123;R,G,B&#125; 一般默认 0x00 00 00 00 00 00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="smhd"><a href="#smhd" class="headerlink" title="smhd"></a>smhd</h3><ul><li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one specific media header shall be present</code></li></ul><p>这个 <code>Box</code> 的大小是固定的，大小是 <code>16</code> 字节，一般都是用默认值填充。</p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SoundMediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;smhd&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> balance </span>= <span class="number">0</span>;   <span class="comment">// 音频的均衡是用来控制计算机的两个扬声器的声音混合效果，一般是 0</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dinf"><a href="#dinf" class="headerlink" title="dinf"></a>dinf</h3><p><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>) or <code>Meta Box</code> (<code>meta</code>)<br><code>Mandatory</code>: <code>Yes</code> (required within <code>minf box</code>) and <code>No</code> (optional within <code>meta box</code>)<br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 <code>Box</code> 也是一个 <code>Container Box</code>，一般用来定位媒体信息。一般会包含一个 <code>dref Box</code> 即 <code>data reference box</code>，<code>dref</code> 下面会有若干个 <code>url Box</code> 或者也叫 <code>urn Box</code>，这些 <code>Box</code> 组成一个表，用来定位 <code>Track</code> 的数据。</p><p><code>Track</code> 可以被分成若干个段，每一段都可以根据 <code>Url</code> 或者 <code>Urn</code> 指向的地址来获取数据，<code>sample</code> 描述中会用这些片段的序号将这些片段组成一个完整的 <code>track</code>，一般情况下当数据完全包含在文件中，<code>Url</code> 和 <code>urn Box</code> 的字符串是空的。</p><p>这个 <code>Box</code> 存在的意义就是允许 <code>MP4</code> 文件的媒体数据分开最后还能进行恢复合并操作，但是实际上，<code>Track</code> 的数据都保存再文件中，所以该字段的重要性还体现不出来。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202130034.png" alt="dinf"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class DataInformationBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;dinf&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 24</code> 表示该 <code>Box</code> 长度为 <code>36</code> 字节</li><li>Box type: <code>0x64 69 6e 66</code> 这就是 <code>dinf</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#dref">第六层 - dref</a></li></ul></li></ul><h3 id="stbl"><a href="#stbl" class="headerlink" title="stbl"></a>stbl</h3><ul><li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202215751.png" alt="stbl"></p><p>stbl Box 同样是 Container Box，使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleTableBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;stbl&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 0f 01</code> 表示该 <code>Box</code> 长度为 <code>3841</code> 字节</li><li>Box type: <code>0x73 74 62 6c</code> 这就是 <code>stbl</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#stsd">第六层 - stsd</a></li><li>参见: <a href="#stts">第六层 - stts</a></li><li>参见: <a href="#stss">第六层 - stss</a></li><li>参见: <a href="#stsc">第六层 - stsc</a></li><li>参见: <a href="#stsz">第六层 - stsz</a></li><li>参见: <a href="#stco">第六层 - stco</a></li></ul></li></ul><h2 id="第六层"><a href="#第六层" class="headerlink" title="第六层"></a>第六层</h2><h3 id="dref"><a href="#dref" class="headerlink" title="dref"></a>dref</h3><p><code>Container</code>: <code>Data Information Box</code> (<code>dinf</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>由于 <code>Track</code> 可以分为多个段，所以该 <code>Box</code> 是用来定义当前 <code>Track</code> 各个段的 <code>URL</code> 或 <code>URN</code>。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202130842.png" alt="dref"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">DataEntryUrlBox</span> <span class="params">(<span class="built_in">bit</span>(<span class="number">24</span>) flags)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;url&quot;</span>, version = <span class="number">0</span>, flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> location;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">DataEntryUrnBox</span> <span class="params">(<span class="built_in">bit</span>(<span class="number">24</span>) flags)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;urn&quot;</span>, version = <span class="number">0</span>, flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> location;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class DataReferenceBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;dref&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        DataEntryBox(entry_version, entry_flags) data_entry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 1c</code> 表示该 <code>Box</code> 长度为 <code>28</code> 字节</li><li>Box type: <code>0x64 72 65 66</code> 这就是 <code>dref</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>url</code> 列表数量是 <code>1</code>，只有一个 <code>url Box</code></li><li>URL Box 1<ul><li>Box Length: <code>0x00 00 00 0c</code> 表示该 <code>Box</code> 长度为 <code>12</code> 字节</li><li>Box type: <code>0x75 72 6c 20</code> 这就是 <code>&quot;url&quot;</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 01</code></li></ul></li></ul></li></ul><h3 id="stsd"><a href="#stsd" class="headerlink" title="stsd"></a>stsd</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>该 <code>Box</code> 存储了编码类型和初始化解码器需要的信息，于特定的 <code>track-type</code> 有关，根于不同的 <code>Track</code> 使用不一样的编码标准。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202220310.png" alt="stsd"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">abstract class <span class="title">SampleEntry</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) format)</span> extends <span class="title">Box</span><span class="params">(format)</span></span>&#123;</span><br><span class="line">    const unsigned int(8)[6] reserved = 0;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> data_reference_index</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">class BitRateBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;btrt&quot;</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> bufferSizeDB</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> maxBitrate</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> avgBitrate</span>;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">SampleDescriptionBox</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) handler_type)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsd&quot;</span>, version, <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;   <span class="comment">//sample description 数目, 同时不同的 Track 有不同的 sample description</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= entry_count ; i++)&#123;</span><br><span class="line">        SampleEntry(); <span class="comment">// an instance of a class derived from SampleEntry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 01 09</code> 表示该 <code>Box</code> 长度为 <code>265</code> 字节</li><li>Box type: <code>0x73 74 73 64</code> 这就是 <code>stsd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>Sample Description Box</code> 列表数量是 <code>1</code></li><li>Sample Description Box: 参见文档 ISO-IEC 14496-15 AVC file format</li></ul></li></ul><h3 id="stts"><a href="#stts" class="headerlink" title="stts"></a>stts</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 Box 是 <code>Sample number</code> 和解码时间 <code>DTS</code> 之间的映射表，通过这个表格，我们可以找到任何时间的 <code>Sample</code>，但用这个表格只是能找到当前时间的 <code>Sample</code> 的序号，<code>Sample</code> 的长度和指针还要靠其它表格获取。</p><p><code>Sample delta</code> 简单可以理解为采样点 <code>Sample</code> 的 <code>duration</code>，所有 <code>duration</code> 相加应该为总的 <code>Track</code> 的时长。大家把这个时间理解为该帧数据当前的解码时间即可，计算公式：</p><pre><code>DT(n+1) = DT(n) + STTS(n)</code></pre><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203130420.png" alt="stts"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class TimeToSampleBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stts&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_count</span>;  <span class="comment">// 连续相同时间长度 `sample delta` 的 `sample` 个数</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_delta</span>;  <span class="comment">// 每个 `sample delta` 以 `timescale` 为单位的时间长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 74 73</code> 这就是 <code>stts</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>sample conut</code> 和 <code>sample delta</code> 组成的二元组信息个数 列表数量是 <code>1</code></li><li>entry 1<ul><li>sample conut: <code>0x00 00 01 b0</code> 值为 <code>sample delta</code> 的 <code>sample</code> 个数为 <code>432</code> 个</li><li>sample delta: <code>0x00 00 02 00</code> 值为 <code>512</code>，这样我们计算出帧率就是 <code>12288/512</code> 即 <code>24fps</code>，参见 <a href="#mdhd">第四层 - mdhd</a>。</li></ul></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203131946.png" alt="stts Mp4Explorer"></p><h3 id="ctts"><a href="#ctts" class="headerlink" title="ctts"></a>ctts</h3><h3 id="stss"><a href="#stss" class="headerlink" title="stss"></a>stss</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p><code>I</code> 帧是播放的起始位置，只有编码器拿到第一个 <code>I</code> 帧才能渲染出第一幅画面。所以后续的一些特殊随机操作，高标清切换时都需要找 <code>I</code> 帧，只有随机找到 <code>I</code> 帧才能完成这些特殊操作。</p><p>其中该 <code>Box</code> 就是存储了那些 <code>Sample</code> 是 <code>I</code> 帧，很显然音频 <code>Track</code> 也是不存在这个 <code>Box</code> 的。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203132044.png" alt="stss"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SyncSampleBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stss&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;           <span class="comment">// 关键帧的 sample 个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_number</span>;     <span class="comment">// 关键帧 sample 序号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 73 73</code> 这就是 <code>stss</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 02</code> 说明本文件有 <code>2</code> 个关键帧</li><li>sample number 1: <code>0x00 00 00 01</code> 关键帧 <code>1</code> 的 <code>Sample</code> 序号为 <code>1</code></li><li>sample number 2: <code>0x00 00 00 fb</code> 关键帧 <code>2</code> 的 <code>Sample</code> 序号为 <code>251</code></li></ul></li></ul><h3 id="stsc"><a href="#stsc" class="headerlink" title="stsc"></a>stsc</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 <code>Box</code> 就是说明那些 <code>Sample</code> 可以划分为一个 <code>Trunk</code></p><p>媒体数据被分为若干个 <code>Chunk</code>, <code>Chunk</code> 可以有不同的大小，同一个 <code>Chunk</code> 中的样点 <code>Sample</code> 也允许有不同的大小；通过本表可以定位一个样点的 <code>Chunk</code> 位置，并可以得知该 <code>MP4</code> 中有多少个 <code>Chunks</code>，每个 <code>Chunks</code> 有多少个 <code>Samples</code>。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203132226.png" alt="stsc"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleToChunkBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsc&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="comment">/* 具有相同采样点 sample 和 `sample_description_index 的 chunk 中，第一个 chunk 的索引值</span></span><br><span class="line"><span class="comment">        ** 也就是说该 chunk 索引值一直到下一个索引值之间的所有 chunk 都具有相同的 sample 个数</span></span><br><span class="line"><span class="comment">        ** 同时这些 sample 的描述 description 也一样； */</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> first_chunk</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> samples_per_chunk</span>;         <span class="comment">// 上面所有 chunk 的 sample 个数</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_description_index</span>;  <span class="comment">// 描述采样点的采样描述项的索引值，范围为 1 到样本描述表中的表项数目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 73 73</code> 这就是 <code>stss</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 01</code> 这说明三元组信息的个数只有 <code>1</code> 个</li><li>first chunk 1: <code>0x00 00 00 01</code> 具有相同 <code>Sample</code> 个数和 <code>description</code> 的 <code>Chunk</code> 起始索引是 <code>1</code></li><li>samples per chunk 1: <code>0x00 00 00 01</code> 每个 <code>Chunk</code> 具有的 <code>Sample</code> 的个数是 <code>1</code></li><li>sample description index 1 <code>0x00 00 00 01</code> 这些 <code>Sample</code> 的 <code>description index</code> 是 1，一般用默认值即可</li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203231441.png" alt="stsc Mp4Explorer"></p><h3 id="stsz"><a href="#stsz" class="headerlink" title="stsz"></a>stsz</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one variant must be present</code></p><p>前面分析了 <code>Sample</code> 的 <code>PTS</code>、<code>DTS</code> 等，也分析了 <code>Chunk</code> 里面 <code>Sample</code> 的信息，但是没有分析 <code>Sample</code> 的大小，这是我们在文件读取和解析 <code>Sample</code> 的关键。这里给出每个 <code>Sample</code> 的 <code>Size</code> 即包含的字节数。</p><p>包含了媒体中全部 <code>Sample</code> 的数目和一张给出每个 <code>Sample</code> 大小的表。这个 <code>Box</code> 相对来说体积是比较大的。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203233016.png" alt="stsz"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleSizeBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsz&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_size</span>;   <span class="comment">// 指定默认的 Sample 大小，如果每个 Sample 大小不相等，则这个字段值为 0，每个 Sample 大小存在下表中</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_count</span>;  <span class="comment">// 该 Track 中所有 Sample 的数量</span></span><br><span class="line">    <span class="keyword">if</span> (sample_size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sample_count; i++) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_size</span>;    <span class="comment">// 每个 Sample 的大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 06 d4</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 73 7a</code> 这就是 <code>stsz</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>sample size: <code>0x00 00 00 00</code> 说明 <code>Sample</code> 的具体大小在表后面项目中的 <code>entry size</code></li><li>sample count: <code>0x00 00 01 b0</code> 说明本 <code>Track</code> 的大小为 <code>432</code> 个 <code>Sample</code></li><li>entry size 1: <code>0x00 00 73 5f</code> 说明第一个 <code>Sample</code> 大小为 <code>29535</code> 字节</li><li>entry size 2: <code>0x00 00 06 e6</code> 说明第二个 <code>Sample</code> 大小为 <code>1766</code> 字节</li><li>entry size 3: <code>0x00 00 1f be</code> 说明第三个 <code>Sample</code> 大小为 <code>8126</code> 字节</li><li>entry size 4: <code>0x00 00 1b e2</code> 说明第四个 <code>Sample</code> 大小为 <code>7138</code> 字节</li><li>entry size 5: <code>0x00 00 25 eb</code> 说明第五个 <code>Sample</code> 大小为 <code>9707</code> 字节</li><li>…</li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203232256.png" alt="stsz Mp4Explorer"></p><h3 id="stco-co64"><a href="#stco-co64" class="headerlink" title="stco | co64"></a>stco | co64</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one variant must be present</code></p><p>该 <code>Box</code> 存储了 <code>Chunk Offset</code>，表示了每个 <code>Chunk</code> 在文件中的位置，这样我们就能找到了 <code>Chunk</code> 在文件的偏移量，然后根据其它表的关联关系就可以读取每个 <code>Sample</code> 的大小。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201204000004.png" alt="stco"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class ChunkOffsetBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stco&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> chunk_offset</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class ChunkLargeOffsetBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;co64&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> chunk_offset</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 06 d0</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 63 6f</code> 这就是 <code>stco</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 01 b0</code> 说明本 <code>Track</code> 的大小为 <code>432</code> 个 <code>Sample</code></li><li>chunk offset 1: <code>0x00 00 00 43</code> 说明本文件第一个 <code>Chunk</code> 的偏移量是 <code>67</code> 字节</li><li>chunk offset 2: <code>0x00 00 74 a2</code> 说明本文件第二个 <code>Chunk</code> 的偏移量是 <code>29858</code> 字节</li><li>chunk offset 3: <code>0x00 00 7e 35</code> 说明本文件第三个 <code>Chunk</code> 的偏移量是 <code>32309</code> 字节</li><li>chunk offset 4: <code>0x00 00 a0 53</code> 说明本文件第四个 <code>Chunk</code> 的偏移量是 <code>41043</code> 字节</li><li>chunk offset 5: <code>0x00 00 be 3f</code> 说明本文件第五个 <code>Chunk</code> 的偏移量是 <code>48703</code> 字节</li><li>…</li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201204000821.png" alt="stco Mp4Explorer"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="/slave/MP4/ISO-IEC-14496-12-Base-Format-2015.pdf">ISO/IEC 14496-12</a></li><li>[2] <a href="/slave/MP4/ISO-IEC-14496-14-MP4-2003.pdf">ISO/IEC 14496-14</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;mp4&lt;/code&gt; 文件封装格式，对应的标准为 &lt;code&gt;ISO/IEC 14496-12&lt;/code&gt; 和 &lt;code&gt;ISO/IEC 14496-14&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ISO/IEC 14496-12&lt;/code&gt; 定义了一种封装媒体数据的基础文件格式，&lt;code&gt;mp4&lt;/code&gt;、&lt;code&gt;3gp&lt;/code&gt;、&lt;code&gt;ismv&lt;/code&gt; 等我们常见媒体封装格式都是以这种基础文件格式为基础衍生的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ISO/IEC 14496-14&lt;/code&gt; 基于 &lt;code&gt;ISO-14496-12&lt;/code&gt; 定义了 &lt;code&gt;mp4&lt;/code&gt; 文件格式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="封装格式" scheme="http://github.hezhaojiang.io/tags/%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - TS 封装解析示例</title>
    <link href="http://github.hezhaojiang.io/post/2020/a03a01c2/"/>
    <id>http://github.hezhaojiang.io/post/2020/a03a01c2/</id>
    <published>2020-11-27T08:13:10.000Z</published>
    <updated>2020-11-29T16:06:36.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章 <a href="/post/2020/c6ae0d94/" title="音视频封装 - TS 封装格式">音视频封装 - TS 封装格式</a> 中分析了 <code>TS</code> 流的结构，本文通过一段真实的码流的分析来加强对 <code>TS</code> 流结构的理解。</p><blockquote><p>注 1：本文中的 <code>TS</code> 码流截取自一段从网络下载的网络视频</p></blockquote><a id="more"></a><h2 id="PAT-包解析"><a href="#PAT-包解析" class="headerlink" title="PAT 包解析"></a>PAT 包解析</h2><p>该段码流中第一包并不是 <code>PAT</code> 包，而 TS 封装的解析需要从 <code>PAT</code> 包开始，所以我们向后寻找 PID 为 0 的第一包，该段码流中第二包 PID 为 0，是一个 <code>PAT</code> 包：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128145341.png" alt="Packet 2"></p><p>第一部分：<code>TS</code> 包头</p><pre><code>HEX 47       40       00       10BIN 01000111 01000000 00000000 00010000</code></pre><p>对比该部分结构，可代码定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_HEAD</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> sync_byte                    : <span class="number">8</span>;  <span class="comment">// 同步字节，固定为 0x47</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_error_indicator    : <span class="number">1</span>;  <span class="comment">// 传输错误指示符，0 表明在 TS 头的 adapt 域后没有无用字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> payload_unit_start_indicator : <span class="number">1</span>;  <span class="comment">// 负载单元起始标示符，一个完整的数据包开始时标记为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_priority           : <span class="number">1</span>;  <span class="comment">// 传输优先级，0 为低优先级</span></span><br><span class="line">    <span class="keyword">unsigned</span> pid                          : <span class="number">13</span>; <span class="comment">// PID 值，0 表示 TS 头后面就是 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_scrambling_controls    : <span class="number">2</span>;  <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> adaptation_field_control         : <span class="number">2</span>;  <span class="comment">// 是否包含自适应区，&#x27;01&#x27;为无自适应域，仅含有效负载</span></span><br><span class="line">    <span class="keyword">unsigned</span> continuity_counter               : <span class="number">4</span>;  <span class="comment">// 递增计数器，0-F，起始值不一定取 0，但必须是连续的</span></span><br><span class="line">&#125; TS_HEAD;</span><br></pre></td></tr></table></figure><p>第二部分：<code>TS</code> 包调整字节</p><pre><code>HEX 00BIN 00000000</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> adaptation_field_length;  <span class="comment">// 自适应域长度，后面的字节数，此包中为 7 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flag;                     <span class="comment">// 0x50 表示包含 PCR，0x40 表示不包含 PCR</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0x50</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> PCR[<span class="number">5</span>]; <span class="comment">// 节目时钟参考 40bit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字节，取值 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>adaptation_field_length</code> 为 <code>0</code>，故该部分后续字节数为 <code>0</code>。</p><p>第三部分：<code>TS</code> 包有效载荷 - 即 <code>PSI</code> 表 <code>PAT</code> 的数据：</p><pre><code>HEX 00 B0 0D 00 01 C1 00 00  00 01 F0 00 2A B1 04 B2BIN 00000000 10110000 00001101 00000000 00000001 11000001 00000000 00000000    00000000 00000001 11110000 00000000 00101010 10110001 00000100 10110010</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 固定 0x00 ，标志是该表是 PAT</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，0000 00001101 值为 13</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_stream_id          : <span class="number">16</span>; <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PAT 版本号，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 固定为 1，表示这个 PAT 表有效，如果为 0 则要等待下一个 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PAT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 最后一个分段的号码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PAT_Program&gt; program; = &#123;    <span class="comment">// 该包中仅有一个 TS_PAT_Program</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> program_number       :<span class="number">16</span>;  <span class="comment">// 节目号，为 0x0000 时表示这是 NIT，节目号为 0x0001 时, 表示这是 PMT</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved             :<span class="number">3</span>    <span class="comment">// 保留，固定为 111</span></span><br><span class="line">            <span class="keyword">if</span> (program_number == <span class="number">0x0000</span>)</span><br><span class="line">                <span class="keyword">unsigned</span> network_PID      :<span class="number">13</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (program_number == <span class="number">0x0001</span>)</span><br><span class="line">                <span class="keyword">unsigned</span> program_map_PID  :<span class="number">13</span>;  <span class="comment">// 节目号对应内容的 PID 值，该 PAT 包取值为 0x1000 = 4096</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PAT;</span><br></pre></td></tr></table></figure><h2 id="PMT-包解析"><a href="#PMT-包解析" class="headerlink" title="PMT 包解析"></a>PMT 包解析</h2><p><code>PAT</code> 信息中可知 <code>PMT</code> 表的 <code>PID</code> 为 <code>4096</code>，我们向后寻找 <code>PID</code> 为 <code>4096</code> 的 <code>TS</code> 包，发现第 <code>3</code> 包 <code>TS</code> 包即为 <code>PMT</code> 包：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128155219.png" alt="PMT"></p><p>第一部分：<code>TS</code> 包头</p><pre><code>HEX 47       50       00       10BIN 01000111 01010000 00000000 00010000</code></pre><p>从 <code>TS</code> 包头可知该 <code>TS</code> 包的 <code>PID</code> 值为 <code>4096</code>，是我们寻找的 <code>PMT</code> 包。</p><p>第二部分：<code>TS</code> 包调整字节，该部分只有一个字节 <code>0x00</code>，详见上文解析，此处不再重复。</p><p>第三部分：<code>TS</code> 包有效载荷 - <code>PMT</code></p><pre><code>HEX 02 B0 23 00 01 C1 00 00  E1 00 F0 00 24 E1 00 F0    06 05 04 48 45 56 43 03  E1 01 F0 06 0A 04 75 6E    64 00 DD 33 FC 6ABIN 00000010 10110000 00100011 00000000 00000001 11000001 00000000 00000000    11100001 00000000 11110000 00000000 00100100 11100001 00000000 11110000    00000110 00000101 00000100 01001000 01000101 01010110 01000011 00000011    11100001 00000001 11110000 00000110 00001010 00000100 01110101 01101110    01100100 00000000 11011101 00110011 11111100 01101010</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 取值随意，一般使用 0x02, 表示 PMT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，0000 00100011 = 35 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number               : <span class="number">16</span>; <span class="comment">// 当前 PMT 表映射到的节目号，1、2、3</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PMT 版本号码，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 发送的 PMT 表， 1 当前有效 PMT 有效</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PMT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 分段数</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_3                   : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> PCR_PID                      : <span class="number">13</span>; <span class="comment">// 指明 TS 包的 PID 值 (0x0100 = 256)，该 TS 包含有 PCR 同步时钟，</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_4                   : <span class="number">4</span>;  <span class="comment">// 预留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_info_length          : <span class="number">12</span>; <span class="comment">// 前 2bit 为 00，该域指出跟随其后对节目信息的描述的字节数 (0x000 = 0)。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;      <span class="comment">// 0 字节</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PMT_Stream&gt; PMT_Stream = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> stream_type          : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，H.265 编码对应 0x24</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved1            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">            <span class="keyword">unsigned</span> elementary_PID       : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值 (0x100 = 256)</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved2            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">            <span class="keyword">unsigned</span> ES_info_length       : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数 (0x006 = 6)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;   <span class="comment">// 6 字节</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> stream_type          : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，MP3 编码对应 0x03</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved1            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">            <span class="keyword">unsigned</span> elementary_PID       : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值 (0x101 = 257)</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved2            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">            <span class="keyword">unsigned</span> ES_info_length       : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数 (0x006 = 6)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;   <span class="comment">// 6 字节</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PMT;</span><br></pre></td></tr></table></figure><p><code>PMT</code> 是定义每路节目的音视频类型 <code>TYPE</code> 和编号 <code>PID</code> 的关键，该 <code>TS</code> 码流中：</p><pre><code>- 视频流格式为 `H.265`，对应 `PID` 为 `256`- 视频流格式为 `MP3`，对应 `PID` 为 `257`</code></pre><h2 id="视频包解析"><a href="#视频包解析" class="headerlink" title="视频包解析"></a>视频包解析</h2><p>第 <code>4</code> 包的 <code>PID</code> 值为 <code>256</code>，根据上述分析可知，该包为一个视频包：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128163234.png" alt="视频包"></p><p>第一部分：<code>TS</code> 包头</p><pre><code>HEX 47       41       00       30BIN 01000111 01000001 00000000 00110000</code></pre><p>从 <code>TS</code> 包头可知该 <code>TS</code> 包的 <code>PID</code> 值为 <code>256</code>，是我们寻找的视频包，另外，TS 包头中 <code>adaptation_field_control</code> 字段为 <code>11</code>，代表同时带有自适应域和有效负载。</p><p>第二部分：<code>TS</code> 包调整字节</p><pre><code>HEX 07 50 00 00 7C F7 7E 00BIN 00000111 01010000 00000000 00000000 01111100 11110111 01111110 00000000</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> adaptation_field_length;  <span class="comment">// 自适应域长度，后面的字节数，此包中为 7 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flag;                     <span class="comment">// 0x50 表示包含 PCR</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0x50</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> PCR[<span class="number">5</span>]; <span class="comment">// 节目时钟参考 40bit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字节，取值 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三部分：<code>TS</code> 包有效载荷 - <code>PES</code></p><pre><code>HEX 00 00 01 E0 00 00 80 80  05 21 00 07 E0 0DBIN 00000000 00000000 00000001 11100000 00000000 00000000 10000000 10000000    00000101 00100001 00000000 00000111 11100000 00001101</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> start_code_prefix        : <span class="number">24</span>; <span class="comment">// 包头起始码，固定为 0x000001</span></span><br><span class="line">    <span class="keyword">unsigned</span> stream_id;               : <span class="number">8</span>;  <span class="comment">// PES 包中的负载流类型，一般视频为 0xe0，音频为 0xc0</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_packet_length        : <span class="number">16</span>; <span class="comment">// PES 包长度，包括此字节后的可选包头和负载的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1               : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 10</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_scrambling_control   : <span class="number">2</span>;  <span class="comment">// 加密模式，00 未加密，01 或 10 或 11 由用户定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_priority             : <span class="number">1</span>;  <span class="comment">// 有效负载的优先级，值为 1 比值为 0 的负载优先级高</span></span><br><span class="line">    <span class="keyword">unsigned</span> Data_alignment_indicator : <span class="number">1</span>;  <span class="comment">// 数据定位指示器</span></span><br><span class="line">    <span class="keyword">unsigned</span> Copyright                : <span class="number">1</span>;  <span class="comment">// 版权信息，1 为有版权，0 无版权</span></span><br><span class="line">    <span class="keyword">unsigned</span> Original_or_copy         : <span class="number">1</span>;  <span class="comment">// 原始或备份，1 为原始，0 为备份</span></span><br><span class="line">    <span class="keyword">unsigned</span> PTS_DTS_flags            : <span class="number">2</span>;  <span class="comment">// PTS 和 DTS 标志位，10 表示首部有 PTS 字段，11 表示有 PTS 和 DTS 字段，00 表示都没有，01 被禁止</span></span><br><span class="line">    <span class="keyword">unsigned</span> ESCR_flag                : <span class="number">1</span>;  <span class="comment">// ESCR 标志，1 表示首部有 ESCR 字段，0 则无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> ES_rate_flag             : <span class="number">1</span>;  <span class="comment">// ES_rate 字段，1 表示首部有此字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> DSM_trick_mode_flag      : <span class="number">1</span>;  <span class="comment">// 1 表示有 8 位的 DSM_trick_mode_flag 字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> Additional_copy_info_flag: <span class="number">1</span>;  <span class="comment">// 1 表示首部有此字段，0 表示无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_CRC_flag             : <span class="number">1</span>;  <span class="comment">// 1 表示 PES 分组有 CRC 字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_extension_flag       : <span class="number">1</span>;  <span class="comment">// 扩展标志位，置 1 表示有扩展字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_header_data_length   : <span class="number">8</span>;  <span class="comment">// PES 首部中可选字段和填充字段的长度，可选字段的内容由上面 7 个 flags 来进行控制</span></span><br><span class="line">    if (PTS_DTS_flags == &#x27;10&#x27;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> reserved_1           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0010</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_32_30            : <span class="number">3</span>;  <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_29_15            : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_14_0             : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (PTS_DTS_flags == &#x27;11&#x27;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> reserved_1           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0011</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_32_30            : <span class="number">3</span>;  <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_29_15            : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_14_0             : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> reserved_2           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0001</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_32_30            : <span class="number">3</span>;  <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_29_15            : <span class="number">15</span>; <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_14_0             : <span class="number">15</span>; <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ESCR_flag) ...</span><br><span class="line">    <span class="keyword">if</span> (ES_rate_flag) ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (PES_extension_flag) ...</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字段，固定为 0xFF，不得超过 32 字节</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; PES_packet_data_byte <span class="comment">// PES 包的负载数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比代码和码流数据，发现码流中 <code>PES_packet_length</code> 值为 <code>0</code>，其表示 <code>PES</code> 分组长度要么没有规定要么没有限制。这种情况只允许出现在有效负载包含来源于传输流分组中某个视频基本流的字节的 <code>PES</code> 分组中。</p><p>该段视频流中 <code>PTS_DTS_flags == &#39;10&#39;</code>，故其还有 <code>5</code> 字节的 <code>PTS</code> 信息，我们尝试解析 <code>PTS</code> 信息：</p><ol><li><code>PTS</code> 的 <code>5</code> 字节信息为 <code>21 00 07 E0 0D</code>，对应二进制 <code>00100001 00000000 00000111 11100000 00001101</code></li><li>除去 <code>reserved</code> 和 <code>marker</code> 字段为 <code>000 00000000 0000011 11100000 0000110</code></li><li>整理可得 <code>0 00000000 00000001 11110000 00000110</code>，即 <code>0x001F006</code></li><li>转为十进制为 <code>126982</code>，与工具计算结果一致</li></ol><p><code>PES</code> 包头数据分析完，剩下的数据就是帧视频数据的一部分了。</p><h2 id="音频包解析"><a href="#音频包解析" class="headerlink" title="音频包解析"></a>音频包解析</h2><p>音频包与视频包均使用 <code>PES</code> 格式封装，解析方式基本一致，比如：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128192950.png" alt="音频包"></p><p>音频包中第三部分：<code>TS</code> 包有效载荷 - <code>PES</code></p><pre><code>HEX 00 00 01 C0 09 D3 80 80 05 21 00 07 D8 61 FFBIN 00000000 00000000 00000001 11000000 00001001 11010011 10000000 10000000    00000101 00100001 00000000 00000111 11011000 01010001 11111111</code></pre><p>该段视频流中 <code>PTS_DTS_flags == &#39;10&#39;</code>，故其也有 <code>5</code> 字节的 <code>PTS</code> 信息，我们尝试解析 <code>PTS</code> 信息：</p><ol><li><code>PTS</code> 的 <code>5</code> 字节信息为 <code>21 00 07 D8 61</code>，对应二进制 <code>00100001 00000000 00000111 11011000 01100001</code></li><li>除去 <code>reserved</code> 和 <code>marker</code> 字段为 <code>000 00000000 0000011 11011000 0110000</code></li><li>整理可得 <code>0 00000000 00000001 11101100 00110000</code>，即 <code>0x001EC30</code></li><li>转为十进制为 <code>126000</code>，与工具计算结果一致</li></ol><p><code>PES</code> 包头数据分析完，剩下的数据就音频数据的一部分了。</p><ul><li>[1] <a href="https://cloud.tencent.com/developer/article/1746983">音视频封装：MPTG2-TS 媒体封装实例解析和说明 - 云 + 社区 - 腾讯云</a></li><li>[2] <a href="/post/2020/c6ae0d94/" title="音视频封装 - TS 封装格式">音视频封装 - TS 封装格式</a></li><li>[3] <a href="https://github.com/daniep01/MPEG-2-Transport-Stream-Packet-Analyser">daniep01/MPEG-2-Transport-Stream-Packet-Analyser: MPEG-2 Transport Stream packet analyser…</a></li><li>[4] 文中 <code>TS</code> 码流视频源文件：<a href="/slave/TS/TestVideoTS.7z" title="密码：github.com">点击下载</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章 &lt;a href=&quot;/post/2020/c6ae0d94/&quot; title=&quot;音视频封装 - TS 封装格式&quot;&gt;音视频封装 - TS 封装格式&lt;/a&gt; 中分析了 &lt;code&gt;TS&lt;/code&gt; 流的结构，本文通过一段真实的码流的分析来加强对 &lt;code&gt;TS&lt;/code&gt; 流结构的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注 1：本文中的 &lt;code&gt;TS&lt;/code&gt; 码流截取自一段从网络下载的网络视频&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="封装格式" scheme="http://github.hezhaojiang.io/tags/%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - TS 封装格式</title>
    <link href="http://github.hezhaojiang.io/post/2020/c6ae0d94/"/>
    <id>http://github.hezhaojiang.io/post/2020/c6ae0d94/</id>
    <published>2020-11-27T06:47:00.000Z</published>
    <updated>2020-12-14T15:24:41.145Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>TS</code> 全称是 <code>MPEG2-TS</code>，<code>MPEG2-TS</code> 是一种标准容器格式，传输与存储音视频、节目与系统信息协议数据，广泛应用于数字广播系统，我们日常数字机顶盒接收到的就是 <code>TS</code>（<code>Transport Stream</code>，传输流）流。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先需要先分辨 <code>TS</code> 传输流中几个基本概念：</p><ul><li><code>ES</code> (<code>Elementary Stream</code>)：基本流，直接从编码器出来的数据流，可以是编码过的音频、视频或其他连续码流</li><li><code>PES</code> (<code>Packetized Elementary Streams</code>)：<code>PES</code> 流是 <code>ES</code> 流经过 <code>PES</code> 打包器处理后形成的数据流，在这个过程中完成了将 <code>ES</code> 流分组、加入包头信息（<code>PTS</code>、<code>DTS</code> 等）操作。<code>PES</code> 流的基本单位是 <code>PES</code> 包，<code>PES</code> 包由包头和 payload 组成</li><li><code>PS</code> 流 (<code>Program Stream</code>)：节目流，PS 流由 PS 包组成，而一个 PS 包又由若干个 <code>PES</code> 包组成。一个 PS 包由具有同一时间基准的一个或多个 <code>PES</code> 包复合合成。</li><li><code>TS</code> 流 (<code>Transport Stream</code>)：传输流，<code>TS</code> 流由固定长度（<code>188</code> 字节）的 <code>TS</code> 包组成，<code>TS</code> 包是对 <code>PES</code> 包的另一种封装方式，同样由具有同一时间基准的一个或多个 <code>PES</code> 包复合合成。PS 包是不固定长度，而 <code>TS</code> 包为固定长度。</li></ul><h2 id="TS-文件"><a href="#TS-文件" class="headerlink" title="TS 文件"></a>TS 文件</h2><p><code>TS</code> 文件分为三次：<code>TS</code> 层、<code>PES</code> 层、<code>ES</code> 层。<code>ES</code> 层就是音视频数据，<code>PES</code> 层是在音视频数据上加了时间戳等数据帧的说明信息，<code>TS</code> 层是在 <code>PES</code> 层上加入了数据流识别和传输的必要信息。</p><pre><code>+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  TS   |  =  |  Packet 1 |  Packet 2 |  Packet 3 |    ...    | Packet n-1|  Packet n |+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+One Packet:          4bytes              184bytes+-+-+-+-+-+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Packet  | =  | Packet header |       Packet data       |+-+-+-+-+-+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><h2 id="TS-层"><a href="#TS-层" class="headerlink" title="TS 层"></a>TS 层</h2><p><code>TS</code> 包大小固定为 <code>188</code> 字节，<code>TS</code> 层分为三个部分：<code>TS header</code>、<code>adaptation field</code>、<code>payload</code>：</p><ul><li><code>TS header</code> 固定 <code>4</code> 个字节</li><li><code>adaptation field</code> 可能存在也可能不存在，主要作用是给不足 <code>188</code> 字节的数据做填充</li><li><p><code>payload</code> 是 <code>PES</code> 数据</p><p>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>  | TS header |  adaptation field |          payload(PES)       |<br>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p></li></ul><h3 id="TS-header"><a href="#TS-header" class="headerlink" title="TS header"></a>TS header</h3><pre><code>|0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|       ①       |②|③|④|             ⑤           | ⑥ | ⑦ |   ⑧   |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><div class="table-container"><table><thead><tr><th>序号</th><th>名称</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>sync_byte</td><td>8bit</td><td>同步字节，固定为 0x47</td></tr><tr><td>2</td><td>transport_error_indicator</td><td>1bit</td><td>传输错误指示符，表明在 TS 头的 adapt 域后由一个无用字节，通常都为 0，这个字节算在 adapt 域长度内</td></tr><tr><td>3</td><td>payload_unit_start_indicator</td><td>1bit</td><td>负载单元起始标示符，一个完整的数据包开始时标记为 1</td></tr><tr><td>4</td><td>transport_priority</td><td>1bit</td><td>传输优先级，0 为低优先级，1 为高优先级，通常取 0</td></tr><tr><td>5</td><td>PID</td><td>13bit</td><td>PID 值</td></tr><tr><td>6</td><td>transport_scrambling_control</td><td>2bit</td><td>传输加扰控制，00 表示未加密</td></tr><tr><td>7</td><td>adaptation_field_control</td><td>2bit</td><td>是否包含自适应区，’00’保留；’01’为无自适应域，仅含有效负载；’10’为仅含自适应域，无有效负载；’11’为同时带有自适应域和有效负载。</td></tr><tr><td>8</td><td>continuity_counter</td><td>4bit</td><td>递增计数器，从 0-f，起始值不一定取 0，但必须是连续的</td></tr></tbody></table></div><p><code>TS</code> 层的内容是通过 <code>PID</code> 值来标识的，主要内容包括：<code>PAT</code> 表、<code>PMT</code> 表、音频流、视频流。解析 <code>TS</code> 流要先找到 <code>PAT</code> 表，只要找到 <code>PAT</code> 就可以找到 <code>PMT</code>，然后就可以找到音视频流了。<code>PAT</code> 表和 <code>PMT</code> 表需要定期插入 <code>TS</code> 流，因为用户随时可能加入 <code>TS</code> 流，这个间隔比较小，通常每隔几个视频帧就要加入 <code>PAT</code> 和 <code>PMT</code>。<code>PAT</code> 和 <code>PMT</code> 表是必须的，还可以加入其它表如 <code>SDT</code>（业务描述表）等，不过 <code>HLS</code> 流只要有 <code>PAT</code> 和 <code>PMT</code> 就可以播放了。</p><ul><li><code>PAT</code> 表：他主要的作用就是指明了 <code>PMT</code> 表的 <code>PID</code> 值。</li><li><code>PMT</code> 表：他主要的作用就是指明了音视频流的 <code>PID</code> 值。</li><li>音频流 / 视频流：承载音视频内容。</li></ul><p><code>PID</code> 是 <code>TS</code> 流中唯一识别标志，<code>Packet Data</code> 是什么内容就是由 <code>PID</code> 决定的。下表给出了一些表的 PID 值：</p><div class="table-container"><table><thead><tr><th>表类型</th><th><code>PID</code> 值</th></tr></thead><tbody><tr><td>PAT</td><td>0x0000</td></tr><tr><td>CAT</td><td>0x0001</td></tr><tr><td>TSDT</td><td>0x0002</td></tr><tr><td>EIT,ST</td><td>0x0012</td></tr><tr><td>RST,ST</td><td>0x0013</td></tr></tbody></table></div><h3 id="adaptation-field"><a href="#adaptation-field" class="headerlink" title="adaptation field"></a>adaptation field</h3><div class="table-container"><table><thead><tr><th>名称</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td>adaptation_field_length</td><td>8bit</td><td>自适应域长度，后面的字节数（从 flag 开始）</td></tr><tr><td>flag</td><td>8bit</td><td>取 0x50 表示包含 PCR 或 0x40 表示不包含 PCR</td></tr><tr><td>PCR</td><td>40bit</td><td>Program Clock Reference，节目时钟参考，用于恢复出与编码端一致的系统时序时钟 STC（System Time Clock）。</td></tr><tr><td>stuffing_bytes</td><td>xbit</td><td>填充字节，取值 0xFF</td></tr></tbody></table></div><p>自适应区的长度要包含传输错误指示符标识的一个字节。<code>PCR</code> 是节目时钟参考，<code>PCR</code>、<code>DTS</code>、<code>PTS</code> 都是对同一个系统时钟的采样值，pcr 是递增的，因此可以将其设置为 <code>DTS</code> 值，音频数据不需要 <code>PCR</code>。如果没有字段，打包 <code>TS</code> 流时 <code>PAT</code> 和 <code>PMT</code> 表是没有 <code>adaptation field</code> 的，不够的长度直接补 <code>0xFF</code> 即可。视频流和音频流都需要加 <code>adaptation field</code>，通常加在一个帧的第一个 <code>TS</code> 包和最后一个 <code>TS</code> 包里，中间的 <code>TS</code> 包不加。</p><h3 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h3><p><code>Program Association Table</code> 节目关联表，每个 <code>TS</code> 流对应一张，用来描述该 <code>TS</code> 流中有多少个节目。</p><ul><li><code>TS</code> 流中中，<code>PAT</code> 包重复实现，大约 <code>0.5</code> 秒出现一个，保证实时解码性</li><li>表示 <code>PAT</code> 表的 <code>TS</code> 包 <code>PID</code> 值为 <code>0</code>，便于识别</li><li><code>PAT</code> 的 payload 中传送特殊 <code>PID</code> 的列表，每个 <code>PID</code> 对应一个节目（对应一张 <code>PMT</code> 表）</li><li><code>PAT</code> 表是 <code>TS</code> 流的基础，任何一个 <code>TS</code> 流解析寻找节目都是从 <code>PAT</code> 表开始查找</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT_Program</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number       :<span class="number">16</span>;  <span class="comment">// 节目号，为 0x0000 时表示这是 NIT，节目号为 0x0001 时, 表示这是 PMT</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved             :<span class="number">3</span>    <span class="comment">// 保留，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_map_PID      :<span class="number">13</span>;  <span class="comment">// 节目号对应内容的 PID 值</span></span><br><span class="line">&#125; TS_PAT_Program;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 固定 0x00 ，标志是该表是 PAT</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，表示从下一个字段开始到 CRC32(含) 之间有用的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_stream_id          : <span class="number">16</span>; <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PAT 版本号，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 固定为 1，表示这个 PAT 表有效，如果为 0 则要等待下一个 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PAT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 最后一个分段的号码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PAT_Program&gt; program;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PAT;</span><br></pre></td></tr></table></figure><h3 id="PMT"><a href="#PMT" class="headerlink" title="PMT"></a>PMT</h3><p><code>Program Map Table</code>，节目映射表，该表的 <code>PID</code> 是由 <code>PAT</code> 表 提供给出的。表征一路节目所有流信息。包含：</p><ol><li>当前节目中包含的所有 <code>Video</code> 数据的 <code>PID</code></li><li>当前节目中包含的所有 <code>Audio</code> 数据的 <code>PID</code></li><li>与当前节目关联在一起的其他数据的 <code>PID</code>（如数字广播, 数据通讯等使用的 <code>PID</code>）</li></ol><p>如果 <code>TS</code> 流中包含多个节目，那么就会有多个 <code>PMT</code> 表。只要我们处理了 <code>PMT</code> 表，那么我们就可以获取该节目中所有的流信息，如当前节目包含多少个 Video、多少个 <code>Audio</code> 和其他数据及每种数据对用的流 <code>PID</code> 分别是多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT_Stream</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> stream_type              : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，H.264 编码对应 0x1b，AAC 编码对应 0x0f，MP3 编码对应 0x03</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved1                : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> elementary_PID           : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved2                : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> ES_info_length           : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; descriptor;</span><br><span class="line">&#125; TS_PMT_Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 取值随意，一般使用 0x02, 表示 PMT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 固定为 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，表示从下一个字段开始到 CRC32(含) 之间有用的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number               : <span class="number">16</span>; <span class="comment">// 当前 PMT 表映射到的节目号，1、2、3</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PMT 版本号码，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 发送的 PMT 表 是当前有效还是下一个 PMT 有效</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PMT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 分段数</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_3                   : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> PCR_PID                      : <span class="number">13</span>; <span class="comment">// 指明 TS 包的 PID 值，该 TS 包含有 PCR 同步时钟，</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_4                   : <span class="number">4</span>;  <span class="comment">// 预留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_info_length          : <span class="number">12</span>; <span class="comment">// 前 2bit 为 00，该域指出跟随其后对节目信息的描述的字节数。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PMT_Stream&gt; PMT_Stream;</span><br><span class="line">    <span class="keyword">unsigned</span> reserved_5                   : <span class="number">3</span>;  <span class="comment">// 保留位，0x07</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_6                   : <span class="number">4</span>;  <span class="comment">// 保留位，0x0F</span></span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PMT;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;TS&lt;/code&gt; 全称是 &lt;code&gt;MPEG2-TS&lt;/code&gt;，&lt;code&gt;MPEG2-TS&lt;/code&gt; 是一种标准容器格式，传输与存储音视频、节目与系统信息协议数据，广泛应用于数字广播系统，我们日常数字机顶盒接收到的就是 &lt;code&gt;TS&lt;/code&gt;（&lt;code&gt;Transport Stream&lt;/code&gt;，传输流）流。&lt;/p&gt;</summary>
    
    
    
    
    <category term="封装格式" scheme="http://github.hezhaojiang.io/tags/%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vim 使用教程</title>
    <link href="http://github.hezhaojiang.io/post/2020/436448e4/"/>
    <id>http://github.hezhaojiang.io/post/2020/436448e4/</id>
    <published>2020-11-26T08:03:54.000Z</published>
    <updated>2020-11-26T16:36:47.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vim 是从 vi 发展出来的一个文本编辑器，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p><a id="more"></a><h2 id="Vim-模式介绍"><a href="#Vim-模式介绍" class="headerlink" title="Vim 模式介绍"></a>Vim 模式介绍</h2><p>Vim 具有 6 种基本模式和 5 种派生模式，我们这里只简单介绍下 6 种基本模式：</p><ul><li>普通模式 (Normal mode)</li></ul><p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是 Vim 启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p><ul><li>插入模式 (Insert mode)</li></ul><p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p><blockquote><p>在插入模式中，可以按 ESC 键回到普通模式。</p></blockquote><ul><li>可视模式 (Visual mode)</li></ul><blockquote><p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim 的 “文本对象” 也能和移动命令一样用在这个模式中。</p></blockquote><ul><li>选择模式 (Select mode)</li></ul><blockquote><p>这个模式和无模式编辑器的行为比较相似（Windows 标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim 会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p></blockquote><ul><li>命令行模式 (Command line mode)</li></ul><blockquote><p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（: 键），搜索（/ 和? 键）或者过滤命令（! 键）。在命令执行之后，Vim 返回到命令行模式之前的模式，通常是普通模式。</p></blockquote><ul><li>Ex 模式 (Ex mode)</li></ul><p>这和命令行模式比较相似，在使用 :visual 命令离开 Ex 模式前，可以一次执行多条命令。</p><blockquote><p>这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容</p></blockquote><h2 id="三种常用模式的切换"><a href="#三种常用模式的切换" class="headerlink" title="三种常用模式的切换"></a>三种常用模式的切换</h2><p>vim 启动进入普通模式，处于插入模式或命令行模式时只需要按 Esc 或者 Ctrl+[（这在 vim 课程环境中不管用）即可进入普通模式。普通模式中按 i（插入）或 a（附加）键都可以进入插入模式，普通模式中按 : 进入命令行模式。命令行模式中输入 wq 回车后保存并退出 vim。</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="游标移动"><a href="#游标移动" class="headerlink" title="游标移动"></a>游标移动</h3><p>普通模式，在该模式下使用方向键或者 h，j，k，l 键可以移动游标。</p><div class="table-container"><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右（小写 L）</td></tr><tr><td>j</td><td>下</td></tr><tr><td>k</td><td>上</td></tr><tr><td>w</td><td>移动到下一个单词</td></tr><tr><td>b</td><td>移动到上一个单词</td></tr></tbody></table></div><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><p>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在当前光标处进行编辑</td></tr><tr><td>I</td><td>在行首插入</td></tr><tr><td>A</td><td>在行末插入</td></tr><tr><td>a</td><td>在光标后插入编辑</td></tr><tr><td>o</td><td>在当前行后插入一个新行</td></tr><tr><td>O</td><td>在当前行前插入一个新行</td></tr><tr><td>cw</td><td>替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table></div><h3 id="保存文档"><a href="#保存文档" class="headerlink" title="保存文档"></a>保存文档</h3><p>从普通模式输入 : 进入命令行模式，输入 w 回车，保存文档。输入 :w <filename> 可以将文档另存为其他文件名或存到其它路径下。</p><h3 id="退出-vim"><a href="#退出-vim" class="headerlink" title="退出 vim"></a>退出 vim</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:q!</td><td>强制退出，不保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:wq!</td><td>强制保存并退出</td></tr><tr><td>:w <filename></td><td>另存为</td></tr><tr><td>:saveas 文件路径</td><td>另存为</td></tr><tr><td>:x</td><td>保存并退出</td></tr><tr><td>:wq</td><td>保存并退出</td></tr></tbody></table></div><p>普通模式下按下 Shift+zz 即可保存退出 vim。</p><h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除游标所在的字符</td></tr><tr><td>X</td><td>删除游标所在前一个字符</td></tr><tr><td>Delete</td><td>同 x</td></tr><tr><td>dd</td><td>删除整行</td></tr><tr><td>dw</td><td>删除一个单词（不适用中文）</td></tr><tr><td>d$ 或 D</td><td>删除至行尾</td></tr><tr><td>d^</td><td>删除至行首</td></tr><tr><td>dG</td><td>删除到文档结尾处</td></tr><tr><td>d1G</td><td>删至文档首部</td></tr></tbody></table></div><p>除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：2dd 表示一次删除 2 行。</p><h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><h3 id="游标的快速跳转"><a href="#游标的快速跳转" class="headerlink" title="游标的快速跳转"></a>游标的快速跳转</h3><h4 id="行间跳转"><a href="#行间跳转" class="headerlink" title="行间跳转"></a>行间跳转</h4><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>nG(n Shift+g) | 游标移动到第 n 行 (如果默认没有显示行号，请先进入命令模式，输入 :set nu 以显示行号)<br>gg | 游标移动到到第一行<br>G(Shift+g) | 到最后一行</p><blockquote><p>小技巧：你在完成依次跳转后，可以使用 Ctrl+o 快速回到上一次 (跳转前) 光标所在位置。</p></blockquote><h4 id="行内跳转"><a href="#行内跳转" class="headerlink" title="行内跳转"></a>行内跳转</h4><p>普通模式下使用下列命令在行内按照单词为单位进行跳转：</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>到下一个单词的开头</td></tr><tr><td>e</td><td>到当前单词的结尾</td></tr><tr><td>b</td><td>到前一个单词的开头</td></tr><tr><td>ge</td><td>到前一个单词的结尾</td></tr><tr><td>0 或 ^</td><td>到行头</td></tr><tr><td>$</td><td>到行尾</td></tr><tr><td>f &lt;字母&gt;</td><td>向后搜索 &lt; 字母 &gt; 并跳转到第一个匹配的位置 (非常实用)</td></tr><tr><td>F &lt;字母&gt;</td><td>向前搜索 &lt; 字母 &gt; 并跳转到第一个匹配的位置</td></tr><tr><td>t &lt;字母&gt;</td><td>向后搜索 &lt; 字母 &gt; 并跳转到第一个匹配位置之前的一个字母 (不常用)</td></tr><tr><td>T &lt;字母&gt;</td><td>向前搜索 &lt; 字母 &gt; 并跳转到第一个匹配位置之后的一个字母 (不常用)</td></tr></tbody></table></div><h3 id="复制粘贴和剪切"><a href="#复制粘贴和剪切" class="headerlink" title="复制粘贴和剪切"></a>复制粘贴和剪切</h3><h4 id="复制及粘贴文本"><a href="#复制及粘贴文本" class="headerlink" title="复制及粘贴文本"></a>复制及粘贴文本</h4><p>普通模式中使用 y 复制：</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>yy</td><td>复制游标所在的整行（3yy 表示复制 3 行）</td></tr><tr><td>y^</td><td>复制至行首，或 y0。不含光标所在处字符</td></tr><tr><td>y$</td><td>复制至行尾。含光标所在处字符</td></tr><tr><td>yw</td><td>复制一个单词</td></tr><tr><td>y2w</td><td>复制两个单词</td></tr><tr><td>yG</td><td>复制至文本末</td></tr><tr><td>y1G</td><td>复制至文本开头</td></tr></tbody></table></div><p>普通模式中使用 p 粘贴：</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>p</td><td>粘贴至光标后（下）</td></tr><tr><td>P</td><td>粘贴至光标前（上）</td></tr></tbody></table></div><h4 id="剪切及粘贴"><a href="#剪切及粘贴" class="headerlink" title="剪切及粘贴"></a>剪切及粘贴</h4><p>其实前面讲得 dd 删除命令就是剪切，你每次 dd 删除文档内容后，便可以使用 p 来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行。</p><p>ddp，就这么简单，即实现了快速交换光标所在行与它下面的行。</p><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="替换和撤销命令"><a href="#替换和撤销命令" class="headerlink" title="替换和撤销命令"></a>替换和撤销命令</h3><p>替换和撤销命令都是针对普通模式下的操作：</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>r+&lt;待替换字母&gt;</td><td>将游标所在字母替换为指定字母</td></tr><tr><td>R</td><td>连续替换，直到按下 Esc</td></tr><tr><td>cc</td><td>替换整行，即删除游标所在行，并进入插入模式</td></tr><tr><td>cw</td><td>替换一个单词，即删除一个单词，并进入插入模式</td></tr><tr><td>C(大写)</td><td>替换游标以后至行末</td></tr><tr><td>~</td><td>反转游标所在字母大小写</td></tr><tr><td>u{n}</td><td>撤销一次或 n 次操作</td></tr><tr><td>U(大写)</td><td>撤销当前行的所有修改</td></tr><tr><td>Ctrl+r</td><td>redo，即撤销 undo 的操作</td></tr></tbody></table></div><h3 id="快速缩进"><a href="#快速缩进" class="headerlink" title="快速缩进"></a>快速缩进</h3><h4 id="调整缩进"><a href="#调整缩进" class="headerlink" title="调整缩进"></a>调整缩进</h4><ul><li>普通模式下输入 &gt;&gt; 整行将向右缩进（使用，用于格式化代码超爽）</li><li>普通模式下输入 &lt;&lt; 整行向左回退</li><li>普通模式下输入 : 进入命令行模式下对 <code>shiftwidth</code> 值进行设置可以控制缩进和回退的字符数<ul><li>获取目前的设定值 <code>:set shiftwidth?</code></li><li>设置缩进为 10 个字符 <code>:set shiftwidth=10</code></li></ul></li></ul><h4 id="调整文本位置"><a href="#调整文本位置" class="headerlink" title="调整文本位置"></a>调整文本位置</h4><ul><li>命令行模式下输入 :ce(center) 命令使本行内容居中：</li><li>命令行模式下输入 :ri(right) 命令使本行文本靠右：</li><li>命令行模式下输入 le(left) 命令使本行内容靠左：</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h4><p>普通模式下输入 / 然后键入需要查找的字符串，按回车后就会进行查找。? 与 / 功能相同，只不过 ? 是向上而 / 是向下查找。</p><p>进入查找之后，输入 n 和 N 可以继续查找。n 是查找下一个内容，N 查找上一个内容。</p><h4 id="高级查找"><a href="#高级查找" class="headerlink" title="高级查找"></a>高级查找</h4><ul><li>普通模式下输入 * 寻找游标所在处的单词</li><li>普通模式下输入 # 同上，但 # 是向前（上）找，* 则是向后（下）找</li><li>普通模式下输入 g* 同 *，但部分符合该单词即可</li><li>普通模式下输入 g# 同 #，但部分符合该单词即可</li></ul><p>以上查找 n，N 的继续查找命令依然可以用。</p><h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="视窗操作"><a href="#视窗操作" class="headerlink" title="视窗操作"></a>视窗操作</h3><div class="table-container"><table><thead><tr><th>模式</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>命令行模式</td><td>:sp 1.txt</td><td>打开新的水平分屏视窗来编辑 1.txt</td></tr><tr><td>命令行模式</td><td>:vsp 2.txt</td><td>打开新的垂直分屏视窗来编辑 2.txt</td></tr><tr><td>普通模式</td><td>Ctrl+w s</td><td>将当前窗口分割成两个水平的窗口</td></tr><tr><td>普通模式</td><td>Ctrl+w v</td><td>将当前窗口分割成两个垂直的窗口</td></tr><tr><td>普通模式</td><td>Ctrl+w q</td><td>即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</td></tr><tr><td>普通模式</td><td>Ctrl+w o</td><td>打开一个视窗并且隐藏之前的所有视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w j</td><td>移至下面视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w k</td><td>移至上面视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w h</td><td>移至左边视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w l</td><td>移至右边视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w J</td><td>将当前视窗移至下面</td></tr><tr><td>普通模式</td><td>Ctrl+w K</td><td>将当前视窗移至上面</td></tr><tr><td>普通模式</td><td>Ctrl+w H</td><td>将当前视窗移至左边</td></tr><tr><td>普通模式</td><td>Ctrl+w L</td><td>将当前视窗移至右边</td></tr><tr><td>普通模式</td><td>Ctrl+w -</td><td>减小视窗的高度</td></tr><tr><td>普通模式</td><td>Ctrl+w +</td><td>增加视窗的高度</td></tr></tbody></table></div><h3 id="文档加密"><a href="#文档加密" class="headerlink" title="文档加密"></a>文档加密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建加密文档</span></span><br><span class="line">vim -x filename</span><br></pre></td></tr></table></figure><p>输入您的密码，确认密码，这样在下一次打开时，vim 就会要求你输入密码。</p><h3 id="在-vim-执行外部命令"><a href="#在-vim-执行外部命令" class="headerlink" title="在 vim 执行外部命令"></a>在 vim 执行外部命令</h3><p>在命令行模式中输入 ! 可以执行外部的 shell 命令，如：</p><ul><li>:!ls 用于显示当前目录的内容</li><li>:!rm filename 用于删除名为 filename 的文件</li><li>:w filename 可将当前 vim 中正在编辑的文件另存为 filename 文件</li></ul><h3 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h3><ul><li>普通模式下按 F1 打开 vim 自己预设的帮助文档</li><li>命令行模式下输入 :h shiftwidth 打开名为 shiftwidth 的帮助文件</li><li>命令行模式下输入 :ver 显示版本及参数</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.lanqiao.cn/courses/2">Vim 基础入门 - 蓝桥</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vim 是从 vi 发展出来的一个文本编辑器，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://github.hezhaojiang.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>流媒体传输 - HLS 协议</title>
    <link href="http://github.hezhaojiang.io/post/2020/f5bbcc60/"/>
    <id>http://github.hezhaojiang.io/post/2020/f5bbcc60/</id>
    <published>2020-11-22T06:41:05.000Z</published>
    <updated>2020-11-24T04:41:56.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>HLS</code> 全称是 <code>HTTP Live Streaming</code>，是一个由 <code>Apple</code> 公司提出的基于 <code>HTTP</code> 的媒体流传输协议，用于实时音视频流的传输。目前 <code>HLS</code> 协议被广泛的应用于视频点播和直播领域。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>通过将整条流切割成一个小的可以通过 <code>HTTP</code> 下载的媒体文件, 然后提供一个配套的媒体列表文件, 提供给客户端, 让客户端顺序地拉取这些媒体文件播放, 来实现看上去是在播放一条流的效果. 由于传输层协议只需要标准的 <code>HTTP</code> 协议, HLS 可以方便的透过防火墙或者代理服务器, 而且可以很方便的利用 CDN 进行分发加速, 并且客户端实现起来也很方便.</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><code>HLS</code> 的架构分为三部分：Server，CDN，Client 。即服务器、分发组件和客户端。</p><p>下面是 <code>HLS</code> 整体架构图：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201122225230.png" alt="HLS 整体架构图"></p><p>服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。</p><p>分发组件为标准的 Web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。</p><p>客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。</p><h2 id="HLS-协议分析"><a href="#HLS-协议分析" class="headerlink" title="HLS 协议分析"></a>HLS 协议分析</h2><h3 id="HLS-Playlist"><a href="#HLS-Playlist" class="headerlink" title="HLS Playlist"></a>HLS Playlist</h3><p>其实, <code>HLS</code> 协议的主要内容是关于 <code>M3U8</code> 这个文本协议的, 其实生成与解析都非常简单. 为了更加直接地说明这一点, 我下面举两个简单的例子:</p><p>简单的 <code>Media Playlist</code>：</p><pre><code>#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:8#EXT-X-MEDIA-SEQUENCE:2680#EXTINF:7.975,https://priv.example.com/fileSequence2680.ts#EXTINF:7.941,https://priv.example.com/fileSequence2681.ts#EXTINF:7.975,https://priv.example.com/fileSequence2682.ts</code></pre><p>包含多种比特率的 <code>Master Playlist</code>：</p><pre><code>#EXTM3U#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1280000http://example.com/low.m3u8#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2560000http://example.com/mid.m3u8#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=7680000http://example.com/hi.m3u8#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=65000,CODECS=&quot;mp4a.40.5&quot;http://example.com/audio-only.m3u8</code></pre><ul><li><code>HLS</code> 通过 <code>URI(RFC3986)</code> 指向的一个 <code>Playlist</code> 来表示一个媒体流</li><li>一个 <code>Playlist</code> 可以是一个 <code>Media Playlist</code> 或者 <code>Master Playlist</code>, 使用 <code>UTF-8</code> 编码的文本文件, 包含一些 <code>URI</code> 跟描述性的 <code>tags</code></li><li>一个 <code>Media Playlist</code> 包含一个 <code>Media Segments</code> 列表,当顺序播放时, 能播放整个完整的流</li><li>要想播放这个 <code>Playlist</code>, 客户端需要首先下载他, 然后播放里面的每一个 <code>Media Segment</code></li><li><p>更加复杂的情况是, <code>Playlist</code> 是一个 <code>Master Playlist</code>, 包含一个 <code>Variant Stream</code> 集合, 通常每个 <code>Variant Stream</code> 里面是同一个流的多个不同版本(如: 分辨率, 码率不同)</p></li><li><p>一个 <code>Playlist</code> 文件必须通过 <code>URI(.m3u8 或 m3u)</code> 或者 <code>HTTP Content-Type</code> 来识别 (<code>application/vnd.apple.mpegurl</code> 或 <code>audio/mpegurl</code>)</p></li><li>换行符可以用 <code>\n</code> 或者 <code>\r\n</code></li><li>以 <code>#</code> 开头的是 <code>tag</code> 或者注释, 以 <code>#EXT</code> 开头的是 <code>tag</code>, 其余的为注释, 在解析时应该忽略</li><li><code>Playlist</code> 里面的 <code>URI</code> 可以用绝对地址或者相对地址, 如果使用相对地址, 那么是相对于 <code>Playlist</code> 文件的地址</li></ul><h3 id="HLS-Media-Segments"><a href="#HLS-Media-Segments" class="headerlink" title="HLS Media Segments"></a>HLS Media Segments</h3><ul><li>每一个 <code>Media Segment</code> 通过一个 <code>URI</code> 指定, 可能包含一个 <code>byte range</code></li><li>每一个 <code>Media Segment</code> 的 <code>duration</code> 通过 <code>EXTINF</code> <code>tag</code> 指定</li><li>每一个 <code>Media Segment</code> 有一个唯一的整数 <code>Media Segment Number</code></li><li>有些媒体格式需要一个 <code>format-specific sequence</code> 来初始化一个 <code>parser</code>, 在 <code>Media Segment</code> 被 <code>parse</code> 之前. 这个字段叫做 <code>Media Initialization Section</code>, 通过 <code>EXT-X-MAP</code> <code>tag</code> 来指定. 支持的 <code>Media Segment</code> 格式</li></ul><h3 id="HLS-TAGS"><a href="#HLS-TAGS" class="headerlink" title="HLS TAGS"></a>HLS TAGS</h3><ul><li><code>Basic Tags</code> : 用在 <code>Media Playlist</code> 和 <code>Master Playlist</code> 里面<ul><li><code>EXTM3U</code>: 必须在文件的第一行, 标识是一个 <code>Extended M3U Playlist</code> 文件</li><li><code>EXT-X-VERSION</code>: 表示 <code>Playlist</code> 兼容的版本</li></ul></li><li><code>Media Segment Tags</code> : 只能出现在 <code>Media Playlist</code> 里面<ul><li><code>EXTINF</code>: 用于指定 <code>Media Segment</code> 的 <code>duration</code></li><li><code>EXT-X-BYTERANGE</code>: 用于指定 <code>URI</code> 的 <code>sub-range</code></li><li><code>EXT-X-DISCONTINUITY</code>: 表示不连续</li><li><code>EXT-X-KEY</code>: 表示 <code>Media Segment</code> 已加密, 该值用于解密</li><li><code>EXT-X-MAP</code>: 用于指定 <code>Media Initialization Section</code></li><li><code>EXT-X-PROGRAM-DATE-TIME</code>: 和 <code>Media Segment</code> 的第一个 <code>sample</code> 一起来确定时间戳</li><li><code>EXT-X-DATERANGE</code>: 将一个时间范围和一组属性键值对结合到一起</li></ul></li><li><code>Media Playlist tags</code> : 只能出现在 <code>Media Playlist</code> 里面<ul><li><code>EXT-X-TARGETDURATION</code>: 用于指定最大的 <code>Media Segment duration</code></li><li><code>EXT-X-MEDIA-SEQUENCE</code>: 用于指定第一个 <code>Media Segment</code> 的 <code>Media Sequence Number</code></li><li><code>EXT-X-DISCONTINUITY-SEQUENCE</code>: 用于不同 <code>Variant Stream</code> 之间同步</li><li><code>EXT-X-ENDLIST</code>: 表示结束</li><li><code>EXT-X-PLAYLIST-TYPE</code>: 可选, 指定整个 <code>Playlist</code> 的类型</li><li><code>EXT-X-I-FRAMES-ONLY</code>: 表示每个 <code>Media Segment</code> 描述一个单一的 <code>I-frame</code></li></ul></li><li><code>Master Playlist tags</code> : 只能出现在 <code>Master Playlist</code> 中<ul><li><code>EXT-X-MEDIA</code>: 用于关联同一个内容的多个 <code>Media Playlist</code> 的多种 <code>renditions</code></li><li><code>EXT-X-STREAM-INF</code>: 用于指定一个 <code>Variant Stream</code></li><li><code>EXT-X-I-FRAME-STREAM-INF</code>: 用于指定一个 <code>Media Playlist</code> 包含媒体的 <code>I-frames</code></li><li><code>EXT-X-SESSION-DATA</code>: 存放一些 <code>session</code> 数据</li><li><code>EXT-X-SESSION-KEY</code>: 用于解密</li></ul></li><li><code>Media or Master Playlist Tags</code> : 可以出现在 <code>Media Playlist</code> 或者 <code>Master Playlist</code> 中，但是如果同时出现在同一个 <code>Master Playlist</code> 和 <code>Media Playlist</code> 中时，必须为相同值<ul><li><code>EXT-X-INDEPENDENT-SEGMENTS</code>: 表示每个 <code>Media Segment</code> 可以独立解码</li><li><code>EXT-X-START</code>: 标识一个优选的点来播放这个 <code>Playlist</code></li></ul></li></ul><h2 id="HLS-播放"><a href="#HLS-播放" class="headerlink" title="HLS 播放"></a>HLS 播放</h2><h3 id="播放未加密-HLS"><a href="#播放未加密-HLS" class="headerlink" title="播放未加密 HLS"></a>播放未加密 HLS</h3><p>我们通过 <code>VLC</code> 播放器播放苹果官方提供的一个例子：<code>http://devimages.apple.com/iphone/samples/bipbop/gear1/prog_index.m3u8</code>，并使用 <code>Wirshark</code> 对其中交互进行抓包。</p><pre><code>GET /iphone/samples/bipbop/gear1/prog_index.m3u8 HTTP/1.1Host: devimages.apple.comAccept: */*Accept-Language: zh_CNUser-Agent: VLC/3.0.8 LibVLC/3.0.8Range: bytes=0-    HTTP/1.1 206 Partial Content    Accept-Ranges: bytes    Content-Type: audio/x-mpegurl    ETag: &quot;50117c8233644c19b5ab49551b72507f:1239907352&quot;    Last-Modified: Thu, 16 Apr 2009 18:42:32 GMT    Server: AkamaiNetStorage    Date: Sun, 22 Nov 2020 15:01:49 GMT    Content-Range: bytes 0-7018/7019    Content-Length: 7019    X-Cache: TCP_MEM_HIT from a184-26-91-45.deploy.akamaitechnologies.com (AkamaiGHost/10.2.0.2-31441410) (-)    Connection: keep-alive    #EXTM3U    #EXT-X-TARGETDURATION:10    #EXT-X-MEDIA-SEQUENCE:0    #EXTINF:10, no desc    fileSequence0.ts    #EXTINF:10, no desc    fileSequence1.ts    #EXTINF:10, no desc    fileSequence2.ts    #EXTINF:10, no desc    ......    #EXTINF:1, no desc    fileSequence180.ts    #EXT-X-ENDLIST</code></pre><p>我们可以看到返回的 <code>M3U8</code> 里面他有一个一个 <code>ts</code> 视频片段，这个一个一个视频片段就是我们需要的播放的视频片段。</p><p><code>#EXTINF</code> 表示每个 <code>ts</code> 切片视频文件的时长。<br><code>#EXT-X-TARGETDURATION</code> 指定当前视频流中的切片文件的最大时长，也就是说这些 <code>ts</code> 切片的时长不能大于 <code>#EXT-X-TARGETDURATION</code> 的值。<br><code>#EXT-X-MEDIA-SEQUENCE</code> 第一个 <code>ts</code> 分片的序列号<br><code>#EXT-X-ENDLIST</code> 这个表示视频结束，有这个标志同时也说明当前的流是一个非直播流。<br><code>#EXT-X-PLAYLIST-TYPE:VOD</code> 的意思是当前的视频流并不是一个直播流，而是点播流，换句话说就是该视频的全部的 <code>ts</code> 文件已经被生成好了<br><code>#EXT-X-ALLOW-CACHE</code> 是否允许 <code>cache</code></p><h3 id="播放加密-HLS"><a href="#播放加密-HLS" class="headerlink" title="播放加密 HLS"></a>播放加密 HLS</h3><h2 id="HLS-协议总结"><a href="#HLS-协议总结" class="headerlink" title="HLS 协议总结"></a>HLS 协议总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>客户端支持简单, 只需要支持 <code>HTTP</code> 请求即可, <code>HTTP</code> 协议无状态, 只需要按顺序下载媒体片段即可。</li><li>使用 <code>HTTP</code> 协议网络兼容性好, <code>HTTP</code> 数据包也可以方便地通过防火墙或者代理服务器, <code>CDN</code> 支持良好。</li><li><code>Apple</code> 的全系列产品支持，不需要安装任何插件就可以原生支持播放 <code>HLS</code>, 目前 <code>Android</code> 也加入了对 <code>HLS</code> 的支持。</li><li>自带多码率自适应机制。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相比 <code>RTMP</code> 这类长连接协议, 延时较高, 难以用到互动直播场景。</li><li>对于点播服务来说, 由于 <code>TS</code> 切片通常较小, 海量碎片在文件分发, 一致性缓存, 存储等方面都有较大挑战。</li></ul><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li>由于客户端每次请求 <code>TS</code> 或 <code>M3U8</code> 有可能一个新的连接请求, 无法有效的标识客户端, 一旦出现问题, 基本无法有效的定位问题。</li><li>一般工业级的服务器都会对传统的 <code>HLS</code> 做一些改进，常见优化是对每个 <code>M3U8</code> 文件增加 <code>Session</code> 来标识一条 <code>HLS</code> 连接。</li><li>不管通过哪种方式, 最终我们都能通过一个唯一的 <code>id</code> 来标识一条流, 这样在排查问题时就可以根据这个 <code>id</code> 来定位播放过程中的问题。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.cnblogs.com/renhui/p/8081869.html">流媒体协议（一）：HLS 协议 - 灰色飘零 - 博客园</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;HLS&lt;/code&gt; 全称是 &lt;code&gt;HTTP Live Streaming&lt;/code&gt;，是一个由 &lt;code&gt;Apple&lt;/code&gt; 公司提出的基于 &lt;code&gt;HTTP&lt;/code&gt; 的媒体流传输协议，用于实时音视频流的传输。目前 &lt;code&gt;HLS&lt;/code&gt; 协议被广泛的应用于视频点播和直播领域。&lt;/p&gt;</summary>
    
    
    
    
    <category term="流媒体" scheme="http://github.hezhaojiang.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    <category term="HLS" scheme="http://github.hezhaojiang.io/tags/HLS/"/>
    
  </entry>
  
  <entry>
    <title>内存管理 - gperftools 检查内存泄漏</title>
    <link href="http://github.hezhaojiang.io/post/2020/f517d3b0/"/>
    <id>http://github.hezhaojiang.io/post/2020/f517d3b0/</id>
    <published>2020-11-19T07:54:19.000Z</published>
    <updated>2020-11-22T02:50:27.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内存泄漏一般是由于程序在堆上分配了内存而没有释放，随着程序的运行占用的内存越来越大，一方面会影响程序的稳定性，可能让运行速度越来越慢，或者造成 <code>OOM</code>，甚至会影响程序所运行的机器的稳定性，造成宕机。</p><p>而分析内存问题的常用工具有 <code>valgrind</code> 和 <code>gperftools</code> 等，当然也可以自行开发钩子函数，本文主要介绍 <code>gperftools</code> 来进行内存泄漏的分析。</p><a id="more"></a><h2 id="安装-gperftools"><a href="#安装-gperftools" class="headerlink" title="安装 gperftools"></a>安装 gperftools</h2><p>首先是一些依赖环境的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## libunwind 64 位系统必选</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libunwind/libunwind.git</span><br><span class="line"><span class="built_in">cd</span> libunwind</span><br><span class="line">sh ./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成 PDF 可视化必选</span></span><br><span class="line">sudo apt-get install graphviz graphviz-doc</span><br><span class="line">sudo yum install graphviz graphviz-doc</span><br><span class="line">sudo yum install ghostscript</span><br></pre></td></tr></table></figure><p>然后就可以安装 <code>gperftools</code> 工具了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gperftools/gperftools.git</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完成后，如果程序运行环境与编译环境不是同一台主机，需要拷贝出一些成果物放置到合适的位置，主要成果物包括：</p><ol><li><code>lib</code> 文件，需要放在运行环境中<ul><li><code>libunwind.so.8</code></li><li><code>libtcmalloc.so.4</code></li></ul></li><li>头文件，需要放在代码中方便集中管理<ul><li><code>heap-checker.h</code></li><li><code>heap-profiler.h</code></li></ul></li><li>工具文件，可以放在编译环境中使用，也可以拷贝到其他主机上使用<ul><li><code>pprof</code></li></ul></li></ol><h2 id="使用-gperftools"><a href="#使用-gperftools" class="headerlink" title="使用 gperftools"></a>使用 gperftools</h2><p><code>gperftools</code> 提供了 <code>4</code> 个工具：</p><ul><li><code>thread-caching malloc</code> : 简称 <code>tcmalloc</code>，可以用来替代 <code>glibc</code> 中原有的 <code>malloc/free</code>、<code>new/delete</code> 等函数</li><li><code>heap-checking using tcmalloc</code> : 用来检查程序中的内存泄漏位置，适用于 <code>C++</code></li><li><code>heap-profiling using tcmalloc</code> : 用来统计程序中的内存申请、释放情况，可用于检查内存使用情况和泄漏情况，适用于 <code>C/C++</code>，可应用于所有可执行文件</li><li><code>CPU profiler</code> : 用来统计程序中每个部分占用 CPU 性能情况，用于程序 CPU 性能的观察和优化</li></ul><p>以上 <code>4</code> 个工具中，用于分析内存泄漏的有两个工具：<code>heap-checking using tcmalloc</code> 和 <code>heap-profiling using tcmalloc</code></p><h3 id="使用-heap-checking"><a href="#使用-heap-checking" class="headerlink" title="使用 heap-checking"></a>使用 heap-checking</h3><p>使用 <code>heap-checking</code> 有两种方式，一种是设置环境变量的方法，一种是修改代码的方法</p><h4 id="设置环境变量来使用-heap-checking"><a href="#设置环境变量来使用-heap-checking" class="headerlink" title="设置环境变量来使用 heap-checking"></a>设置环境变量来使用 heap-checking</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env LD_PRELOAD=<span class="string">&quot;/usr/lib/libtcmalloc.so&quot;</span></span><br><span class="line"><span class="comment">## 假设我们要检查的程序是 /usr/local/bin/my_binary_compiled_with_tcmalloc</span></span><br><span class="line">env HEAPCHECK=normal /usr/<span class="built_in">local</span>/bin/my_binary_compiled_with_tcmalloc</span><br></pre></td></tr></table></figure><ol><li>minimal</li><li>normal</li><li>strict</li><li>draconian</li></ol><p>“minimal”：堆检查在初始化中尽可能晚地开始，这意味着您可以在初始化例程中泄漏一些内存，并且不会触发泄漏消息。如果您经常在一次全局初始化中故意泄漏数据，则 “minimal” 模式对您非常有用。否则，应使用更严格的模式。</p><p>“normal” 堆检查跟踪活动对象，并报告程序退出时无法通过活动对象访问的任何数据的泄漏，是谷歌最常用的模式，适用于日常堆检查使用。</p><p>“strict” 堆检查很像 “normal”，但有一些额外的检查，即内存不会丢失在全局析构函数中。特别是，如果您有一个全局变量，该变量在程序执行期间分配内存，然后在全局析构函数中 “forgets” 内存（例如，将指针设置为 NULL），这将在 “strict” 模式下提示泄漏消息，而在 “normal” 模式下并不会进行提示。</p><p>“draconian” 堆检查适合那些喜欢非常精确地了解其内存管理，并且希望堆检查器帮助他们实施它的人。在 “draconian” 模式下，堆检查器不会执行 “live object” 检查，因此除非在程序退出之前释放了所有分配的内存，它都会报告泄漏。</p><h4 id="修改代码来使用-heap-checking"><a href="#修改代码来使用-heap-checking" class="headerlink" title="修改代码来使用 heap-checking"></a>修改代码来使用 heap-checking</h4><blockquote><p>可参考：<a href="https://gperftools.github.io/gperftools/heap_checker.html">https://gperftools.github.io/gperftools/heap_checker.html</a></p></blockquote><h3 id="分析-heap-checking-输出"><a href="#分析-heap-checking-输出" class="headerlink" title="分析 heap-checking 输出"></a>分析 heap-checking 输出</h3><h3 id="使用-heap-profiling"><a href="#使用-heap-profiling" class="headerlink" title="使用 heap-profiling"></a>使用 heap-profiling</h3><p>与 <code>heap-checking</code> 一样，<code>heap-profiling</code> 也有同样的两种方法来使用</p><h4 id="设置环境变量来使用-heap-profiling"><a href="#设置环境变量来使用-heap-profiling" class="headerlink" title="设置环境变量来使用 heap-profiling"></a>设置环境变量来使用 heap-profiling</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env LD_PRELOAD=<span class="string">&quot;/usr/lib/libtcmalloc.so&quot;</span></span><br><span class="line"><span class="comment">## 假设我们要检查的程序是 /usr/local/bin/my_binary_compiled_with_tcmalloc</span></span><br><span class="line">env HEAPPROFILE=/tmp/mybin.hprof /usr/<span class="built_in">local</span>/bin/my_binary_compiled_with_tcmalloc</span><br></pre></td></tr></table></figure><p>除了以上环境变量，还有一些环境变量可以设置：</p><div class="table-container"><table><thead><tr><th>环境变量</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>HEAP_PROFILE_ALLOCATION_INTERVAL</td><td>1073741824 (1GB)</td><td>每次程序分配指定字节数时，转储堆分析信息。</td></tr><tr><td>HEAP_PROFILE_INUSE_INTERVAL</td><td>104857600(100M)</td><td>每当高水位内存使用标记增加指定字节数时，转储堆分析信息。</td></tr><tr><td>HEAP_PROFILE_TIME_INTERVAL</td><td>0</td><td>每次经过指定的秒数时转储堆分析信息。</td></tr><tr><td>HEAPPROFILESIGNAL</td><td>已禁用</td><td>每当将指定的信号发送到进程时，转储堆分析信息。</td></tr></tbody></table></div><h4 id="修改代码来使用-heap-profiling"><a href="#修改代码来使用-heap-profiling" class="headerlink" title="修改代码来使用 heap-profiling"></a>修改代码来使用 heap-profiling</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/heap-profiler.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 启动堆分析器 */</span></span><br><span class="line">HeapProfilerStart()</span><br><span class="line"><span class="comment">/* 停止堆分析器 */</span></span><br><span class="line">HeapProfilerStop()</span><br><span class="line"><span class="comment">/* 转储堆分析器分析结果 */</span></span><br><span class="line">HeapProfilerDump()</span><br><span class="line">GetHeapProfile()</span><br><span class="line"><span class="comment">/* 检查堆分析器是否启动 */</span></span><br><span class="line">IsHeapProfilerRunning()</span><br></pre></td></tr></table></figure><p>示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/heap-profiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAIT_FOREVER(t) do &#123; while(1) &#123; sleep(t); &#125; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">leek_malloc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ptr = <span class="built_in">malloc</span>(<span class="number">1024</span>); <span class="comment">/* 1024 Byte */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc 1024 byte success.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (time(<span class="literal">NULL</span>) % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">free</span>(ptr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">leek_check</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        HeapProfilerDump(<span class="string">&quot;check&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidmalloc;</span><br><span class="line">    <span class="keyword">pthread_t</span> tiddump;</span><br><span class="line">    HeapProfilerStart(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tidmalloc, <span class="literal">NULL</span>, leek_malloc, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tidmalloc, <span class="literal">NULL</span>, leek_check, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WAIT_FOREVER(<span class="number">10</span>);</span><br><span class="line">    HeapProfilerStop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-heap-profiling-输出"><a href="#分析-heap-profiling-输出" class="headerlink" title="分析 heap-profiling 输出"></a>分析 heap-profiling 输出</h4><p>如果在程序中打开堆分析，程序将定期将配置文件写入文件系统。配置文件序列将命名为：</p><pre><code>    &lt;prefix&gt;.0000.heap    &lt;prefix&gt;.0001.heap    &lt;prefix&gt;.0002.heap    ...</code></pre><p><code>&lt;prefix&gt;</code> 是运行代码时提供的文件名前缀（或者通过环境变量 <code>HEAPPROFILE</code> 提供）的位置。请注意，如果提供的前缀不是以 ‘/‘ 开头，则配置文件将写入程序的工作目录。</p><p>通过将配置文件输出传递到工具 <code>pprof</code> 可以查看配置文件输出。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://gperftools.github.io/gperftools/heap_checker.html">Gperftools Heap Leak Checker</a></li><li>[2] <a href="https://gperftools.github.io/gperftools/heapprofile.html">Gperftools Heap Profiler</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存泄漏一般是由于程序在堆上分配了内存而没有释放，随着程序的运行占用的内存越来越大，一方面会影响程序的稳定性，可能让运行速度越来越慢，或者造成 &lt;code&gt;OOM&lt;/code&gt;，甚至会影响程序所运行的机器的稳定性，造成宕机。&lt;/p&gt;
&lt;p&gt;而分析内存问题的常用工具有 &lt;code&gt;valgrind&lt;/code&gt; 和 &lt;code&gt;gperftools&lt;/code&gt; 等，当然也可以自行开发钩子函数，本文主要介绍 &lt;code&gt;gperftools&lt;/code&gt; 来进行内存泄漏的分析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://github.hezhaojiang.io/tags/Linux/"/>
    
    <category term="内存管理" scheme="http://github.hezhaojiang.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - PS 封装解析示例</title>
    <link href="http://github.hezhaojiang.io/post/2020/1472cc3/"/>
    <id>http://github.hezhaojiang.io/post/2020/1472cc3/</id>
    <published>2020-11-17T05:03:07.000Z</published>
    <updated>2021-01-08T17:07:30.754Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章 <a href="/post/2020/9064839e/" title="音视频封装 - PS 封装格式">音视频封装 - PS 封装格式</a> 中分析了 <code>PS</code> 流的结构，但文章中中涉及到的元素过多，难以理解，故通过一段真实的码流的分析来加强对 <code>PS</code> 流结构的理解。</p><blockquote><p>注 1：本文中的 <code>PS</code> 码流 A 截取自一段经 <code>ffmpeg</code> 转码的网络视频，码流 B 截取自海康摄像机的 <code>GB28181</code> 码流。<br>注 2：本文中的数字一般为十进制表示，如果是其他进制数据，会在数字后携带 <code>(2)</code> 代表二进制，在数字前添加 <code>0x</code> 代表十六进制<br>注 3：截图中的码流信息均使用十六进制</p></blockquote><a id="more"></a><h2 id="PS-Stream-A"><a href="#PS-Stream-A" class="headerlink" title="PS Stream A"></a>PS Stream A</h2><h3 id="PS-Header"><a href="#PS-Header" class="headerlink" title="PS Header"></a>PS Header</h3><p><code>PS</code> 码流由多个 <code>PS Pack</code> 组成，而 <code>PS Pack</code> 的起始符为 <code>0x00 00 01 ba</code>。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117214228.png" alt="PS Header"></p><p>接下来跳过 <code>9</code> 个字节，看第 <code>10</code> 个字节，其最后三位数字代表拓展内容的长度，此包中该位置后三位为 <code>0</code>，代表无拓展内容。</p><blockquote><p>如果该位置后三位非 0，参见 <a href="#PS-Header-Extern">PS Header Extern</a></p></blockquote><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117215716.png" alt="拓展内容"></p><p>继续读取数据，如果遇到了 <code>0x00 00 01 bb</code>，就代表到了码流中 <code>PS System Header</code> 部分。</p><blockquote><p>码流中有可能会读取到 <code>0x00 00 01 bc</code>，参见 <a href="#Program-Stream-Map">Program Stream Map</a></p></blockquote><h3 id="PS-System-Header"><a href="#PS-System-Header" class="headerlink" title="PS System Header"></a>PS System Header</h3><p><code>System Header</code> 当且仅当数据包为第一个数据包时才存在，以 <code>0x00 00 01 bb</code> 的开始。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220401.png" alt="PS System Header"></p><p>之后紧跟着的 <code>0x00 0c</code> 两个字节表示 <code>System Header</code> 的长度，换算为十进制，即为 <code>12</code> 个字节。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220711.png" alt="PS System Header Length"></p><p>之后跳过 <code>6</code> 字节数据，之后如果 <code>nextbit == 1</code>，则该位置为一个 <code>stream_id</code>，<code>stream_id</code> 为 <code>0xe0</code>，指示该 <code>PS</code> 码流中包含视频流。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117221430.png" alt="Stream id e0"></p><p>该部分内容 <code>3</code> 字节一个循环，下一个循环中 <code>nextbit == 1</code>，则该位置也为一个 <code>stream_id</code>，<code>stream_id</code> 为 <code>0xc0</code>，指示该 <code>PS</code> 码流中包含音频流。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117221746.png" alt="Stream id c0"></p><p>至此 <code>nextbit == 0</code>，说明该循环结束，读取的长度也与上述 <code>PS System Header</code> 的长度值 <code>12</code> 一致。</p><p>继续读取数据，遇到了 <code>0x00 00 01</code>，<code>PS</code> 流中这三个字符可视为不同数据的分隔符，而其下一位数据指示了后续数据的类型。</p><h3 id="PES-Pack"><a href="#PES-Pack" class="headerlink" title="PES Pack"></a>PES Pack</h3><p>如果读取 PS 流中遇到了 <code>0x00 00 01 e0</code> 或 <code>0x00 00 01 c0</code>，就代表读取到了 <code>PES Pack</code>。</p><p><code>PES Pack</code> 分为两个部分，一部分是 <code>Header</code>，一部分是 <code>Payload</code>，<code>Header</code> 用于存储一些描述信息，而 <code>Payload</code> 部分为其存储的原始数据，<code>PES</code> 可能有多个。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117234659.png" alt="PES Pack"></p><p><code>0x00 00 01 e0</code> 代表遇到的是一个 <code>PES Video Pack</code>，如果是 <code>0x00 00 01 c0</code>，代表遇到的是一个 <code>PES Audio Pack</code>。</p><p>再之后的 <code>0x07 dc</code> 表示长度，即其后的 <code>2012</code> 字节为数据内容长度。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117235040.png" alt="PES Pack Length"></p><p>之后参考 <code>PES Pack</code> 结构来解析数据，可参见 <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a>。</p><p>跳过 1 字节字段后，下一个字段为 <code>PTS_DTS_flags</code> 字段，占位 2bits。</p><blockquote><p><code>PTS_DTS_flags</code>：<code>PTS</code> 和 <code>DTS</code> 标志位，占位 2bit；<code>10(2)</code> 表示首部有 <code>PTS</code> 字段，<code>11(2)</code> 表示有 <code>PTS</code> 和 <code>DTS</code> 字段，<code>00(2)</code> 表示都没有，<code>01(2)</code> 被禁止。<br><code>PTS</code> - 显示时间戳（Presentation Time Stamp），用来表示显示单元出现在系统目标解码器的时间。<br><code>DTS</code> - 解码时间戳（Decoding Time Stamp），用来表示将存取单元全部字节从解码缓存取走的时间。<br>如果 <code>PTS_DTS_flags</code> 不是 <code>00(2)</code>，就代表存在 <code>PTS</code> 或 <code>DTS</code> 参见 <a href="#PTS_DTS_flags">PTS_DTS_flags</a></p></blockquote><p>故该 <code>PES Pack</code> 中无 <code>PTS</code> 和 <code>DTS</code> 字段</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117235708.png" alt="PTS_DTS_flags"></p><p>后面 6bits 也是 <code>PES</code> 包中可选字段的 <code>Flag</code> 参数，由上图可知，该 <code>PES Pack</code> 无这些可选字段。</p><p>继续读取数据，下一个字段就为 <code>PES_header_data_length</code>，代表 <code>PES Header</code> 中可选字段和填充字段的长度，占位 <code>8bit</code>，该 <code>PES Pack</code> 中该值为 <code>03</code>，即该 <code>PES Pack</code> 中，该字段之后 <code>3</code> 个字节为 <code>PES Header</code> 字段，剩余数据均为数据 <code>Payload</code>。</p><h2 id="PS-Stream-B"><a href="#PS-Stream-B" class="headerlink" title="PS Stream B"></a>PS Stream B</h2><h3 id="PS-Header-Extern"><a href="#PS-Header-Extern" class="headerlink" title="PS Header Extern"></a>PS Header Extern</h3><p>如果 <code>PS Pack</code> 第 <code>10</code> 字节后三位不是 <code>000(2)</code>，则代表其后有相应长度的拓展内容，比如下图码流中就有 <code>6</code> 字节拓展内容：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220016.png" alt="拓展内容 2"></p><h3 id="Program-Stream-Map"><a href="#Program-Stream-Map" class="headerlink" title="Program Stream Map"></a>Program Stream Map</h3><p>如果码流中遇到了 <code>0x00 00 01 bc</code>，则之后的数据为 <code>Program Stream Map</code> 数据。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223419.png" alt="Program Stream Map"></p><p><code>Program Stream Map</code>，即 <code>PSM</code>，其格式如下图所示：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223519.png" alt="Program Stream Map 格式"></p><p>可以看出，<code>0x00 00 01 bc</code> 后两位代表该部分数据长度，该 <code>PSM</code> 数据长度为 <code>0x62</code>，转化为十进制，即 <code>98</code> 字节。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223909.png" alt="Program Stream Map length"></p><p>结合上边的 <code>PSM</code> 结构，自 <code>0x00 62</code> 后，跳过两个字节的固定内容，就到了两个字节的 <code>program_stream_info_length</code>，其值为 <code>0x00 2c</code>，说明其后跟着的 <code>descriptor</code> 共占 <code>44</code> 字节。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117230813.png" alt="descriptor"></p><p>跳过该长度信息和 <code>44</code> 字节后，接下来的值 <code>0x00 2c</code> 为 <code>element_stream_map_length</code>（基本流映射长度），也就是 <code>44</code> 字节，它表示接下来的 <code>44</code> 字节都是用来描述原始流信息的。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117231212.png" alt="c"></p><p>接下来进入了原始流描述的第一次循环，第一个字节 <code>stream_type</code> 值为 <code>0x24</code>，根据《GB/T 28181-2016 修改补充文件》可知其为 <code>H.265</code> 码流。</p><pre><code>    a)  MPEG-4  视频流：    0x10    b)  H.264   视频流：    0x1B    c)  SVAC    视频流：    0x80    d)  H.265   视频流：    0x24    e)  G.711A  音频流：    0x90    f)  G.711U  音频流：    0x91    g)  G.722.1 音频流：    0x92    h)  G.723.1 音频流：    0x93    i)  G.729   音频流：    0x99    j)  SVAC    音频流：    0x9B</code></pre><p>之后的 <code>0xe0</code> 表示其为视频流。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232429.png" alt="stream_type"></p><p>之后的 <code>0x00 10</code> 代表该视频流描述 <code>element_stream_info_length</code> 占 <code>16</code> 字节。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232540.png" alt="element_stream_info_length"></p><p>同理，接着循环下去，接下来的字段 <code>0x91</code> 和 <code>0xc0</code>，代表着其为 <code>G.711U</code> 编码的音频流，并携带有 <code>0x0c</code> 即 <code>12</code> 字节的描述信息。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232848.png" alt="stream_type Audio"></p><p>继续循环，接下来的字段 <code>0xbd bd</code>，是海康的私有数据，携带有 <code>0</code> 字节的描述信息。</p><p>继续循环，接下来的字段 <code>0xbf bf</code>，也是海康的私有数据，携带有 <code>0</code> 字节的描述信息。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117233803.png" alt="私有数据 PSM"></p><p>以上四次循环后，他们占用的字节数已经等于 <code>44</code>，跟 <code>element_stream_map_length</code> 值相等。</p><p>接下来的内容就是 <code>CRC_32</code>，<code>4bits</code>，从以下码流中可以看出，海康 IPC 中没有对这些字节进行计算。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118211141.png" alt="CRC_32"></p><h3 id="PTS-DTS-flags"><a href="#PTS-DTS-flags" class="headerlink" title="PTS_DTS_flags"></a>PTS_DTS_flags</h3><p>在很多码流中，都会存在 <code>PTS</code> 或 <code>DTS</code> 字段，此时 <code>PTS_DTS_flags</code> 字段就会置位，比如以下码流中，<code>PTS_DTS_flags</code> 为 <code>00(2)</code></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118212717.png" alt="PTS_DTS_flags"></p><p>对比 <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a> 中 <code>PES</code> 码流结构可知，之后由 <code>5</code> 字节的 <code>PTS</code> 数据</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118213841.png" alt="PES Struct"></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118214049.png" alt="PTS Data"></p><h3 id="ES-Stream"><a href="#ES-Stream" class="headerlink" title="ES Stream"></a>ES Stream</h3><p>经过以上步骤分析出 <code>PS</code> 的各层封装后，就能将封装中的 <code>ES</code> 码流提取出来：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118212109.png" alt="ES"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] 文中 <code>PS</code> 码流 <code>A</code> 视频源文件：<a href="/slave/PS/TestVideoA.7z" title="密码：github.com">点击下载</a></li><li>[2] 文中 <code>PS</code> 码流 <code>B</code> 视频源文件：<a href="/slave/PS/TestVideoB.7z" title="密码：github.com">点击下载</a></li><li>[3] <a href="/post/2020/9064839e/" title="音视频封装 - PS 封装格式">音视频封装 - PS 封装格式</a></li><li>[4] <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章 &lt;a href=&quot;/post/2020/9064839e/&quot; title=&quot;音视频封装 - PS 封装格式&quot;&gt;音视频封装 - PS 封装格式&lt;/a&gt; 中分析了 &lt;code&gt;PS&lt;/code&gt; 流的结构，但文章中中涉及到的元素过多，难以理解，故通过一段真实的码流的分析来加强对 &lt;code&gt;PS&lt;/code&gt; 流结构的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注 1：本文中的 &lt;code&gt;PS&lt;/code&gt; 码流 A 截取自一段经 &lt;code&gt;ffmpeg&lt;/code&gt; 转码的网络视频，码流 B 截取自海康摄像机的 &lt;code&gt;GB28181&lt;/code&gt; 码流。&lt;br&gt;注 2：本文中的数字一般为十进制表示，如果是其他进制数据，会在数字后携带 &lt;code&gt;(2)&lt;/code&gt; 代表二进制，在数字前添加 &lt;code&gt;0x&lt;/code&gt; 代表十六进制&lt;br&gt;注 3：截图中的码流信息均使用十六进制&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="封装格式" scheme="http://github.hezhaojiang.io/tags/%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - FLV 封装格式</title>
    <link href="http://github.hezhaojiang.io/post/2020/dff5a5c3/"/>
    <id>http://github.hezhaojiang.io/post/2020/dff5a5c3/</id>
    <published>2020-11-15T06:42:37.000Z</published>
    <updated>2020-11-16T16:26:43.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于 FLV 封装格式，随便在网络上一搜索，便能搜到一张包浆图：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201115225122.png" alt="FLV 封装格式"></p><a id="more"></a><h2 id="The-FLV-header"><a href="#The-FLV-header" class="headerlink" title="The FLV header"></a>The FLV header</h2><p>An FLV file shall begin with the FLV header:</p><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>Signature</td><td>uint_8</td><td>Signature byte always ‘F’ (0x46)</td></tr><tr><td>Signature</td><td>uint_8</td><td>Signature byte always ‘L’ (0x4C)</td></tr><tr><td>Signature</td><td>uint_8</td><td>Signature byte always ‘V’ (0x56)</td></tr><tr><td>Version</td><td>uint_8</td><td>File version (for example, 0x01 for FLV version 1)</td></tr><tr><td>TypeFlagsReserved</td><td>ubit[5]</td><td>Shall be 0</td></tr><tr><td>TypeFlagsAudio</td><td>ubit[1]</td><td>1 = Audio tags are present</td></tr><tr><td>TypeFlagsReserved</td><td>ubit[1]</td><td>Shall be 0</td></tr><tr><td>TypeFlagsVideo</td><td>ubit[1]</td><td>1 = Video tags are present</td></tr><tr><td>DataOffset</td><td>uint_32</td><td>The length of this header in bytes</td></tr></tbody></table></div><p>The DataOffset field usually has a value of 9 for FLV version 1. This field is present to accommodate larger headers<br>in future versions.</p><h2 id="The-FLV-File-Body"><a href="#The-FLV-File-Body" class="headerlink" title="The FLV File Body"></a>The FLV File Body</h2><p>After the FLV header, the remainder of an FLV file shall consist of alternating back-pointers and tags. They<br>interleave as shown in the following table:</p><p>FLV File Body</p><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>PreviousTagSize0</td><td>uint_32</td><td>Always 0</td></tr><tr><td>Tag1</td><td>FLVTAG</td><td>First tag</td></tr><tr><td>PreviousTagSize1</td><td>uint_32</td><td>Size of previous tag, including its header, in bytes. For FLV version1, this value is 11 plus the DataSize of the previous tag.</td></tr><tr><td>Tag2</td><td>FLVTAG</td><td>Second tag</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>PreviousTagSizeN-1</td><td>uint_32</td><td>Size of second-to-last tag, including its header, in bytes.</td></tr><tr><td>TagN</td><td>FLVTAG</td><td>Last tag</td></tr><tr><td>PreviousTagSizeN</td><td>uint_32</td><td>Size of last tag, including its header, in bytes.</td></tr></tbody></table></div><h2 id="FLV-Tag-Definition"><a href="#FLV-Tag-Definition" class="headerlink" title="FLV Tag Definition"></a>FLV Tag Definition</h2><h3 id="FLV-Tag-Header"><a href="#FLV-Tag-Header" class="headerlink" title="FLV Tag Header"></a>FLV Tag Header</h3><p>The FLV tag contains metadata for audio, video, or scriPTS, optional encryption metadata, and the payload.</p><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>Reserved</td><td>ubit[2]</td><td>保留字段 恒为 0</td></tr><tr><td>Filter</td><td>ubit[1]</td><td>0：无需预处理 1：需要对包进行预处理（如解密）</td></tr><tr><td>TagType</td><td>ubit[5]</td><td>tag 类型</td></tr><tr><td>DataSize</td><td>uint_24</td><td>消息长度，包括从 StreamID 以后到 tag 末尾的数据</td></tr><tr><td>Timestamp</td><td>uint_24</td><td>当前 tag 的时间戳，以毫秒为单位</td></tr><tr><td>TimestampExtended</td><td>uint_8</td><td>时间戳的拓展字节</td></tr><tr><td>StreamID</td><td>uint_24</td><td>≡ 0</td></tr></tbody></table></div><ul><li>TagType（tag 类型）<ul><li>8 = 音频</li><li>9 = 视频</li><li>18 = 脚本数据</li></ul></li></ul><p>In playback, the time sequencing of FLV tags depends on the FLV timestamps only. Any timing mechanisms built<br>into the payload data format shall be ignored.</p><h3 id="Audio-Tags"><a href="#Audio-Tags" class="headerlink" title="Audio Tags"></a>Audio Tags</h3><p>FLV 对 AAC 音频格式封装比较特殊，本文中忽略对 AAC 格式音频的 FLV 封装介绍</p><p>The AudioTagHeader contains audio-specific metadata.</p><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>SoundFormat</td><td>ubit[4]</td><td>音频格式</td></tr><tr><td>SoundRate</td><td>ubit[2]</td><td>音频采样率</td></tr><tr><td>SoundSize</td><td>ubit[1]</td><td>音频采样大小</td></tr><tr><td>SoundType</td><td>ubit[1]</td><td>单声道 / 立体声</td></tr><tr><td>AACPacketType</td><td>IF (SoundFormat == 10) uint_8</td></tr><tr><td>AUDIODATA</td><td>Varies by SoundFormat</td></tr></tbody></table></div><ul><li>SoundFormat<ul><li>0 = Linear PCM, platform endian</li><li>1 = ADPCM</li><li>2 = MP3</li><li>3 = Linear PCM, little endian</li><li>4 = Nellymoser 16 kHz mono</li><li>5 = Nellymoser 8 kHz mono</li><li>6 = Nellymoser</li><li>7 = G.711 A-law logarithmic PCM</li><li>8 = G.711 mu-law logarithmic PCM</li><li>9 = reserved</li><li>10 = AAC</li><li>11 = Speex</li><li>14 = MP3 8 kHz</li><li>15 = Device-specific sound</li></ul></li><li>SoundRate<ul><li>0 = 5.5 kHz</li><li>1 = 11 kHz</li><li>2 = 22 kHz</li><li>3 = 44 kHz</li></ul></li><li>SoundSize<ul><li>0 = 8-bit samples</li><li>1 = 16-bit samples</li></ul></li><li>SoundType<ul><li>0 = Mono sound</li><li>1 = Stereo sound</li></ul></li><li>AACPacketType<ul><li>0 = AAC sequence header</li><li>1 = AAC raw</li></ul></li></ul><h3 id="Video-Tags"><a href="#Video-Tags" class="headerlink" title="Video Tags"></a>Video Tags</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>Frame Type</td><td>ubit[4]</td><td>视频帧类型</td></tr><tr><td>CodecID</td><td>ubit[4]</td><td>视频编码格式</td></tr><tr><td>AVCPacketType</td><td>IF (CodecID == 7) uint_8</td><td>AVC 包类型</td></tr><tr><td>CompositionTime</td><td>IF (CodecID == 7) uint_24</td><td>单声道 / 立体声</td></tr><tr><td>VIDEODATA</td><td>VideoTagBody</td><td>Video frame payload or frame info</td></tr></tbody></table></div><ul><li>Frame Type<br>  1 = key frame (for AVC, a seekable frame)<br>  2 = inter frame (for AVC, a non-seekable frame)<br>  3 = disposable inter frame (H.263 only)<br>  4 = generated key frame (reserved for server use only)<br>  5 = video info/command frame</li><li>CodecID<br>  2 = Sorenson H.263<br>  3 = Screen video<br>  4 = On2 VP6<br>  5 = On2 VP6 with alpha channel<br>  6 = Screen video version 2<br>  7 = AVC</li><li>AVCPacketType<br>  0 = AVC sequence header<br>  1 = AVC NALU<br>  2 = AVC end of sequence (lower level NALU sequence ender is not required or supported)</li><li>CompositionTime<ul><li>IF (AVCPacketType == 1) CTS 偏移</li><li>IF (AVCPacketType == 0) 0</li></ul></li></ul><div class="note info no-icon"><p>关于 CTS：这是一个比较难以理解的概念，需要和 PTS，DTS 配合一起理解。<br>首先，PTS（presentation time stamps），DTS(decoder timestamps)，CTS(CompositionTime) 的概念：<br>PTS：显示时间，也就是接收方在显示器显示这帧的时间。单位为 1/90000 秒。<br>DTS：解码时间，也就是 RTP 包中传输的时间戳，表明解码的顺序。单位单位为 1/90000 秒。根据后面的理解，PTS 就是标准中的 CompositionTime<br>CTS 偏移：CTS = (PTS - DTS) / 90 。CTS 的单位是毫秒。<br>PTS 和 DTS 的时间不一样，应该只出现在含有 B 帧的情况下，也就是 main profile 以上。baseline 是没有这个问题的，baseline 的 PTS 和 DTS 一直 x 相同，所以 CTS 一直为 0。</p></div><h3 id="Data-Tags"><a href="#Data-Tags" class="headerlink" title="Data Tags"></a>Data Tags</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>Name</td><td>SCRIPTDATAVALUE</td><td>Method or object name. SCRIPTDATAVALUE.Type = 2 (String)</td></tr><tr><td>Value</td><td>SCRIPTDATAVALUE</td><td>AMF arguments or object properties. SCRIPTDATAVALUE.Type = 8 (ECMA array)</td></tr></tbody></table></div><p>SCRIPTDATAVALUE 类型类似于 AMF 类型：</p><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>Type</td><td>uint_8</td><td>Type of the ScriptDataValue.</td></tr><tr><td>ScriptDataValue</td><td>Varies by Type</td><td>Script data value.</td></tr></tbody></table></div><p>每种 Type 的取值对应的 ScriptDataValue 如下：</p><div class="table-container"><table><thead><tr><th>Type Value</th><th>Type</th><th>ScriptDataValue</th></tr></thead><tbody><tr><td>0</td><td>Number</td><td>DOUBLE</td></tr><tr><td>1</td><td>Boolean</td><td>uint_8</td></tr><tr><td>2</td><td>String</td><td>SCRIPTDATASTRING</td></tr><tr><td>3</td><td>Object</td><td>SCRIPTDATAOBJECT</td></tr><tr><td>4</td><td>MovieClip (reserved, not supported)</td><td></td></tr><tr><td>5</td><td>Null</td><td></td></tr><tr><td>6</td><td>Undefined</td><td></td></tr><tr><td>7</td><td>Reference</td><td>uint_16</td></tr><tr><td>8</td><td>ECMA array</td><td>SCRIPTDATAECMAARRAY</td></tr><tr><td>9</td><td>Object end marker</td><td></td></tr><tr><td>10</td><td>Strict array</td><td>SCRIPTDATASTRICTARRAY</td></tr><tr><td>11</td><td>Date</td><td>SCRIPTDATADATE</td></tr><tr><td>12</td><td>Long string</td><td>SCRIPTDATALONGSTRING</td></tr></tbody></table></div><ul><li>Number: 8 字节 DOUBLE 类型，比如十六进制 <code>00 40 10 00 00 00 00 00 00</code> 就表示的是一个 double 数 <code>4.0</code></li><li>Boolean: 1 字节，使用 <code>00</code> 表示 <code>false</code>，使用 <code>01</code> 表示 <code>true</code></li><li>String: 16 位整数表示字符串的长度 + 字符串</li><li>Object: 内容由多组 String 类型的 SCRIPTDATAVALUE 作为 Key，其他类型的 SCRIPTDATAVALUE 作为 Value 的哈希列表组成，由 3 个字节：<code>00 00 09</code> 来表示结束</li><li>Null: 仅占用 1 字节，那就是 Null 对象标识 0x05</li><li>ECMA array: 32 位整数表示 Object 对象中元素个数 + Object 类型的 SCRIPTDATAVALUE</li><li>Strict array: 32 位整数表示数组元素个数 + 多个其他类型的 SCRIPTDATAVALUE</li><li>Date: 8 字节 double 来表示从 1970/1/1 到表示的时间所经过的毫秒数 + 2 字节无符号整数表示时区</li><li>Long string: 32 位整数表示字符串的长度 + 字符串</li></ul><p>如 FLV 的 Data Tags 信息中最主要的 onMetaData 信息如下：</p><pre><code>02 20 0a 6f 6e 4d 65 74 61 44 61 74 61 08 20 20 20 0d 20 08 64 75 72 61 74 69 6f 6e 20 40 32 0c49 ba 5e 35 3f 20 05 77 69 64 74 68 20 40 8a c0 20 20 20 20 20 20 06 68 65 69 67 68 74 20 40 7e20 20 20 20 20 20 20 0d 76 69 64 65 6f 64 61 74 61 72 61 74 65 20 40 95 41 68 20 20 20 20 20 0966 72 61 6d 65 72 61 74 65 20 40 38 20 20 20 20 20 20 20 0c 76 69 64 65 6f 63 6f 64 65 63 69 6420 40 1c 20 20 20 20 20 20 20 0d 61 75 64 69 6f 64 61 74 61 72 61 74 65 20 40 5f 40 20 20 20 2020 20 0f 61 75 64 69 6f 73 61 6d 70 6c 65 72 61 74 65 20 40 e5 88 80 20 20 20 20 20 0f 61 75 6469 6f 73 61 6d 70 6c 65 73 69 7a 65 20 40 30 20 20 20 20 20 20 20 06 73 74 65 72 65 6f 01 01 200c 61 75 64 69 6f 63 6f 64 65 63 69 64 20 40 24 20 20 20 20 20 20 20 07 65 6e 63 6f 64 65 72 0220 0d 4c 61 76 66 35 38 2e 32 39 2e 31 30 30 20 08 66 69 6c 65 73 69 7a 65 20 41 4a 9e 05 80 2020 20 20 20 09 20 20 01 30 09</code></pre><p>解析后以上数据如下所示：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117000710.png" alt="onMetaData 信息"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于 FLV 封装格式，随便在网络上一搜索，便能搜到一张包浆图：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201115225122.png&quot; alt=&quot;FLV 封装格式&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="封装格式" scheme="http://github.hezhaojiang.io/tags/%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 libevent - 事件主循环</title>
    <link href="http://github.hezhaojiang.io/post/2020/f65e9050/"/>
    <id>http://github.hezhaojiang.io/post/2020/f65e9050/</id>
    <published>2020-11-08T21:03:49.000Z</published>
    <updated>2020-11-28T12:41:13.747Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <code>libevent</code> 中，事件主循环的作用就是执行一个循环，在循环中监听事件以及超时的事件并且将这些激活的事件进行处理。<code>libevent</code> 提供了对用户开放了两种执行事件主循环的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="事件主循环"><a href="#事件主循环" class="headerlink" title="事件主循环"></a>事件主循环</h2><blockquote><p><a href="/post/2020/afa6fb2f/" title="源码阅读 libevent - 结构体：event">源码阅读 libevent - 结构体：event</a> 中提到了 <code>event</code> 结构体的生命周期:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128204050.png" alt="event 的生命周期"></p></blockquote><p>事件主循环做的工作就是该流程图的下半部分：</p><p>pending 状态：等待事件发生<br>active 状态：事件已经发生，等待调用事件回调</p><p>总体流程分为三部分</p><div class="table-container"><table><thead><tr><th>流程</th><th>调用相关函数</th><th>event 状态</th></tr></thead><tbody><tr><td>事件发生</td><td>event_active()</td><td>pending —&gt; avtive</td></tr><tr><td>单次事件处理</td><td>callback done</td><td>avtive —&gt; non-pending</td></tr><tr><td>持久事件处理</td><td>callback done</td><td>avtive —&gt; pending</td></tr></tbody></table></div><p>事件主循环函数 <code>event_base_dispatch()</code> 其实就是调用 <code>event_base_loop()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *event_base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (event_base_loop(event_base, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>event_base_loop()</code> 函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv_p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res, done, retval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 加锁. 在调用 evsel-&gt;dispatch 时会进行解锁, 在调用用户回调函数时也会解锁 */</span></span><br><span class="line">    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;running_loop) &#123;</span><br><span class="line">        event_warnx(<span class="string">&quot;%s: reentrant invocation.  Only one event_base_loop can run on each event_base at once.&quot;</span>, __func__);</span><br><span class="line">        EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;running_loop = <span class="number">1</span>; <span class="comment">/* 只允许一个事件主循环 */</span></span><br><span class="line"></span><br><span class="line">    clear_time_cache(base); <span class="comment">/* 清空缓存的超时 */</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;sig.ev_signal_added &amp;&amp; base-&gt;sig.ev_n_signals_added) evsig_set_base_(base);</span><br><span class="line">    done = <span class="number">0</span>; <span class="comment">/* 用来确定是否退出循环 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EVENT__DISABLE_THREAD_SUPPORT</span></span><br><span class="line">    base-&gt;th_owner_id = EVTHREAD_GET_ID(); <span class="comment">/* 保存当前线程 ID */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    base-&gt;event_gotterm = base-&gt;event_break = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        base-&gt;event_continue = <span class="number">0</span>;</span><br><span class="line">        base-&gt;n_deferreds_queued = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 中止循环的两个条件 */</span></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_gotterm) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_break) <span class="keyword">break</span>;</span><br><span class="line">        tv_p = &amp;tv;</span><br><span class="line">        <span class="comment">/* 如果当前 event_base 里没有已经激活的事件，就将时间最小堆，堆顶的超时值取出来，作为下一轮 dispatch 的超时值</span></span><br><span class="line"><span class="comment">        ** 否则就将超时时间置为 0，evsel-&gt;dispatch 会立马超时返回，激活的事件得以处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (!N_ACTIVE_CALLBACKS(base) &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) timeout_next(base, &amp;tv_p);</span><br><span class="line">        <span class="keyword">else</span> evutil_timerclear(&amp;tv);</span><br><span class="line">        <span class="comment">/* If we have no events, we just exit */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (flags &amp; EVLOOP_NO_EXIT_ON_EMPTY) &amp;&amp;</span><br><span class="line">            !event_haveevents(base) &amp;&amp; !N_ACTIVE_CALLBACKS(base)) &#123;</span><br><span class="line">            event_debug((<span class="string">&quot;%s: no events registered.&quot;</span>, __func__));</span><br><span class="line">            retval = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        event_queue_make_later_events_active(base);</span><br><span class="line">        clear_time_cache(base);</span><br><span class="line">        res = evsel-&gt;dispatch(base, tv_p);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            event_debug((<span class="string">&quot;%s: dispatch returned unsuccessfully.&quot;</span>, __func__));</span><br><span class="line">            retval = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_time_cache(base);</span><br><span class="line">        <span class="comment">/* 将 base 的 min_heap 中所有超时的事件以超时激活类型添加到激活队列中 */</span></span><br><span class="line">        timeout_process(base);</span><br><span class="line">        <span class="keyword">if</span> (N_ACTIVE_CALLBACKS(base)) &#123; <span class="comment">/* 如果激活队列中有事件 */</span></span><br><span class="line">            <span class="comment">/* 执行激活队列中的 event 相应的回调函数，返回的 n 是成功执行的非内部事件数目 */</span></span><br><span class="line">            <span class="keyword">int</span> n = event_process_active(base);</span><br><span class="line">            <span class="comment">/* 如果设置了 EVLOOP_ONCE，并且所有激活的事件都处理完了，那么就退出 event_loop */</span></span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; EVLOOP_ONCE) &amp;&amp; N_ACTIVE_CALLBACKS(base) == <span class="number">0</span> &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">                done = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; EVLOOP_NONBLOCK) <span class="comment">/* 如果设置了 EVLOOP_NONBLOCK 那么也会退出 event_loop 循环 */</span></span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event_debug((<span class="string">&quot;%s: asked to terminate loop.&quot;</span>, __func__));</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    clear_time_cache(base);</span><br><span class="line">    base-&gt;running_loop = <span class="number">0</span>;</span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">return</span> (retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接阅读 <code>event_base_loop()</code> 较为困难，我们根据上述流程进行分析</p><ol><li>事件发生<ul><li>如何监听事件发生</li><li>事件发生后如何激活事件</li></ul></li><li>事件处理<ul><li>如何处理已激活事件</li><li>如何持久化事件</li></ul></li></ol><h2 id="事件发生"><a href="#事件发生" class="headerlink" title="事件发生"></a>事件发生</h2><h3 id="如何监听事件发生"><a href="#如何监听事件发生" class="headerlink" title="如何监听事件发生"></a>如何监听事件发生</h3><h4 id="监听方式"><a href="#监听方式" class="headerlink" title="监听方式"></a>监听方式</h4><p>libevent 提供了多种监听事件的方案，如单次监听、循环监听等，监听方案由 <code>event_base_loop()</code> 参数决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 阻塞, 直到一个 event 变成 active. 在 active 状态的 event 的 Callback 函数执行后，就退出。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_ONCE 0x01</span></span><br><span class="line"><span class="comment">/* 不会阻塞，它仅仅是查看是否已经有 event ready. 有则运行其 callback. 然后退出 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NONBLOCK 0x02</span></span><br><span class="line"><span class="comment">/* 哪怕 event_base 中没有 active 或者 pending 的 event 了。也不退出。直到调用 event_base_loopbreak() or event_base_loopexit(). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当 flags 什么都不设置时，则 loop 一直运行，检查到 event 变为 active 时，运行其 callback 函数。</span></span><br><span class="line"><span class="comment">** 当没有 active 或 pending 的 event 后，退出 loop。</span></span><br><span class="line"><span class="comment">** 有人调用了 event_base_loopbreak() or event_base_loopexit()，也退出 loop. */</span></span><br></pre></td></tr></table></figure><blockquote><p>有关 event_base_loopbreak() 和 event_base_loopexit() 参见：<a href="#">Post not found: 源码阅读 libevent - 事件主循环的停止</a></p></blockquote><h4 id="监听超时时间的计算"><a href="#监听超时时间的计算" class="headerlink" title="监听超时时间的计算"></a>监听超时时间的计算</h4><h4 id="监听-IO-事件和-Signal-事件"><a href="#监听-IO-事件和-Signal-事件" class="headerlink" title="监听 IO 事件和 Signal 事件"></a>监听 IO 事件和 Signal 事件</h4><p><code>libevent</code> 调用 <code>evsel-&gt;dispatch</code> 回调函数监听 <code>IO</code> 事件和 <code>Signal</code> 事件的发生：</p><p>以 <code>select.c</code> 为例：</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select_dispatch</span><span class="params">(struct event_base *base, struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>, i, j, nfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">selectop</span> *<span class="title">selectop</span> = <span class="title">base</span>-&gt;<span class="title">evbase</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectop-&gt;resize_out_sets) &#123;</span><br><span class="line">        fd_set *readset_out = <span class="literal">NULL</span>, *writeset_out = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">size_t</span> sz = selectop-&gt;event_fdsz;</span><br><span class="line">        <span class="keyword">if</span> (!(readset_out = mm_realloc(selectop-&gt;event_readset_out, sz))) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        selectop-&gt;event_readset_out = readset_out;</span><br><span class="line">        <span class="keyword">if</span> (!(writeset_out = mm_realloc(selectop-&gt;event_writeset_out, sz))) &#123;</span><br><span class="line">            <span class="comment">/* We don&#x27;t free readset_out here, since it was already successfully reallocated.</span></span><br><span class="line"><span class="comment">            ** The next time we call select_dispatch, the realloc will be a no-op. */</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        selectop-&gt;event_writeset_out = writeset_out;</span><br><span class="line">        selectop-&gt;resize_out_sets = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(selectop-&gt;event_readset_out, selectop-&gt;event_readset_in, selectop-&gt;event_fdsz);</span><br><span class="line">    <span class="built_in">memcpy</span>(selectop-&gt;event_writeset_out, selectop-&gt;event_writeset_in, selectop-&gt;event_fdsz);</span><br><span class="line">    nfds = selectop-&gt;event_fds + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    res = select(nfds, selectop-&gt;event_readset_out, selectop-&gt;event_writeset_out, <span class="literal">NULL</span>, tv);</span><br><span class="line">    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EINTR) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    event_debug((<span class="string">&quot;%s: select reports %d&quot;</span>, __func__, res));</span><br><span class="line"></span><br><span class="line">    i = evutil_weakrand_range_(&amp;base-&gt;weakrand_seed, nfds);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nfds; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++i&gt;= nfds) i = <span class="number">0</span>;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(i, selectop-&gt;event_readset_out)) res |= EV_READ;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(i, selectop-&gt;event_writeset_out)) res |= EV_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        evmap_io_active_(base, i, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在事件发生后调用 <code>evmap_io_active_()</code> 将发生的事件加入到激活事件队列中，参见 <a href="# 事件发生后如何激活事件">事件发生后如何激活事件</a>。</p><h3 id="事件发生后如何激活事件"><a href="#事件发生后如何激活事件" class="headerlink" title="事件发生后如何激活事件"></a>事件发生后如何激活事件</h3><p>三种事件的激活方式如下图所示：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201111125131.png" alt="事件激活"></p><h4 id="激活-IO-事件"><a href="#激活-IO-事件" class="headerlink" title="激活 IO 事件"></a>激活 IO 事件</h4><h5 id="evmap-io-active"><a href="#evmap-io-active" class="headerlink" title="evmap_io_active_"></a>evmap_io_active_</h5><p>从 <code>select_dispatch</code> 函数中可以看出，对于每一个事件发生的 <code>fd</code>，均会调用一次 <code>evmap_io_active_</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evmap_io_active_</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_io_map</span> *<span class="title">io</span> = &amp;<span class="title">base</span>-&gt;<span class="title">io</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_io</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || fd&gt;= io-&gt;nentries) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 在 IO 事件的哈希表中获取该 fd 已添加的事件 */</span></span><br><span class="line">    GET_IO_SLOT(ctx, io, fd, evmap_io);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ctx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 遍历哈希表中所有该 fd 已添加的事件 */</span></span><br><span class="line">    LIST_FOREACH(ev, &amp;ctx-&gt;events, ev_io_next) &#123;</span><br><span class="line">        <span class="comment">/* 比对 dispatch 的事件和已添加的事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (ev-&gt;ev_events &amp; events) s(ev, ev-&gt;ev_events &amp; events, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-active-nolock"><a href="#event-active-nolock" class="headerlink" title="event_active_nolock_"></a>event_active_nolock_</h5><p><code>evmap_io_active_</code> 对 <code>dispatch</code> 的所有事件进行过滤后，对于所有已添加事件，就需要调用 <code>event_active_nolock_</code> 进行激活。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active_nolock_</span><span class="params">(struct event *ev, <span class="keyword">int</span> res, <span class="keyword">short</span> ncalls)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    base = ev-&gt;ev_base;</span><br><span class="line">    EVENT_BASE_ASSERT_LOCKED(base);</span><br><span class="line">    <span class="comment">/* #define ev_flags ev_evcallback.evcb_flags */</span></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_FINALIZING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* event 是否在激活链表和下一次激活链表中 */</span></span><br><span class="line">    <span class="keyword">switch</span> ((ev-&gt;ev_flags &amp; (EVLIST_ACTIVE|EVLIST_ACTIVE_LATER))) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE|EVLIST_ACTIVE_LATER:</span><br><span class="line">        EVUTIL_ASSERT(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE: <span class="comment">/* We get different kinds of events, add them together */</span></span><br><span class="line">        ev-&gt;ev_res |= res;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE_LATER:</span><br><span class="line">        ev-&gt;ev_res |= res;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ev-&gt;ev_res = res;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_pri &lt; base-&gt;event_running_priority) base-&gt;event_continue = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 对于 signal 事件，需要对 IO 事件触发次数进行计数 */</span></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_SIGNAL) &#123;</span><br><span class="line">        ev-&gt;ev_ncalls = ncalls;</span><br><span class="line">        ev-&gt;ev_pncalls = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event_callback_activate_nolock_(base, event_to_event_callback(ev));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-callback-activate-nolock"><a href="#event-callback-activate-nolock" class="headerlink" title="event_callback_activate_nolock_"></a>event_callback_activate_nolock_</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_callback_activate_nolock_</span><span class="params">(struct event_base *base, struct event_callback *evcb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (evcb-&gt;evcb_flags &amp; EVLIST_FINALIZING) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* event 是否在激活链表和下一次激活链表中 */</span></span><br><span class="line">    <span class="keyword">switch</span> (evcb-&gt;evcb_flags &amp; (EVLIST_ACTIVE|EVLIST_ACTIVE_LATER)) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        EVUTIL_ASSERT(<span class="number">0</span>);</span><br><span class="line">        EVUTIL_FALLTHROUGH;</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE_LATER:</span><br><span class="line">        event_queue_remove_active_later(base, evcb); <span class="comment">/* 删除下一次激活列表中的该 event */</span></span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 没有在激活列表和在下一次激活列表中的 event 会走到这里 */</span></span><br><span class="line">    event_queue_insert_active(base, evcb); <span class="comment">/* 加入激活队列 */</span></span><br><span class="line">    <span class="keyword">if</span> (EVBASE_NEED_NOTIFY(base))evthread_notify_base(base);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-queue-insert-active"><a href="#event-queue-insert-active" class="headerlink" title="event_queue_insert_active"></a>event_queue_insert_active</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">event_queue_insert_active(struct event_base *base, struct event_callback *evcb)</span><br><span class="line">&#123;</span><br><span class="line">    EVENT_BASE_ASSERT_LOCKED(base);</span><br><span class="line">    <span class="comment">/* Double insertion is possible for active events */</span></span><br><span class="line">    <span class="keyword">if</span> (evcb-&gt;evcb_flags &amp; EVLIST_ACTIVE) <span class="keyword">return</span>;</span><br><span class="line">    INCR_EVENT_COUNT(base, evcb-&gt;evcb_flags); <span class="comment">/* 非内部事件计数自增 increase */</span></span><br><span class="line">    evcb-&gt;evcb_flags |= EVLIST_ACTIVE; <span class="comment">/* event 事件增加激活标志位 */</span></span><br><span class="line"></span><br><span class="line">    base-&gt;event_count_active++; <span class="comment">/* 激活事件计数自增 */</span></span><br><span class="line">    MAX_EVENT_COUNT(base-&gt;event_count_active_max, base-&gt;event_count_active);</span><br><span class="line">    <span class="comment">/* #define ev_pri ev_evcallback.evcb_pri 事件优先级 */</span></span><br><span class="line">    EVUTIL_ASSERT(evcb-&gt;evcb_pri &lt; base-&gt;nactivequeues);</span><br><span class="line">    <span class="comment">/* 插入到对应优先级的激活队列尾部 */</span></span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;base-&gt;activequeues[evcb-&gt;evcb_pri], evcb, evcb_active_next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="激活-Signal-事件"><a href="#激活-Signal-事件" class="headerlink" title="激活 Signal 事件"></a>激活 Signal 事件</h4><p>对于 <code>Signal</code> 事件，<code>libevent</code> 将其统一转换为了 <code>IO</code> 事件，在 <code>IO</code> 事件中，有一个特殊的事件专门用来接收信号事件，该特殊事件的回调函数会调用 <code>evmap_signal_active_</code> 将发生的 <code>Signal</code> 事件添加到激活事件列表中。</p><blockquote><p>参见：<a href="/post/2020/89de67d/" title="源码阅读 libevent - 信号事件处理">源码阅读 libevent - 信号事件处理</a></p></blockquote><p><code>evmap_signal_active_</code> 代码如下，其最终也是调用了 <code>event_active_nolock_</code> 进行事件的激活。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evmap_signal_active_</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> sig, <span class="keyword">int</span> ncalls)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> *<span class="title">map</span> = &amp;<span class="title">base</span>-&gt;<span class="title">sigmap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_signal</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; <span class="number">0</span> || sig&gt;= <span class="built_in">map</span>-&gt;nentries) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 在 Signal 事件的数组中获取该 Signal 已添加的事件 */</span></span><br><span class="line">    GET_SIGNAL_SLOT(ctx, <span class="built_in">map</span>, sig, evmap_signal);</span><br><span class="line">    <span class="keyword">if</span> (!ctx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 将该 Signal 已添加的事件全部加入到激活事件列表中 */</span></span><br><span class="line">    LIST_FOREACH(ev, &amp;ctx-&gt;events, ev_signal_next)</span><br><span class="line">        event_active_nolock_(ev, EV_SIGNAL, ncalls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="激活超时事件"><a href="#激活超时事件" class="headerlink" title="激活超时事件"></a>激活超时事件</h4><p>遍历检查小根堆中每个事件是否超时，如果超时，则将其加入到激活队列中，激活事件调用的函数也为 <code>event_active_nolock_</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeout_process</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Caller must hold lock. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (min_heap_empty_(&amp;base-&gt;timeheap)) <span class="keyword">return</span>;</span><br><span class="line">    gettime(base, &amp;now);</span><br><span class="line">    <span class="keyword">while</span> ((ev = min_heap_top_(&amp;base-&gt;timeheap))) &#123;</span><br><span class="line">        <span class="comment">/* 根据小根堆的特性，如果顶部的事件没有超时，其他事件就不用再遍历了 */</span></span><br><span class="line">        <span class="keyword">if</span> (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;now, &gt;)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* delete this event from the I/O queues */</span></span><br><span class="line">        event_del_nolock_(ev, EVENT_DEL_NOBLOCK);</span><br><span class="line">        event_debug((<span class="string">&quot;timeout_process: event: %p, call %p&quot;</span>, ev, ev-&gt;ev_callback));</span><br><span class="line">        event_active_nolock_(ev, EV_TIMEOUT, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>IO</code> 事件的激活是在 <code>libevent</code> 调用多路 <code>IO</code> 复用函数后，然后将发生的事件添加入激活队列</li><li><code>Signal</code> 事件的激活在 <code>libevent</code> 处理 <code>IO</code> 事件的回调中</li><li>超时事件的激活在 <code>libevent</code> 调用完多路 <code>IO</code> 复用函数后，检查小根堆里的超时情况时</li></ul><h2 id="单次事件处理"><a href="#单次事件处理" class="headerlink" title="单次事件处理"></a>单次事件处理</h2><h3 id="如何处理已激活事件"><a href="#如何处理已激活事件" class="headerlink" title="如何处理已激活事件"></a>如何处理已激活事件</h3><h4 id="event-process-active"><a href="#event-process-active" class="headerlink" title="event_process_active"></a>event_process_active</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">event_process_active</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Caller must hold th_base_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evcallback_list</span> *<span class="title">activeq</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">endtime</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxcb = base-&gt;max_dispatch_callbacks;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> limit_after_prio = base-&gt;limit_callbacks_after_prio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;max_dispatch_time.tv_sec &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        update_time_cache(base);</span><br><span class="line">        gettime(base, &amp;tv);</span><br><span class="line">        evutil_timeradd(&amp;base-&gt;max_dispatch_time, &amp;tv, &amp;tv);</span><br><span class="line">        endtime = &amp;tv;</span><br><span class="line">    &#125; <span class="keyword">else</span> endtime = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按优先级遍历激活队列中的事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; base-&gt;nactivequeues; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TAILQ_FIRST(&amp;base-&gt;activequeues[i]) != <span class="literal">NULL</span>) &#123; <span class="comment">/* 同一个优先级下可以有多个事件 */</span></span><br><span class="line">            base-&gt;event_running_priority = i; <span class="comment">/* 设置当前的优先级 */</span></span><br><span class="line">            activeq = &amp;base-&gt;activequeues[i]; <span class="comment">/* 获取优先级 i 下的所有 event 组成的链表 */</span></span><br><span class="line">            <span class="comment">/* 遍历 activeq 链表，调用其中每个 event 的回调函数 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; limit_after_prio) c = event_process_active_single_queue(base, activeq, INT_MAX, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span> c = event_process_active_single_queue(base, activeq, maxcb, endtime);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="keyword">goto</span> done; <span class="comment">/* c 是执行的非内部事件数目 */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c&gt; <span class="number">0</span>) <span class="comment">/* Processed a real event; do not consider lower-priority events */</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* If we get here, all of the events we processed were internal. Continue. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    base-&gt;event_running_priority = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="event-process-active-single-queue"><a href="#event-process-active-single-queue" class="headerlink" title="event_process_active_single_queue"></a>event_process_active_single_queue</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">event_process_active_single_queue</span><span class="params">(struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evcallback_list *activeq, <span class="keyword">int</span> max_to_process, <span class="keyword">const</span> struct timeval *endtime)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_callback</span> *<span class="title">evcb</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    EVUTIL_ASSERT(activeq != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* activeq 为某一优先级的激活队列，该处遍历该优先级的激活队列中的所有事件 */</span></span><br><span class="line">    <span class="comment">/* 从遍历结束的结束条件和遍历下一个事件的方式就可知，每次遍历会在激活队列中删除当前事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (evcb = TAILQ_FIRST(activeq); evcb; evcb = TAILQ_FIRST(activeq)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">/* 在激活队列中删除当前事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (evcb-&gt;evcb_flags &amp; EVLIST_INIT) &#123;</span><br><span class="line">            <span class="comment">/* 激活队列中仅插入了 event 结构体中的 event_callback 结构体，需要获取 event 所在地址 */</span></span><br><span class="line">            ev = event_callback_to_event(evcb);</span><br><span class="line">            <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_PERSIST || ev-&gt;ev_flags &amp; EVLIST_FINALIZING)</span><br><span class="line">                event_queue_remove_active(base, evcb); <span class="comment">/* 永久事件从激活队列中删除 */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                event_del_nolock_(ev, EVENT_DEL_NOBLOCK); <span class="comment">/* 非永久事件从所有队列中删除 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> event_queue_remove_active(base, evcb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(evcb-&gt;evcb_flags &amp; EVLIST_INTERNAL)) ++count; <span class="comment">/* 非内部事件回调次数计数 */</span></span><br><span class="line">        base-&gt;current_event = evcb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (evcb-&gt;evcb_closure) &#123; <span class="comment">/* 在调用回调函数是否进行其他行为 */</span></span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT_SIGNAL:</span><br><span class="line">            EVUTIL_ASSERT(ev != <span class="literal">NULL</span>);</span><br><span class="line">            event_signal_closure(base, ev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT_PERSIST: <span class="comment">/* 对于永久事件，在调用回调函数之前会重新调用 event_add 来添加该事件到对应队列中 */</span></span><br><span class="line">            EVUTIL_ASSERT(ev != <span class="literal">NULL</span>);</span><br><span class="line">            event_persist_closure(base, ev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT: <span class="comment">/* 对于一般事件，直接调用回调函数 */</span></span><br><span class="line">            <span class="keyword">void</span> (*evcb_callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *);</span><br><span class="line">            <span class="keyword">short</span> res;</span><br><span class="line">            EVUTIL_ASSERT(ev != <span class="literal">NULL</span>);</span><br><span class="line">            evcb_callback = *ev-&gt;ev_callback;</span><br><span class="line">            res = ev-&gt;ev_res;</span><br><span class="line">            EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">            evcb_callback(ev-&gt;ev_fd, res, ev-&gt;ev_arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_CB_SELF:</span><br><span class="line">            <span class="keyword">void</span> (*evcb_selfcb)(struct event_callback *, <span class="keyword">void</span> *) = evcb-&gt;evcb_cb_union.evcb_selfcb;</span><br><span class="line">            EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">            evcb_selfcb(evcb, evcb-&gt;evcb_arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT_FINALIZE:</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT_FINALIZE_FREE:</span><br><span class="line">            <span class="keyword">void</span> (*evcb_evfinalize)(struct event *, <span class="keyword">void</span> *);</span><br><span class="line">            <span class="keyword">int</span> evcb_closure = evcb-&gt;evcb_closure;</span><br><span class="line">            EVUTIL_ASSERT(ev != <span class="literal">NULL</span>);</span><br><span class="line">            base-&gt;current_event = <span class="literal">NULL</span>;</span><br><span class="line">            evcb_evfinalize = ev-&gt;ev_evcallback.evcb_cb_union.evcb_evfinalize;</span><br><span class="line">            EVUTIL_ASSERT((evcb-&gt;evcb_flags &amp; EVLIST_FINALIZING));</span><br><span class="line">            EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">            evcb_evfinalize(ev, ev-&gt;ev_arg);</span><br><span class="line">            event_debug_note_teardown_(ev);</span><br><span class="line">            <span class="keyword">if</span> (evcb_closure == EV_CLOSURE_EVENT_FINALIZE_FREE) mm_free(ev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_CB_FINALIZE:</span><br><span class="line">            <span class="keyword">void</span> (*evcb_cbfinalize)(struct event_callback *, <span class="keyword">void</span> *) = evcb-&gt;evcb_cb_union.evcb_cbfinalize;</span><br><span class="line">            base-&gt;current_event = <span class="literal">NULL</span>;</span><br><span class="line">            EVUTIL_ASSERT((evcb-&gt;evcb_flags &amp; EVLIST_FINALIZING));</span><br><span class="line">            EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">            evcb_cbfinalize(evcb, evcb-&gt;evcb_arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            EVUTIL_ASSERT(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line">        base-&gt;current_event = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_break) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (count&gt;= max_to_process) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">if</span> (count &amp;&amp; endtime) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">            update_time_cache(base);</span><br><span class="line">            gettime(base, &amp;now);</span><br><span class="line">            <span class="keyword">if</span> (evutil_timercmp(&amp;now, endtime,&gt;=)) <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_continue) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何持久化事件"><a href="#如何持久化事件" class="headerlink" title="如何持久化事件"></a>如何持久化事件</h4><p><code>libevent</code> 持久化事件是在调用事件的回调函数之前，调用 <code>event_add_nolock_</code> 重新将事件添加到事件列表中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Closure function invoked when we&#x27;re activating a persistent event. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">event_persist_closure</span><span class="params">(struct event_base *base, struct event *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*evcb_callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="comment">// Other fields of *ev that must be stored before executing</span></span><br><span class="line">    <span class="keyword">evutil_socket_t</span> evcb_fd;</span><br><span class="line">    <span class="keyword">short</span> evcb_res;</span><br><span class="line">    <span class="keyword">void</span> *evcb_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reschedule the persistent event if we have a timeout. */</span></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_io_timeout.tv_sec || ev-&gt;ev_io_timeout.tv_usec) &#123;</span><br><span class="line">        <span class="comment">/* If there was a timeout, we want it to run at an interval of ev_io_timeout after the last time</span></span><br><span class="line"><span class="comment">        ** it was _scheduled_ for, not ev_io_timeout after _now_.  If it fired for another reason,</span></span><br><span class="line"><span class="comment">        ** though,the timeout ought to start ticking _now_. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">run_at</span>, <span class="title">relative_to</span>, <span class="title">delay</span>, <span class="title">now</span>;</span></span><br><span class="line">        <span class="keyword">ev_uint32_t</span> usec_mask = <span class="number">0</span>;</span><br><span class="line">        EVUTIL_ASSERT(is_same_common_timeout(&amp;ev-&gt;ev_timeout, &amp;ev-&gt;ev_io_timeout));</span><br><span class="line">        gettime(base, &amp;now);</span><br><span class="line">        <span class="keyword">if</span> (is_common_timeout(&amp;ev-&gt;ev_timeout, base)) &#123;</span><br><span class="line">            <span class="built_in">delay</span> = ev-&gt;ev_io_timeout;</span><br><span class="line">            usec_mask = <span class="built_in">delay</span>.tv_usec &amp; ~MICROSECONDS_MASK;</span><br><span class="line">            <span class="built_in">delay</span>.tv_usec &amp;= MICROSECONDS_MASK;</span><br><span class="line">            <span class="keyword">if</span> (ev-&gt;ev_res &amp; EV_TIMEOUT) &#123;</span><br><span class="line">                relative_to = ev-&gt;ev_timeout;</span><br><span class="line">                relative_to.tv_usec &amp;= MICROSECONDS_MASK;</span><br><span class="line">            &#125; <span class="keyword">else</span> relative_to = now;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">delay</span> = ev-&gt;ev_io_timeout;</span><br><span class="line">            <span class="keyword">if</span> (ev-&gt;ev_res &amp; EV_TIMEOUT) relative_to = ev-&gt;ev_timeout;</span><br><span class="line">            <span class="keyword">else</span> relative_to = now;</span><br><span class="line">        &#125;</span><br><span class="line">        evutil_timeradd(&amp;relative_to, &amp;<span class="built_in">delay</span>, &amp;run_at);</span><br><span class="line">        <span class="keyword">if</span> (evutil_timercmp(&amp;run_at, &amp;now, &lt;)) &#123;</span><br><span class="line">            <span class="comment">/* Looks like we missed at least one invocation due to a clock jump, not running the event</span></span><br><span class="line"><span class="comment">            ** loop for a while, really slow callbacks, or something. Reschedule relative to now.*/</span></span><br><span class="line">            evutil_timeradd(&amp;now, &amp;<span class="built_in">delay</span>, &amp;run_at);</span><br><span class="line">        &#125;</span><br><span class="line">        run_at.tv_usec |= usec_mask;</span><br><span class="line">        event_add_nolock_(ev, &amp;run_at, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save our callback before we release the lock</span></span><br><span class="line">    evcb_callback = ev-&gt;ev_callback;</span><br><span class="line">    evcb_fd = ev-&gt;ev_fd;</span><br><span class="line">    evcb_res = ev-&gt;ev_res;</span><br><span class="line">    evcb_arg = ev-&gt;ev_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the lock</span></span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="comment">// Execute the callback</span></span><br><span class="line">    (evcb_callback)(evcb_fd, evcb_res, evcb_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li><li>[2] <a href="https://blog.csdn.net/qq_28114615/article/details/96826553">libevent 源码学习（13）：事件主循环 event_base_loop_HerofH_的博客 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;code&gt;libevent&lt;/code&gt; 中，事件主循环的作用就是执行一个循环，在循环中监听事件以及超时的事件并且将这些激活的事件进行处理。&lt;code&gt;libevent&lt;/code&gt; 提供了对用户开放了两种执行事件主循环的函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;event_base_dispatch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(struct event_base *)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;event_base_loop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(struct event_base *, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="源码" scheme="http://github.hezhaojiang.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 libevent - 工作流程分析</title>
    <link href="http://github.hezhaojiang.io/post/2020/dd5b304b/"/>
    <id>http://github.hezhaojiang.io/post/2020/dd5b304b/</id>
    <published>2020-11-08T20:36:32.000Z</published>
    <updated>2021-01-01T17:23:26.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前的小节讲了很多 <code>libevent</code> 的基础构件，现在以一个实际例子来初步探究 <code>libevent</code> 的基本工作流程。</p><a id="more"></a><h2 id="libevent-工作流程分析"><a href="#libevent-工作流程分析" class="headerlink" title="libevent 工作流程分析"></a>libevent 工作流程分析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_cb</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in the cmd_cb\n&quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    evthread_use_pthreads();</span><br><span class="line">    <span class="comment">// 使用默认的 event_base 配置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new</span>();</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">cmd_ev</span> = <span class="title">event_new</span>(<span class="title">base</span>, <span class="title">STDIN_FILENO</span>,</span></span><br><span class="line"><span class="class">                                     <span class="title">EV_READ</span> | <span class="title">EV_PERSIST</span>, <span class="title">cmd_cb</span>, <span class="title">NULL</span>);</span></span><br><span class="line">    event_add(cmd_ev, <span class="literal">NULL</span>); <span class="comment">// 没有超时</span></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子非常简单，却已经包含了 <code>libevent</code> 的基础工作流程：</p><ol><li><code>event_base_new()</code></li><li><code>event_new()</code></li><li><code>event_add()</code></li><li><code>event_base_dispatch()</code></li></ol><h3 id="evthread-use-pthreads"><a href="#evthread-use-pthreads" class="headerlink" title="evthread_use_pthreads"></a>evthread_use_pthreads</h3><p><code>evthread_use_pthreads()</code> 开启多线程支持。</p><blockquote><p>参见：<a href="/post/2020/52b3bda8/" title="源码阅读 libevent - 多线程：锁和条件变量">源码阅读 libevent - 多线程：锁和条件变量</a></p></blockquote><h3 id="event-base-new"><a href="#event-base-new" class="headerlink" title="event_base_new"></a>event_base_new</h3><p><code>event_base_new()</code> 构造一个 <code>event_base</code> 对象。</p><blockquote><p>参见：<a href="/post/2020/1a2a4fe3/" title="源码阅读 libevent - 创建 event_base">源码阅读 libevent - 创建 event_base</a></p></blockquote><h3 id="event-new"><a href="#event-new" class="headerlink" title="event_new"></a>event_new</h3><p><code>event_new()</code> 创建一个 <code>event</code> 事件。</p><h3 id="event-add"><a href="#event-add" class="headerlink" title="event_add"></a>event_add</h3><p><code>event_add()</code> 将 <code>event</code> 事件加入到 <code>event_base</code> 对象中。</p><blockquote><p>参见：<a href="/post/2020/afa6fb2f/" title="源码阅读 libevent - 结构体：event">源码阅读 libevent - 结构体：event</a></p></blockquote><h3 id="event-base-dispatch"><a href="#event-base-dispatch" class="headerlink" title="event_base_dispatch"></a>event_base_dispatch</h3><p><code>event_base_dispatch()</code> 开始监听 <code>event</code> 事件发生。</p><blockquote><p>参见：<a href="/post/2020/f65e9050/" title="源码阅读 libevent - 事件主循环">源码阅读 libevent - 事件主循环</a></p></blockquote><h2 id="源码学习流程"><a href="#源码学习流程" class="headerlink" title="源码学习流程"></a>源码学习流程</h2><h3 id="该博客文章建议阅读顺序"><a href="#该博客文章建议阅读顺序" class="headerlink" title="该博客文章建议阅读顺序"></a>该博客文章建议阅读顺序</h3><ul><li><a href="/post/2020/a867e274/" title="源码阅读 libevent - 初识 Hello World">源码阅读 libevent - 初识 Hello World</a></li><li><a href="/post/2020/5f35962e/" title="源码阅读 libevent - 日志模块">源码阅读 libevent - 日志模块</a></li><li><a href="/post/2020/58deb66e/" title="源码阅读 libevent - 内存管理">源码阅读 libevent - 内存管理</a></li><li><a href="/post/2020/52b3bda8/" title="源码阅读 libevent - 多线程：锁和条件变量">源码阅读 libevent - 多线程：锁和条件变量</a></li><li><a href="/post/2020/a26c1bab/" title="源码阅读 libevent - 多线程：调试锁">源码阅读 libevent - 多线程：调试锁</a></li><li><a href="/post/2020/ee7292d/" title="源码阅读 libevent - 数据结构：双向链表">源码阅读 libevent - 数据结构：双向链表</a></li><li><a href="/post/2020/e6338d04/" title="源码阅读 libevent - 数据结构：尾队列">源码阅读 libevent - 数据结构：尾队列</a></li><li><a href="/post/2020/542e4e52/" title="源码阅读 libevent - 数据结构：哈希表">源码阅读 libevent - 数据结构：哈希表</a></li><li><a href="/post/2020/517d2de7/" title="源码阅读 libevent - 结构体：event_io_map">源码阅读 libevent - 结构体：event_io_map</a></li><li><a href="/post/2020/a24039d7/" title="源码阅读 libevent - 结构体：event_signal_map">源码阅读 libevent - 结构体：event_signal_map</a></li><li><a href="/post/2020/1a2a4fe3/" title="源码阅读 libevent - 创建 event_base">源码阅读 libevent - 创建 event_base</a></li><li><a href="/post/2020/afa6fb2f/" title="源码阅读 libevent - 结构体：event">源码阅读 libevent - 结构体：event</a></li><li><a href="/post/2020/c8f9ab4c/" title="源码阅读 libevent - 结构体：event_once">源码阅读 libevent - 结构体：event_once</a></li><li><a href="/post/2020/f65e9050/" title="源码阅读 libevent - 事件主循环">源码阅读 libevent - 事件主循环</a></li><li><a href="/post/2020/3a941cca/" title="源码阅读 libevent - 数据结构：小根堆">源码阅读 libevent - 数据结构：小根堆</a></li><li><a href="/post/2020/97886769/" title="源码阅读 libevent - 超时管理：min_heap">源码阅读 libevent - 超时管理：min_heap</a></li><li><a href="/post/2020/89de67d/" title="源码阅读 libevent - 信号事件处理">源码阅读 libevent - 信号事件处理</a></li><li><a href="/post/2020/dd5b304b/" title="源码阅读 libevent - 工作流程分析">源码阅读 libevent - 工作流程分析</a></li><li><a href="/post/2020/27de5435/" title="源码阅读 libevent - 优先级管理">源码阅读 libevent - 优先级管理</a></li><li><a href="/post/2020/39d8a9e7/" title="源码阅读 libevent - 时间管理">源码阅读 libevent - 时间管理</a></li></ul><h3 id="待完成文章"><a href="#待完成文章" class="headerlink" title="待完成文章"></a>待完成文章</h3><p>因为有新系列文章计划，该系列文章仍会持续更新，但不会很频繁了。</p><ul><li>源码阅读 libevent - 超时管理：common timeout</li><li>源码阅读 libevent - 通知机制</li><li>未完待续</li></ul><h3 id="其他资料整理"><a href="#其他资料整理" class="headerlink" title="其他资料整理"></a>其他资料整理</h3><p>本文是我在阅读源码过程中，对自己学习情况的一个记录，学习过程中参考了很多资料，也对所有资料的作者表示感谢：</p><ul><li><a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li><li><a href="https://github.com/KelvinYin/libevent-src-analysis/blob/master/libevent%E6%BA%9090%E7%A0%81%E5%88%86%E6%9E%90.md">libevent-src-analysis/libevent 源码分析. md at master · KelvinYin/libevent-src-analysis</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前的小节讲了很多 &lt;code&gt;libevent&lt;/code&gt; 的基础构件，现在以一个实际例子来初步探究 &lt;code&gt;libevent&lt;/code&gt; 的基本工作流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="源码" scheme="http://github.hezhaojiang.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 libevent - 超时管理：min_heap</title>
    <link href="http://github.hezhaojiang.io/post/2020/97886769/"/>
    <id>http://github.hezhaojiang.io/post/2020/97886769/</id>
    <published>2020-11-05T21:08:22.000Z</published>
    <updated>2020-11-09T05:08:32.171Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>libevent</code> 允许创建一个超时 <code>event</code>，使用 <code>evtimer_new</code> 宏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(b, cb, arg)     event_new((b), -1, 0, (cb), (arg))</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>从宏的实现来看，它一样是用到了一般的 <code>event_new</code>，并且不使用任何的文件描述符。从超时 <code>event</code> 宏的实现来看，无论是 <code>evtimer</code> 创建的 <code>event</code> 还是一般 <code>event_new</code> 创建的 <code>event</code>，都能使得 <code>libevent</code> 进行超时监听。</p><p>使得 <code>libevent</code> 对一个 <code>event</code> 进行超时监听的原因是：在调用 <code>int event_add(struct event *ev, const struct timeval *tv)</code> 的时候，第二参数不能为 <code>NULL</code>，要设置一个超时值。如果为 <code>NULL</code>，那么 <code>libevent</code> 将不会为这个 <code>event</code> 监听超时。下文统一称设置了超时值的 <code>event</code> 为超时 <code>event</code>。</p><h2 id="超时-event-的原理"><a href="#超时-event-的原理" class="headerlink" title="超时 event 的原理"></a>超时 event 的原理</h2><p><code>libevent</code> 对超时进行监听的原理不同于之前讲到的对信号的监听，<code>libevent</code> 对超时的监听的原理是，多路 <code>IO</code> 复用函数都是有一个超时值。如果用户需要 <code>libevent</code> 同时监听多个超时 <code>event</code>，那么 <code>libevent</code> 就把超时值最小的那个作为多路 <code>IO</code> 复用函数的超时值。自然，当时间一到，就会从多路 <code>IO</code> 复用函数返回。此时对超时 <code>event</code> 进行处理即可。</p><p><code>libevent</code> 运行用户同时监听多个超时 <code>event</code>，那么就必须要对这个超时值进行管理。<code>libevent</code> 提供了小根堆 <code>min_heap</code> 和通用超时 <code>common timeout</code> 两种管理方式。本文首先分析小根堆 <code>min_heap</code> 超时管理机制。</p><h2 id="设置超时值"><a href="#设置超时值" class="headerlink" title="设置超时值"></a>设置超时值</h2><p>首先调用 event_add 时要设置一个超时值，这样才能成为一个超时 event。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    res = event_add_nolock_(ev, tv, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add_nolock_</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv, <span class="keyword">int</span> tv_is_absolute)</span> </span>&#123;</span><br><span class="line">    ...... <span class="comment">/* common timeout 相关代码没有展示 */</span></span><br><span class="line">    <span class="comment">/* tv 不为 NULL, 就说明是一个超时 event, 在小根堆中为其留一个位置 */</span></span><br><span class="line">    <span class="keyword">if</span> (tv != <span class="literal">NULL</span> &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_heap_reserve_(&amp;base-&gt;timeheap, <span class="number">1</span> + min_heap_size_(&amp;base-&gt;timeheap)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);  <span class="comment">/* ENOMEM == errno */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">/* 将 IO 或者信号 event 插入到对应的队列中 */</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; tv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">        <span class="comment">/* 用户把这个 event 设置成 EV_PERSIST。即永久 event 如果没有这样设置的话，那么只会超时一次</span></span><br><span class="line"><span class="comment">        ** 设置了，那么就可以超时多次。那么就要记录用户设置的超时值。 */</span></span><br><span class="line">        <span class="keyword">if</span> (ev-&gt;ev_closure == EV_CLOSURE_EVENT_PERSIST &amp;&amp; !tv_is_absolute)</span><br><span class="line">            ev-&gt;ev_io_timeout = *tv;</span><br><span class="line">        <span class="comment">/* 因为可以在次线程调用 event_add。而主线程刚好在执行 event_base_dispatch */</span></span><br><span class="line">        <span class="keyword">if</span> ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp; (ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123; <span class="comment">/* Abort loop */</span></span><br><span class="line">                    *ev-&gt;ev_pncalls = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 从超时队列中删除这个 event。因为下次会再次加入。多次对同一个超时 event 调用 event_add, 那么只能保留最后的那个。 */</span></span><br><span class="line">            event_queue_remove_active(base, event_to_event_callback(ev));</span><br><span class="line">        &#125;</span><br><span class="line">        gettime(base, &amp;now); <span class="comment">/* 获取现在的时间 */</span></span><br><span class="line">        <span class="comment">/* 虽然用户在 event_add 时只需用一个相对时间，但实际上在 Libevent 内部还是要把这个时间转换成绝对时间。</span></span><br><span class="line"><span class="comment">        ** 从存储的角度来说，存绝对时间只需一个变量。而相对时间则需两个，一个存相对值，另一个存参照物。 */</span></span><br><span class="line">        <span class="keyword">if</span> (tv_is_absolute) ev-&gt;ev_timeout = *tv; <span class="comment">/* 该参数指明时间是否为一个绝对时间 */</span></span><br><span class="line">        <span class="keyword">else</span> evutil_timeradd(&amp;now, tv, &amp;ev-&gt;ev_timeout); <span class="comment">/* 参照时间 + 相对时间  ev_timeout 存的是绝对时间 */</span></span><br><span class="line">        event_queue_insert_timeout(base, ev); <span class="comment">/* 将该超时 event 插入到超时队列中 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">top</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">/* 本次插入的超时值，是所有超时中最小的。那么此时就需要通知主线程。. */</span></span><br><span class="line">        <span class="keyword">if</span> (min_heap_elt_is_top_(ev)) notify = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((top = min_heap_top_(&amp;base-&gt;timeheap)) != <span class="literal">NULL</span> &amp;&amp; evutil_timercmp(&amp;top-&gt;ev_timeout, &amp;now, &lt;))</span><br><span class="line">            notify = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果代码逻辑中是需要通知的。并且本线程不是主线程。那么就通知主线程 */</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; notify &amp;&amp; EVBASE_NEED_NOTIFY(base)) evthread_notify_base(base);</span><br><span class="line">    <span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于同一个 <code>event</code>，如果是 <code>IO event</code> 或者 <code>sigal event</code>，那么将无法多次添加。但如果是一个超时 <code>event</code>，那么是可以多次添加的。并且对应超时值会使用最后添加时指明的那个，之前的统统不要，即替换掉之前的超时值。</p><h2 id="调用多路-IO-复用函数等待超时"><a href="#调用多路-IO-复用函数等待超时" class="headerlink" title="调用多路 IO 复用函数等待超时"></a>调用多路 IO 复用函数等待超时</h2><h3 id="event-base-loop"><a href="#event-base-loop" class="headerlink" title="event_base_loop"></a>event_base_loop</h3><p>现在来看一下 <code>event_base_loop</code> 函数，看其是怎么处理超时 <code>event</code> 的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 非超时相关代码没有展示 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv_p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res, done, retval = <span class="number">0</span>;</span><br><span class="line">    done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        tv_p = &amp;tv;</span><br><span class="line">        <span class="keyword">if</span> (!N_ACTIVE_CALLBACKS(base) &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;</span><br><span class="line">            <span class="comment">/* 根据 Timer 事件计算 evsel-&gt;dispatch 的最大等待时间（超时值最小） */</span></span><br><span class="line">            timeout_next(base, &amp;tv_p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* if we have active events, we just poll new events without waiting. */</span></span><br><span class="line">            evutil_timerclear(&amp;tv);</span><br><span class="line">        &#125;</span><br><span class="line">        res = evsel-&gt;dispatch(base, tv_p);</span><br><span class="line">        <span class="comment">/* 处理超时事件，将超时事件插入到激活链表中 */</span></span><br><span class="line">        timeout_process(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> (retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>event_base_loop()</code> 中有关超时管理方面工作不多，最主要的工作有两部分：</p><ol><li><p>设置 <code>dispatch</code> 回调的第二个参数 <code>tv</code>，这个参数如果为 <code>0</code>, 则无论是否有事件发生，都会立即返回。</p><ol><li><p>如果设置了 <code>EVLOOP_NONBLOCK</code> 标志位，则会调用 <code>evutil_timerclear()</code> 将 <code>tv</code> 设置为 <code>0</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不会阻塞，它仅仅是查看是否已经有 event ready. 有则运行其 callback. 然后退出 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NONBLOCK 0x02</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerclear(tvp)  (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0</span></span><br></pre></td></tr></table></figure></li><li><p>如果不存在激活的 <code>event</code>，也会调用 <code>evutil_timerclear()</code> 将 <code>tv</code> 设置为 <code>0</code></p></li><li>如果存在激活的 <code>event</code> 且没有设置 <code>EVLOOP_NONBLOCK</code> 标志位，则需要调用 <code>timeout_next()</code> 获取最近的超时 <code>event</code>，并作为等待事件的时间传给 <code>dispatch</code> 回调函数</li></ol></li><li><p>调用 <code>timeout_process()</code> 函数将超时了的 <code>event</code> 加入激活队列。</p></li></ol><h3 id="timeout-next"><a href="#timeout-next" class="headerlink" title="timeout_next"></a>timeout_next</h3><p><code>timeout_next()</code> 用来计算出本次调用多路 <code>IO</code> 复用函数的等待时间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">timeout_next</span><span class="params">(struct event_base *base, struct timeval **tv_p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Caller must hold th_base_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv</span> = *<span class="title">tv_p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 堆的首元素具有最小的超时值，这个是小根堆的性质。 */</span></span><br><span class="line">    ev = min_heap_top_(&amp;base-&gt;timeheap);</span><br><span class="line">    <span class="keyword">if</span> (ev == <span class="literal">NULL</span>) &#123; *tv_p = <span class="literal">NULL</span>; <span class="keyword">goto</span> out; &#125; <span class="comment">/* 堆中没有元素 */</span></span><br><span class="line">    <span class="keyword">if</span> (gettime(base, &amp;now) == <span class="number">-1</span>) &#123; res = <span class="number">-1</span>; <span class="keyword">goto</span> out; &#125; <span class="comment">/* /* 获取当前时间 */</span></span><br><span class="line">    <span class="comment">/* 如果超时时间 &lt;= 当前时间，不能等待，需要立即返回</span></span><br><span class="line"><span class="comment">    ** 因为 ev_timeout 这个时间是由 event_add 调用时的绝对时间 + 相对时间。所以 ev_timeout 是绝对时间。</span></span><br><span class="line"><span class="comment">    ** 可能在调用 event_add 之后，过了一段时间才调用 event_base_diapatch, 所以现在可能都过了用户设置的超时时间。 */</span></span><br><span class="line">    <span class="keyword">if</span> (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;now, &lt;=)) &#123; evutil_timerclear(tv); <span class="keyword">goto</span> out; &#125;</span><br><span class="line">    <span class="comment">/* 计算等待的时间 = 当前时间 - 最小的超时时间 */</span></span><br><span class="line">    evutil_timersub(&amp;ev-&gt;ev_timeout, &amp;now, tv);</span><br><span class="line">    event_debug((<span class="string">&quot;timeout_next: event: %p, in %d seconds, %d useconds&quot;</span>, ev, (<span class="keyword">int</span>)tv-&gt;tv_sec, (<span class="keyword">int</span>)tv-&gt;tv_usec));</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="timeout-process"><a href="#timeout-process" class="headerlink" title="timeout_process"></a>timeout_process</h3><p><code>timeout_process()</code> 函数将超时了的 <code>event</code> 加入激活队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeout_process</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min_heap_empty_(&amp;base-&gt;timeheap)) <span class="keyword">return</span>;</span><br><span class="line">    gettime(base, &amp;now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历小根堆的元素。之所以不是只取堆顶那一个元素，是因为当主线程调用多路 IO 复用函数进入等待时，次线程可能添加了多个超时值更小的 event */</span></span><br><span class="line">    <span class="keyword">while</span> ((ev = min_heap_top_(&amp;base-&gt;timeheap))) &#123;</span><br><span class="line">        <span class="comment">/* ev-&gt;ev_timeout 存的是绝对时间，超时时间比此刻时间大，说明该 event 还没超时。那么余下的小根堆元素更不用检查了。 */</span></span><br><span class="line">        <span class="keyword">if</span> (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;now, &gt;)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 下面说到的 del 是等同于调用 event_del. 把 event 从这个 event_base 中 (所有的队列都) 删除。event_base 不再监听之。</span></span><br><span class="line"><span class="comment">        ** 这里是 timeout_process 函数。所以对于有超时的 event，才会被 del 掉。</span></span><br><span class="line"><span class="comment">        ** 对于有 EV_PERSIST 选项的 event，在处理激活 event 的时候，会再次添加进 event_base 的。</span></span><br><span class="line"><span class="comment">        ** 这样做的一个好处就是，再次添加的时候，又可以重新计算该 event 的超时时间 (绝对时间)。 */</span></span><br><span class="line">        event_del_nolock_(ev, EVENT_DEL_NOBLOCK);</span><br><span class="line">        <span class="comment">/* 把这个 event 加入到 event_base 的激活队列中。event_base 的激活队列又有该 event 了。</span></span><br><span class="line"><span class="comment">        ** 如果该 event 是 EV_PERSIST 的，可以再次添加进该 event_base */</span></span><br><span class="line">        event_active_nolock_(ev, EV_TIMEOUT, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当从多路 <code>IO</code> 复用函数返回时，就检查时间小根堆，看有多少个 <code>event</code> 已经超时了。如果超时了，那就把这个 <code>event</code> 加入到 <code>event_base</code> 的激活队列中。并且把这个超时删除掉。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li><li>[2] <a href="https://github.com/KelvinYin/libevent-src-analysis/blob/master/libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">libevent-src-analysis/libevent 源码分析. md at master · KelvinYin/libevent-src-analysis</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;libevent&lt;/code&gt; 允许创建一个超时 &lt;code&gt;event&lt;/code&gt;，使用 &lt;code&gt;evtimer_new&lt;/code&gt; 宏。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; evtimer_new(b, cb, arg)     event_new((b), -1, 0, (cb), (arg))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="源码" scheme="http://github.hezhaojiang.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C++ - 位运算函数</title>
    <link href="http://github.hezhaojiang.io/post/2020/aa6f0789/"/>
    <id>http://github.hezhaojiang.io/post/2020/aa6f0789/</id>
    <published>2020-11-05T08:32:28.000Z</published>
    <updated>2021-01-03T05:29:00.650Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 LeetCode 刷题时，经常会用到 C++ 的一些位运算函数，在此记录下防止需要用时忘记。</p><blockquote><p>需要注意，以下函数均为 gcc 提供的内置位运算函数，在其他编译环境上无法使用。</p></blockquote><a id="more"></a><h2 id="builtin-parity-n"><a href="#builtin-parity-n" class="headerlink" title="__builtin_parity(n)"></a>__builtin_parity(n)</h2><p>该函数是判断 n 的二进制中 1 的个数的奇偶性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">15</span>;                         <span class="comment">// 二进制为 1111</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">7</span>;                          <span class="comment">// 二进制为 111</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_parity(n)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 偶数个 1，输出 0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_parity(m)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 奇数个 1，输出 1</span></span><br></pre></td></tr></table></figure><h2 id="builtin-popcount-n"><a href="#builtin-popcount-n" class="headerlink" title="__builtin_popcount(n)"></a>__builtin_popcount(n)</h2><p>该函数时判断 n 的二进制中有多少个 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">15</span>;                         <span class="comment">// 二进制为 1111</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_popcount(n)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 输出结果为 4</span></span><br></pre></td></tr></table></figure><h2 id="builtin-ctz-n"><a href="#builtin-ctz-n" class="headerlink" title="__builtin_ctz(n)"></a>__builtin_ctz(n)</h2><p>该函数判断 n 的二进制末尾后面 0 的个数，n = 0 时结果未定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;                      <span class="comment">// 二进制为 1</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">8</span>;                      <span class="comment">// 二进制为 1000</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ctzll(n)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ctz(m)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><h2 id="builtin-clz-n"><a href="#builtin-clz-n" class="headerlink" title="__builtin_clz(n)"></a>__builtin_clz(n)</h2><p>n 前导 0 的个数, n = 0 时结果未定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">1</span>;                <span class="comment">// 二进制为 000....001 64 位整数</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">8</span>;                      <span class="comment">// 二进制为 000...1000 32 位整数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_clzll(n)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出 63</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_clz(m)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 输出 28</span></span><br></pre></td></tr></table></figure><h2 id="builtin-ffs-n"><a href="#builtin-ffs-n" class="headerlink" title="__builtin_ffs(n)"></a>__builtin_ffs(n)</h2><p>该函数判断 n 的二进制末尾最后一个 1 的位置，从 1 开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;                      <span class="comment">// 二进制为 1</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">8</span>;                      <span class="comment">// 二进制为 1000</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ffs(n)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ffs(m)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 LeetCode 刷题时，经常会用到 C++ 的一些位运算函数，在此记录下防止需要用时忘记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意，以下函数均为 gcc 提供的内置位运算函数，在其他编译环境上无法使用。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://github.hezhaojiang.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 libevent - 结构体：event_once</title>
    <link href="http://github.hezhaojiang.io/post/2020/c8f9ab4c/"/>
    <id>http://github.hezhaojiang.io/post/2020/c8f9ab4c/</id>
    <published>2020-11-04T08:20:40.000Z</published>
    <updated>2020-11-04T16:37:30.027Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于只需要触发一次的事件，<code>libevent</code> 提供了一种方案：<code>event_once</code>，让使用者不需要手动管理 <code>event</code>，并且也保证了事件被触发后，内存会被自动被释放。</p><a id="more"></a><h2 id="struct-event-once-的定义"><a href="#struct-event-once-的定义" class="headerlink" title="struct event_once 的定义"></a>struct event_once 的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_once</span> &#123;</span></span><br><span class="line">    LIST_ENTRY(event_once) next_once;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*cb)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建-event-once"><a href="#创建-event-once" class="headerlink" title="创建 event_once"></a>创建 event_once</h2><p>并没有 <code>event_once_new()</code> 之类的函数用于创建 <code>event_once</code>，要使用它要到一个新的函数 <code>event_base_once()</code>, 它将 <code>event_new()</code> 和 <code>event_add()</code> 两个步骤合成了一个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Schedules an event once */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_once</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">const</span> struct timeval *tv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((eonce = mm_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct event_once))) == <span class="literal">NULL</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    eonce-&gt;cb = callback;</span><br><span class="line">    eonce-&gt;arg = arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((events &amp; (EV_TIMEOUT|EV_SIGNAL|EV_READ|EV_WRITE|EV_CLOSED)) == EV_TIMEOUT) &#123;</span><br><span class="line">        evtimer_assign(&amp;eonce-&gt;ev, base, event_once_cb, eonce);</span><br><span class="line">        <span class="keyword">if</span> (tv == <span class="literal">NULL</span> || ! evutil_timerisset(tv)) activate = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; (EV_READ|EV_WRITE|EV_CLOSED)) &#123;</span><br><span class="line">        events &amp;= EV_READ|EV_WRITE|EV_CLOSED;</span><br><span class="line">        event_assign(&amp;eonce-&gt;ev, base, fd, events, event_once_cb, eonce);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mm_free(eonce);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activate) event_active_nolock_(&amp;eonce-&gt;ev, EV_TIMEOUT, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> res = event_add_nolock_(&amp;eonce-&gt;ev, tv, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">            mm_free(eonce);</span><br><span class="line">            <span class="keyword">return</span> (res);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LIST_INSERT_HEAD(&amp;base-&gt;once_events, eonce, next_once);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>event_base_once()</code> 的参数也和 <code>event_new()</code> 一样，功能也是一样，不做额外的解释，主要看一下 <code>event_once()</code> 里边的多出来的回调函数用来干了什么事情。</p><p>我们用 <code>event_once-&gt;cb</code> 和 <code>event-&gt;cb</code> 分别表示 <code>event_once</code> 和 <code>event</code> 里的回调函数。首先函数入口处直接把参数里的 <code>callback</code> 赋值给了 <code>event_once-&gt;cb</code>，它用来负责实际的事件回调。然后调用 <code>event_assign</code> 新建一个 <code>event</code> 初始化 <code>event_once-&gt;event</code> 的同时，传入了一个 <code>event_once_cb()</code> 回调函数。这个函数才是事件发生时会被回调的函数，也是一次性事件的秘密所在。</p><h2 id="event-once-的回调和销毁"><a href="#event-once-的回调和销毁" class="headerlink" title="event_once 的回调和销毁"></a>event_once 的回调和销毁</h2><p>上文中说到，<code>event_once_cb()</code> 是一次性事件的真正回调函数，我们来看下该函数的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_once_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_once</span> *<span class="title">eonce</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    (*eonce-&gt;cb)(fd, events, eonce-&gt;arg);</span><br><span class="line">    EVBASE_ACQUIRE_LOCK(eonce-&gt;ev.ev_base, th_base_lock);</span><br><span class="line">    LIST_REMOVE(eonce, next_once);</span><br><span class="line">    EVBASE_RELEASE_LOCK(eonce-&gt;ev.ev_base, th_base_lock);</span><br><span class="line">    event_debug_unassign(&amp;eonce-&gt;ev);</span><br><span class="line">    mm_free(eonce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>event_once_cb()</code> 这个函数被回调时，会马上调用 <code>event_once-&gt;cb</code>, 然后把他从一次性事件的链表里移除，最后释放掉整个 <code>event_once</code> 所分配的内存。</p><p>要是这个事件不触发，那么他的回调函数就不会被释放，<code>event_once</code> 所占用的内存就得不到释放，我们无法获得它的指针对其 <code>free</code>。一次性事件链表就是为了解决这个问题的，他是 <code>event_base</code> 里的一个结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST_HEAD(once_event_list, event_once) once_events;</span><br></pre></td></tr></table></figure><p>所有的 <code>event_once</code> 在释放之前都会保留在这个链表里，除了 <code>event_once_cb()</code> 触发时会被移除，在 <code>event_base</code> 被释放时，也会将所有 <code>once_events</code> 里的 <code>event_once</code> 逐个释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_base_free_</span><span class="params">(struct event_base *base, <span class="keyword">int</span> run_finalizers)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (LIST_FIRST(&amp;base-&gt;once_events)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_once</span> *<span class="title">eonce</span> = <span class="title">LIST_FIRST</span>(&amp;<span class="title">base</span>-&gt;<span class="title">once_events</span>);</span></span><br><span class="line">        LIST_REMOVE(eonce, next_once);</span><br><span class="line">        mm_free(eonce);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li><li>[2] <a href="http://www.ilovecpp.com/2018/05/01/libevent-event-analyze/">抽丝剥茧 libevent——初识 event | Baixiangcpp’s Blog</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于只需要触发一次的事件，&lt;code&gt;libevent&lt;/code&gt; 提供了一种方案：&lt;code&gt;event_once&lt;/code&gt;，让使用者不需要手动管理 &lt;code&gt;event&lt;/code&gt;，并且也保证了事件被触发后，内存会被自动被释放。&lt;/p&gt;</summary>
    
    
    
    
    <category term="源码" scheme="http://github.hezhaojiang.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
