<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何照江的博客</title>
  
  
  <link href="http://github.hezhaojiang.io/atom.xml" rel="self"/>
  
  <link href="http://github.hezhaojiang.io/"/>
  <updated>2021-01-21T16:45:37.123Z</updated>
  <id>http://github.hezhaojiang.io/</id>
  
  <author>
    <name>何照江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>源码阅读 x264 - 离散余弦变换</title>
    <link href="http://github.hezhaojiang.io/post/2021/f0753f9a/"/>
    <id>http://github.hezhaojiang.io/post/2021/f0753f9a/</id>
    <published>2021-01-21T08:23:29.000Z</published>
    <updated>2021-01-21T16:45:37.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中 <code>x264_dct_init</code> 函数中初始化了与离散余弦变换有关的函数，本文分析部分离散余弦变换函数的实现</p><a id="more"></a><p>DCT 变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，之后在压缩时就可以去除掉人眼不敏感的高频信息（位于矩阵右下角的系数），从而达到压缩数据的目的。</p><p>关于 DCT 的计算，都是通过 <code>x264_dct_init</code> 函数内定义的 <code>DCT</code> 和 <code>IDCT</code> 函数完成的，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_dct_init</span><span class="params">(<span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_dct_function_t</span> *dctf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dctf-&gt;sub4x4_dct    = sub4x4_dct;</span><br><span class="line">    dctf-&gt;add4x4_idct   = add4x4_idct;</span><br><span class="line"></span><br><span class="line">    dctf-&gt;sub8x8_dct    = sub8x8_dct;</span><br><span class="line">    dctf-&gt;sub8x8_dct_dc = sub8x8_dct_dc;</span><br><span class="line">    dctf-&gt;add8x8_idct   = add8x8_idct;</span><br><span class="line">    dctf-&gt;add8x8_idct_dc = add8x8_idct_dc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处省略大量平台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="dct-函数命名规律"><a href="#dct-函数命名规律" class="headerlink" title="dct 函数命名规律"></a>dct 函数命名规律</h2><p>从源代码可以看出，<code>x264_dct_init()</code> 初始化了一系列的 <code>DCT</code> 变换的函数，这些 <code>DCT</code> 函数名称有如下规律：</p><ol><li><code>DCT</code> 函数名称前面有 <code>sub</code>，代表对两块像素相减得到残差之后，再进行 <code>DCT</code> 变换。</li><li><code>DCT</code> 反变换函数名称前面有 <code>add</code>，代表将 <code>DCT</code> 反变换之后的残差数据叠加到预测数据上。</li><li>以 <code>dct8</code> 为结尾的函数使用了 <code>8x8DCT</code>，其余函数是用的都是 <code>4x4DCT</code>。</li></ol><h2 id="sub4x4-dct"><a href="#sub4x4-dct" class="headerlink" title="sub4x4_dct"></a>sub4x4_dct</h2><p><code>sub4x4_dct()</code> 可以将两块 <code>4x4</code> 的图像相减求残差后，进行 <code>DCT</code> 变换，源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sub4x4_dct</span><span class="params">(dctcoef dct[<span class="number">16</span>], pixel *pix1, pixel *pix2 )</span> </span>&#123;</span><br><span class="line">    dctcoef d[<span class="number">16</span>];</span><br><span class="line">    dctcoef tmp[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    pixel_sub_wxh(d, <span class="number">4</span>, pix1, FENC_STRIDE, pix2, FDEC_STRIDE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s03 = d[i*<span class="number">4</span>+<span class="number">0</span>] + d[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> s12 = d[i*<span class="number">4</span>+<span class="number">1</span>] + d[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> d03 = d[i*<span class="number">4</span>+<span class="number">0</span>] - d[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> d12 = d[i*<span class="number">4</span>+<span class="number">1</span>] - d[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        tmp[<span class="number">0</span>*<span class="number">4</span>+i] =   s03 +   s12;</span><br><span class="line">        tmp[<span class="number">1</span>*<span class="number">4</span>+i] = <span class="number">2</span>*d03 +   d12;</span><br><span class="line">        tmp[<span class="number">2</span>*<span class="number">4</span>+i] =   s03 -   s12;</span><br><span class="line">        tmp[<span class="number">3</span>*<span class="number">4</span>+i] =   d03 - <span class="number">2</span>*d12;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s03 = tmp[i*<span class="number">4</span>+<span class="number">0</span>] + tmp[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> s12 = tmp[i*<span class="number">4</span>+<span class="number">1</span>] + tmp[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> d03 = tmp[i*<span class="number">4</span>+<span class="number">0</span>] - tmp[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> d12 = tmp[i*<span class="number">4</span>+<span class="number">1</span>] - tmp[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">0</span>] =   s03 +   s12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">1</span>] = <span class="number">2</span>*d03 +   d12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">2</span>] =   s03 -   s12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">3</span>] =   d03 - <span class="number">2</span>*d12;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码中涉及函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pixel_sub_wxh</span><span class="params">( dctcoef *diff, <span class="keyword">int</span> i_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  pixel *pix1, <span class="keyword">int</span> i_pix1, pixel *pix2, <span class="keyword">int</span> i_pix2 )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; i_size; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; i_size; x++)</span><br><span class="line">            diff[x + y * i_size] = pix1[x] - pix2[x];</span><br><span class="line">        pix1 += i_pix1;</span><br><span class="line">        pix2 += i_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add4x4-idct"><a href="#add4x4-idct" class="headerlink" title="add4x4_idct"></a>add4x4_idct</h2><p><code>add4x4_idct()</code> 可以将残差数据进行 <code>DCT</code> 反变换，并将变换后得到的残差像素数据叠加到预测数据上，源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add4x4_idct</span><span class="params">(pixel *p_dst, dctcoef dct[<span class="number">16</span>] )</span> </span>&#123;</span><br><span class="line">    dctcoef d[<span class="number">16</span>];</span><br><span class="line">    dctcoef tmp[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s02 =  dct[<span class="number">0</span>*<span class="number">4</span>+i]     +  dct[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> d02 =  dct[<span class="number">0</span>*<span class="number">4</span>+i]     -  dct[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> s13 =  dct[<span class="number">1</span>*<span class="number">4</span>+i]     + (dct[<span class="number">3</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> d13 = (dct[<span class="number">1</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>) -  dct[<span class="number">3</span>*<span class="number">4</span>+i];</span><br><span class="line"></span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">0</span>] = s02 + s13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">1</span>] = d02 + d13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">2</span>] = d02 - d13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">3</span>] = s02 - s13;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s02 =  tmp[<span class="number">0</span>*<span class="number">4</span>+i]     +  tmp[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> d02 =  tmp[<span class="number">0</span>*<span class="number">4</span>+i]     -  tmp[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> s13 =  tmp[<span class="number">1</span>*<span class="number">4</span>+i]     + (tmp[<span class="number">3</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> d13 = (tmp[<span class="number">1</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>) -  tmp[<span class="number">3</span>*<span class="number">4</span>+i];</span><br><span class="line"></span><br><span class="line">        d[<span class="number">0</span>*<span class="number">4</span>+i] = ( s02 + s13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">1</span>*<span class="number">4</span>+i] = ( d02 + d13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">2</span>*<span class="number">4</span>+i] = ( d02 - d13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">3</span>*<span class="number">4</span>+i] = ( s02 - s13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++)</span><br><span class="line">            p_dst[x] = x264_clip_pixel( p_dst[x] + d[y*<span class="number">4</span>+x] );</span><br><span class="line">        p_dst += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li><li>[2] <a href="http://lazybing.github.io/blog/2017/07/10/x264-dct-init/">X264 源码解析之 x264_dct_init 函数 - 懒人李冰</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;x264&lt;/code&gt; 中 &lt;code&gt;x264_dct_init&lt;/code&gt; 函数中初始化了与离散余弦变换有关的函数，本文分析部分离散余弦变换函数的实现&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 代价计算</title>
    <link href="http://github.hezhaojiang.io/post/2021/ae3a0f38/"/>
    <id>http://github.hezhaojiang.io/post/2021/ae3a0f38/</id>
    <published>2021-01-21T06:43:32.000Z</published>
    <updated>2021-01-21T16:22:13.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中 <code>x264_pixel_init</code> 函数中初始化了与代价计算有关的函数，本文分析部分代价计算函数的实现，包括 <code>SAD</code>、<code>SATD</code>、<code>SSD</code>、等</p><ul><li>SAD (Sum of Absolute Difference) = SAE(Sum of Absolute Error) 绝对误差和</li><li>SATD（Sum of Absolute Transformed Difference）即 hadamard 变换后再绝对值求和</li><li>SSD（Sum of Squared Difference）= SSE（Sum of Squared Error) 差值的平方和</li><li>MAD（Mean Absolute Difference）= MAE（Mean Absolute Error) 平均绝对差值</li><li>MSD（Mean Squared Difference）= MSE（Mean Squared Error）平均平方误差</li></ul><a id="more"></a><p>下面分别介绍 <code>SAD</code>、<code>SSD</code>、<code>SATD</code> 的实现过程。</p><h2 id="SAD-实现过程"><a href="#SAD-实现过程" class="headerlink" title="SAD 实现过程"></a>SAD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 INIT8(sad,) 展开，可以得到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pixf-&gt;sad[PIXEL_16x16] = x264_pixel_sad_16x16;</span><br><span class="line">pixf-&gt;sad[PIXEL_16x8]  = x264_pixel_sad_16x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x16]  = x264_pixel_sad_8x16;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x8]   = x264_pixel_sad_8x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x4]   = x264_pixel_sad_8x4;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x8]   = x264_pixel_sad_4x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x4]   = x264_pixel_sad_4x4;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x16]  = x264_pixel_sad_4x16;</span><br></pre></td></tr></table></figure><p>我们选取其中最简单的 <code>x264_pixel_sad_4x4</code> 继续展开，它是通过一个宏来定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SAD_C(name, lx, ly) \</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">name</span><span class="params">( pixel *pix1, <span class="keyword">intptr_t</span> i_stride_pix1,  \</span></span></span><br><span class="line">                 pixel *pix2, intptr_t i_stride_pix2 ) \</span><br><span class="line">&#123;                                                   \</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;                                  \</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ly; y++)                   \</span><br><span class="line">    &#123;                                               \</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; lx; x++)               \</span><br><span class="line">        &#123;                                           \</span><br><span class="line">            i_sum += <span class="built_in">abs</span>(pix1[x] - pix2[x] );      \</span><br><span class="line">        &#125;                                           \</span><br><span class="line">        pix1 += i_stride_pix1;                      \</span><br><span class="line">        pix2 += i_stride_pix2;                      \</span><br><span class="line">    &#125;                                               \</span><br><span class="line">    <span class="keyword">return</span> i_sum;                                   \</span><br><span class="line">&#125;</span><br><span class="line">PIXEL_SAD_C(x264_pixel_sad_4x4, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 展开宏定义如下 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">x264_pixel_sad_4x4</span><span class="params">(<span class="keyword">uint8_t</span> *pix1, <span class="keyword">intptr_t</span> i_stride_pix1, <span class="keyword">uint8_t</span> *pix2, <span class="keyword">intptr_t</span> i_stride_pix2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">            i_sum += <span class="built_in">abs</span>(pix1[x] - pix2[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        pix1 += i_stride_pix1;</span><br><span class="line">        pix2 += i_stride_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SSD-实现过程"><a href="#SSD-实现过程" class="headerlink" title="SSD 实现过程"></a>SSD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 <code>INIT8(ssd,)</code> 展开，可以得到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pixf-&gt;ssd[PIXEL_16x16] = x264_pixel_ssd_16x16;</span><br><span class="line">pixf-&gt;ssd[PIXEL_16x8]  = x264_pixel_ssd_16x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x16]  = x264_pixel_ssd_8x16;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x8]   = x264_pixel_ssd_8x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x4]   = x264_pixel_ssd_8x4;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x8]   = x264_pixel_ssd_4x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x4]   = x264_pixel_ssd_4x4;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x16]  = x264_pixel_ssd_4x16;</span><br></pre></td></tr></table></figure><p>我们选取其中最简单的 <code>x264_pixel_ssd_4x4</code> 继续展开，它也是通过一个宏来定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SSD_C(name, lx, ly) \</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">x264_pixel_ssd_4x4</span><span class="params">( pixel *pix1, <span class="keyword">intptr_t</span> i_stride_pix1,  \</span></span></span><br><span class="line">                 pixel *pix2, intptr_t i_stride_pix2 ) \</span><br><span class="line">&#123;                                                   \</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;                                  \</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ly; y++)                   \</span><br><span class="line">    &#123;                                               \</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; lx; x++)               \</span><br><span class="line">        &#123;                                           \</span><br><span class="line">            <span class="keyword">int</span> d = pix1[x] - pix2[x];              \</span><br><span class="line">            i_sum += d*d;                           \</span><br><span class="line">        &#125;                                           \</span><br><span class="line">        pix1 += i_stride_pix1;                      \</span><br><span class="line">        pix2 += i_stride_pix2;                      \</span><br><span class="line">    &#125;                                               \</span><br><span class="line">    <span class="keyword">return</span> i_sum;                                   \</span><br><span class="line">&#125;</span><br><span class="line">PIXEL_SSD_C(x264_pixel_ssd_4x4, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 展开宏定义如下 */</span></span><br><span class="line"><span class="function">tatic <span class="keyword">int</span> <span class="title">name</span><span class="params">(<span class="keyword">uint8_t</span> *pix1, <span class="keyword">intptr_t</span> i_stride_pix1, <span class="keyword">uint8_t</span> *pix2, <span class="keyword">intptr_t</span> i_stride_pix2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = pix1[x] - pix2[x];</span><br><span class="line">            i_sum += d*d;</span><br><span class="line">        &#125;</span><br><span class="line">        pix1 += i_stride_pix1;</span><br><span class="line">        pix2 += i_stride_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SATD-实现过程"><a href="#SATD-实现过程" class="headerlink" title="SATD 实现过程"></a>SATD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 <code>INIT8(satd,)</code> 展开，可以得到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pixf-&gt;satd[PIXEL_16x16] = x264_pixel_satd_16x16;</span><br><span class="line">pixf-&gt;satd[PIXEL_16x8]  = x264_pixel_satd_16x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x16]  = x264_pixel_satd_8x16;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x8]   = x264_pixel_satd_8x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x4]   = x264_pixel_satd_8x4;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x8]   = x264_pixel_satd_4x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x4]   = x264_pixel_satd_4x4;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x16]  = x264_pixel_satd_4x16;</span><br></pre></td></tr></table></figure><p>同样，选取最简单的 <code>x264_pixel_satd_4x4</code> 继续展开，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span>  pixel;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">sum_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">sum2_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_SUM (8 * sizeof(sum_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HADAMARD4(d0, d1, d2, d3, s0, s1, s2, s3) &#123;\</span></span><br><span class="line">    <span class="keyword">sum2_t</span> t0 = s0 + s1;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t1 = s0 - s1;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t2 = s2 + s3;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t3 = s2 - s3;\</span><br><span class="line">    d0 = t0 + t2;\</span><br><span class="line">    d2 = t0 - t2;\</span><br><span class="line">    d1 = t1 + t3;\</span><br><span class="line">    d3 = t1 - t3;\</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> NOINLINE <span class="keyword">int</span> <span class="title">x264_pixel_satd_4x4</span><span class="params">(pixel *pix1, <span class="keyword">intptr_t</span> i_pix1, pixel *pix2, <span class="keyword">intptr_t</span> i_pix2 )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sum2_t</span> tmp[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">sum2_t</span> a0, a1, a2, a3, b0, b1;</span><br><span class="line">    <span class="keyword">sum2_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++, pix1 += i_pix1, pix2 += i_pix2 ) &#123;</span><br><span class="line">        a0 = pix1[<span class="number">0</span>] - pix2[<span class="number">0</span>];</span><br><span class="line">        a1 = pix1[<span class="number">1</span>] - pix2[<span class="number">1</span>];</span><br><span class="line">        b0 = (a0+a1) + ((a0-a1)&lt;&lt;BITS_PER_SUM);</span><br><span class="line">        a2 = pix1[<span class="number">2</span>] - pix2[<span class="number">2</span>];</span><br><span class="line">        a3 = pix1[<span class="number">3</span>] - pix2[<span class="number">3</span>];</span><br><span class="line">        b1 = (a2+a3) + ((a2-a3)&lt;&lt;BITS_PER_SUM);</span><br><span class="line">        tmp[i][<span class="number">0</span>] = b0 + b1;</span><br><span class="line">        tmp[i][<span class="number">1</span>] = b0 - b1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ ) &#123;</span><br><span class="line">        HADAMARD4( a0, a1, a2, a3, tmp[<span class="number">0</span>][i], tmp[<span class="number">1</span>][i], tmp[<span class="number">2</span>][i], tmp[<span class="number">3</span>][i] );</span><br><span class="line">        a0 = abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);</span><br><span class="line">        sum += ((<span class="keyword">sum_t</span>)a0) + (a0&gt;&gt;BITS_PER_SUM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li><li>[2] <a href="http://lazybing.github.io/blog/2017/07/08/x264-pixel-init-function/">X264 源码解析之 x264_pixel_init 函数 - 懒人李冰</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;x264&lt;/code&gt; 中 &lt;code&gt;x264_pixel_init&lt;/code&gt; 函数中初始化了与代价计算有关的函数，本文分析部分代价计算函数的实现，包括 &lt;code&gt;SAD&lt;/code&gt;、&lt;code&gt;SATD&lt;/code&gt;、&lt;code&gt;SSD&lt;/code&gt;、等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SAD (Sum of Absolute Difference) = SAE(Sum of Absolute Error) 绝对误差和&lt;/li&gt;
&lt;li&gt;SATD（Sum of Absolute Transformed Difference）即 hadamard 变换后再绝对值求和&lt;/li&gt;
&lt;li&gt;SSD（Sum of Squared Difference）= SSE（Sum of Squared Error) 差值的平方和&lt;/li&gt;
&lt;li&gt;MAD（Mean Absolute Difference）= MAE（Mean Absolute Error) 平均绝对差值&lt;/li&gt;
&lt;li&gt;MSD（Mean Squared Difference）= MSE（Mean Squared Error）平均平方误差&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 编码 API (2)</title>
    <link href="http://github.hezhaojiang.io/post/2021/fe510fb6/"/>
    <id>http://github.hezhaojiang.io/post/2021/fe510fb6/</id>
    <published>2021-01-19T06:09:58.000Z</published>
    <updated>2021-01-19T16:59:57.081Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇介绍以下接口中的主要函数：</p><ul><li><code>x264_encoder_headers()</code>：输出 SPS/PPS/SEI。</li><li><code>x264_encoder_encode()</code>：编码一帧数据。</li><li><code>x264_encoder_close()</code>：关闭 H.264 编码器。</li></ul><a id="more"></a><h2 id="x264-encoder-headers"><a href="#x264-encoder-headers" class="headerlink" title="x264_encoder_headers"></a>x264_encoder_headers</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* x264_encoder_headers:</span></span><br><span class="line"><span class="comment"> *      return the SPS and PPS that will be used for the whole stream.</span></span><br><span class="line"><span class="comment"> *      *pi_nal is the number of NAL units outputted in pp_nal.</span></span><br><span class="line"><span class="comment"> *      returns the number of bytes in the returned NALs.</span></span><br><span class="line"><span class="comment"> *      returns negative on error.</span></span><br><span class="line"><span class="comment"> *      the payloads of all output NALs are guaranteed to be sequential in memory. */</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">int</span> <span class="title">x264_encoder_headers</span><span class="params">(<span class="keyword">x264_t</span> *param, <span class="keyword">x264_nal_t</span> **pp_nal, <span class="keyword">int</span> *pi_nal)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="x264-encoder-encode"><a href="#x264-encoder-encode" class="headerlink" title="x264_encoder_encode"></a>x264_encoder_encode</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* x264_encoder_encode:</span></span><br><span class="line"><span class="comment"> *      encode one picture.</span></span><br><span class="line"><span class="comment"> *      *pi_nal is the number of NAL units outputted in pp_nal.</span></span><br><span class="line"><span class="comment"> *      returns the number of bytes in the returned NALs.</span></span><br><span class="line"><span class="comment"> *      returns negative on error and zero if no NAL units returned.</span></span><br><span class="line"><span class="comment"> *      the payloads of all output NALs are guaranteed to be sequential in memory. */</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">int</span> <span class="title">x264_encoder_encode</span><span class="params">(<span class="keyword">x264_t</span> *param, <span class="keyword">x264_nal_t</span> **pp_nal, <span class="keyword">int</span> *pi_nal, <span class="keyword">x264_picture_t</span> *pic_in, <span class="keyword">x264_picture_t</span> *pic_out)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="x264-encoder-close"><a href="#x264-encoder-close" class="headerlink" title="x264_encoder_close"></a>x264_encoder_close</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* x264_encoder_close:</span></span><br><span class="line"><span class="comment"> *      close an encoder handler */</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">void</span> <span class="title">x264_encoder_close</span><span class="params">(<span class="keyword">x264_t</span> *param)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li><li>[2] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45719905">x264 源代码简单分析：编码器主干部分 - 2 雷霄骅的专栏 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍以下接口中的主要函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x264_encoder_headers()&lt;/code&gt;：输出 SPS/PPS/SEI。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x264_encoder_encode()&lt;/code&gt;：编码一帧数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x264_encoder_close()&lt;/code&gt;：关闭 H.264 编码器。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 帧内预测</title>
    <link href="http://github.hezhaojiang.io/post/2021/b66cfff2/"/>
    <id>http://github.hezhaojiang.io/post/2021/b66cfff2/</id>
    <published>2021-01-19T06:06:39.000Z</published>
    <updated>2021-01-21T16:17:52.651Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文分析 <code>x264</code> 库中的帧内预测的 <code>C</code> 语言函数。</p><a id="more"></a><h2 id="16x16-预测"><a href="#16x16-预测" class="headerlink" title="16x16 预测"></a>16x16 预测</h2><p><code>x264</code> 代码通过 <code>x264_predict_16x16_init()</code> 函数初始化 <code>Intra16x16</code> 帧内预测汇编函数，初始化的预测模式如下：</p><div class="table-container"><table><thead><tr><th><code>intra16x16Predmode</code></th><th><code>Name of Intra16x16PredMode</code></th><th><code>Note</code></th><th><code>Function</code></th></tr></thead><tbody><tr><td><code>0</code></td><td><code>Intra_16x16_Vertical</code></td><td>由上边像素推出相应像素值</td><td><code>x264_predict_16x16_v_c</code></td></tr><tr><td><code>1</code></td><td><code>Intra_16x16_Horicontal</code></td><td>由左边像素推出相应像素值</td><td><code>x264_predict_16x16_h_c</code></td></tr><tr><td><code>2</code></td><td><code>Intra_16x16_DC</code></td><td>由上边和左边像素平均值推出相应像素值</td><td><code>x264_predict_16x16_dc_c</code></td></tr><tr><td><code>3</code></td><td><code>Intra_16x16_Plane</code></td><td>利用线性 plan 函数及左、上像素推出相应像素值，适用于亮度变化平缓区域</td><td><code>x264_predict_16x16_p_c</code></td></tr></tbody></table></div><h3 id="Intra-16x16-Vertical"><a href="#Intra-16x16-Vertical" class="headerlink" title="Intra_16x16_Vertical"></a>Intra_16x16_Vertical</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121220616.png" alt="Intra_16x16_Vertical"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* common/predict.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_v_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pixel4 实际上是 uint32_t（占用 32bit），存储 4 个像素的值（每个像素占用 8bit）</span></span><br><span class="line">    pixel4 v0 = MPIXEL_X4(&amp;src[ <span class="number">0</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v1 = MPIXEL_X4(&amp;src[ <span class="number">4</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v2 = MPIXEL_X4(&amp;src[ <span class="number">8</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v3 = MPIXEL_X4(&amp;src[<span class="number">12</span> - FDEC_STRIDE]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Vertical 预测方式</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     * --+-----------</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t v0 = ((x264_union32_t*)(&amp;src[ 0-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v1 = ((x264_union32_t*)(&amp;src[ 4-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v2 = ((x264_union32_t*)(&amp;src[ 8-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v3 = ((x264_union32_t*)(&amp;src[12-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * x264_union32_t 的定义如下：</span></span><br><span class="line"><span class="comment">     * typedef union &#123;uint64_t i; uint32_t d[2]; uint16_t w[4]; uint8_t b[8]; &#125; MAY_ALIAS x264_union64_t;</span></span><br><span class="line"><span class="comment">     * 即将一行 16 字节数据分成 4 次，每次取出 4 个像素（一共 16 个像素），分别赋值给 v0，v1，v2，v3</span></span><br><span class="line"><span class="comment">     * 取出的值源自于 16x16 块上面的一行像素</span></span><br><span class="line"><span class="comment">     *    0|          4          8          12         16</span></span><br><span class="line"><span class="comment">     *    ||    v0    |    v1    |    v2    |    v3    |</span></span><br><span class="line"><span class="comment">     * ---++==========+==========+==========+==========+</span></span><br><span class="line"><span class="comment">     *    ||</span></span><br><span class="line"><span class="comment">     *    ||</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">0</span>) = v0;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">4</span>) = v1;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">8</span>) = v2;</span><br><span class="line">        MPIXEL_X4(src + <span class="number">12</span>) = v3;</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  0))-&gt;i = v0;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  4))-&gt;i = v1;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  8))-&gt;i = v2;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src + 12))-&gt;i = v3;</span></span><br><span class="line"><span class="comment">     * 即分成 4 次，每次赋值 4 个像素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-16x16-Horicontal"><a href="#Intra-16x16-Horicontal" class="headerlink" title="Intra_16x16_Horicontal"></a>Intra_16x16_Horicontal</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121220849.png" alt="Intra_16x16_Horicontal"></p><p><code>x264</code> 中关于模式 <code>Intra_16x16_Horicontal</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SPLAT_X4(x) ((x)*0x01010101U)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_h_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">const</span> pixel4 v = PIXEL_SPLAT_X4( src[<span class="number">-1</span>] );</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">0</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">4</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">8</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+<span class="number">12</span> ) = v;</span><br><span class="line">        <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">         * uint32_t v = src[-1] * 0x01010101U;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  0))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  4))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  8))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src + 12))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-16x16-DC"><a href="#Intra-16x16-DC" class="headerlink" title="Intra_16x16_DC"></a>Intra_16x16_DC</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121222206.jpg" alt="Intra_16x16_DC"></p><p><code>x264</code> 中关于模式 <code>Intra_16x16_DC</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_16x16_DC(v)\</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ )\</span><br><span class="line">    &#123;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">0</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">4</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">8</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+<span class="number">12</span> ) = v;\</span><br><span class="line">        src += FDEC_STRIDE;\</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_dc_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        dc += src[<span class="number">-1</span> + i * FDEC_STRIDE];</span><br><span class="line">        dc += src[i - FDEC_STRIDE];</span><br><span class="line">    &#125;</span><br><span class="line">    pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + <span class="number">16</span> ) &gt;&gt; <span class="number">5</span> );</span><br><span class="line">    PREDICT_16x16_DC( dcsplat );</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t dcsplat = ((dc + 16) &gt;&gt; 5) * 0x01010101U;</span></span><br><span class="line"><span class="comment">     * for ( int i = 0; i &lt; 16; i++ ) &#123;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  0))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  4))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  8))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src + 12))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     src += FDEC_STRIDE;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-16x16-Plane"><a href="#Intra-16x16-Plane" class="headerlink" title="Intra_16x16_Plane"></a>Intra_16x16_Plane</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121222712.png" alt="Intra_16x16_Plane"></p><p><code>x264</code> 中关于模式 <code>Intra_16x16_Plane</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_MAX 255</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_p_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H = <span class="number">0</span>, V = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate H and V */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">        H += (i + <span class="number">1</span>) * ( src[ <span class="number">8</span> + i - FDEC_STRIDE ] - src[<span class="number">6</span> - i - FDEC_STRIDE] );</span><br><span class="line">        V += (i + <span class="number">1</span>) * ( src[<span class="number">-1</span> + (<span class="number">8</span>+i) * FDEC_STRIDE] - src[<span class="number">-1</span> + (<span class="number">6</span>-i) * FDEC_STRIDE] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">16</span> * (src[<span class="number">-1</span> + <span class="number">15</span>*FDEC_STRIDE] + src[<span class="number">15</span> - FDEC_STRIDE] );</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="number">5</span> * H + <span class="number">32</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="number">5</span> * V + <span class="number">32</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i00 = a - b * <span class="number">7</span> - c * <span class="number">7</span> + <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">16</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pix = i00;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">16</span>; x++) &#123;</span><br><span class="line">            src[x] = x264_clip_pixel( pix &gt;&gt; <span class="number">5</span> );</span><br><span class="line">            pix += b;</span><br><span class="line">        &#125;</span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">        i00 += c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4x4-预测"><a href="#4x4-预测" class="headerlink" title="4x4 预测"></a>4x4 预测</h2><p><code>x264</code> 中对 <code>4x4</code> 的预测模式如下：</p><div class="table-container"><table><thead><tr><th><code>Intra4x4PredMode[luma4x4BlkIdx]</code></th><th><code>Name of Intra4x4PredMode[luma4x4BlkIdx]</code></th><th><code>x264 Function</code></th></tr></thead><tbody><tr><td><code>0</code></td><td><code>Intra_4x4_Vertical</code></td><td><code>x264_predict_4x4_v_c()</code></td></tr><tr><td><code>1</code></td><td><code>Intra_4x4_Horizontal</code></td><td><code>x264_predict_4x4_h_c()</code></td></tr><tr><td><code>2</code></td><td><code>Intra_4x4_DC</code></td><td><code>x264_predict_4x4_dc_c()</code></td></tr><tr><td><code>3</code></td><td><code>Intra_4x4_Diagonal_Down_Left</code></td><td><code>predict_4x4_ddl_c()</code></td></tr><tr><td><code>4</code></td><td><code>Intra_4x4_Diagonal_Down_Right</code></td><td><code>predict_4x4_ddr_c()</code></td></tr><tr><td><code>5</code></td><td><code>Intra_4x4_Vertical_Right</code></td><td><code>predict_4x4_vr_c()</code></td></tr><tr><td><code>6</code></td><td><code>Intra_4x4_Horizontal_Down</code></td><td><code>predict_4x4_hd_c()</code></td></tr><tr><td><code>7</code></td><td><code>Intra_4x4_Vertical_Left</code></td><td><code>predict_4x4_vl_c()</code></td></tr><tr><td><code>8</code></td><td><code>Intra_4x4_Horizontal_Up</code></td><td><code>predict_4x4_hu_c()</code></td></tr></tbody></table></div><h3 id="Intra-4x4-Vertical"><a href="#Intra-4x4-Vertical" class="headerlink" title="Intra_4x4_Vertical"></a>Intra_4x4_Vertical</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210120234537.png" alt="Intra_4x4_Vertical"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC(x,y) src[(x)+(y)*FDEC_STRIDE]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC_X4(x,y) MPIXEL_X4( &amp;SRC(x,y) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_DC(v)\</span></span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">0</span>) = SRC_X4(<span class="number">0</span>,<span class="number">1</span>) = SRC_X4(<span class="number">0</span>,<span class="number">2</span>) = SRC_X4(<span class="number">0</span>,<span class="number">3</span>) = v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_v_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_DC(SRC_X4(<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+0*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+1*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+2*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+3*FDEC_STRIDE])-&gt;i = ((x264_union32_t*)(&amp;src[0+(-1)*FDEC_STRIDE])-&gt;i;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Horizontal"><a href="#Intra-4x4-Horizontal" class="headerlink" title="Intra_4x4_Horizontal"></a>Intra_4x4_Horizontal</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210120235209.png" alt="Intra_4x4_Horizontal"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M32(src) (((x264_union32_t*)(src))-&gt;i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPIXEL_X4(src) M32(src)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC(x,y) src[(x)+(y)*FDEC_STRIDE]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC_X4(x,y) MPIXEL_X4( &amp;SRC(x,y) )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SPLAT_X4(x) ((x)*0x01010101U)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_h_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">0</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">0</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">1</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">1</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">2</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">2</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">3</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">3</span>) );</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+0*FDEC_STRIDE])-&gt;i = src[-1+0*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+1*FDEC_STRIDE])-&gt;i = src[-1+1*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+2*FDEC_STRIDE])-&gt;i = src[-1+2*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+3*FDEC_STRIDE])-&gt;i = src[-1+3*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-DC"><a href="#Intra-4x4-DC" class="headerlink" title="Intra_4x4_DC"></a>Intra_4x4_DC</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121000124.png" alt="Intra_4x4_DC"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_DC</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> pixel4;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_DC(v) SRC_X4(0,0) = SRC_X4(0,1) = SRC_X4(0,2) = SRC_X4(0,3) = v;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_dc_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    pixel4 dc = PIXEL_SPLAT_X4((SRC(<span class="number">-1</span>,<span class="number">0</span>) + SRC(<span class="number">-1</span>,<span class="number">1</span>) + SRC(<span class="number">-1</span>,<span class="number">2</span>) + SRC(<span class="number">-1</span>,<span class="number">3</span>) +</span><br><span class="line">                                 SRC(<span class="number">0</span>,<span class="number">-1</span>) + SRC(<span class="number">1</span>,<span class="number">-1</span>) + SRC(<span class="number">2</span>,<span class="number">-1</span>) + SRC(<span class="number">3</span>,<span class="number">-1</span>) + <span class="number">4</span>) &gt;&gt; <span class="number">3</span> );</span><br><span class="line">    PREDICT_4x4_DC(dc);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t dc = (( src[-1+0*FDEC_STRIDE] + src[-1+1*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[-1+2*FDEC_STRIDE] + src[-1+3*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[0+(-1)*FDEC_STRIDE] + src[1+(-1)*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[2+(-1)*FDEC_STRIDE] + src[3+(-1)*FDEC_STRIDE] ) &gt;&gt; 3 ) * 0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(0)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(1)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(2)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(3)*FDEC_STRIDE])-&gt;i = dc;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Diagonal-Down-Left"><a href="#Intra-4x4-Diagonal-Down-Left" class="headerlink" title="Intra_4x4_Diagonal_Down_Left"></a>Intra_4x4_Diagonal_Down_Left</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121001324.png" alt="Intra_4x4_Diagonal_Down_Left"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Diagonal_Down_Left</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_TOP\</span></span><br><span class="line">    <span class="keyword">int</span> t0 = SRC(<span class="number">0</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t1 = SRC(<span class="number">1</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t2 = SRC(<span class="number">2</span>,<span class="number">-1</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> t3 = SRC(<span class="number">3</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_TOP_RIGHT\</span></span><br><span class="line">    <span class="keyword">int</span> t4 = SRC(<span class="number">4</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t5 = SRC(<span class="number">5</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t6 = SRC(<span class="number">6</span>,<span class="number">-1</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> t7 = SRC(<span class="number">7</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F2(a,b,c) (((a)+2*(b)+(c)+2)&gt;&gt;2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_ddl_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    PREDICT_4x4_LOAD_TOP_RIGHT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">1</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F2(t2,t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(t3,t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(t4,t5,t6);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(t5,t6,t7);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t6,t7,t7);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * int t0 = src[0+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t1 = src[1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t2 = src[2+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t3 = src[3+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t4 = src[4+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t5 = src[5+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t6 = src[6+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t7 = src[7+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * src[0+0*FDEC_STRIDE] = (t0+2*t1+t2+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[1+0*FDEC_STRIDE] = src[0+1*FDEC_STRIDE] = (t1+2*t2+t3+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[2+0*FDEC_STRIDE] = src[1+1*FDEC_STRIDE] = src[0+2*FDEC_STRIDE] = (t2+2*t3+t4+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+0*FDEC_STRIDE] = src[2+1*FDEC_STRIDE] = src[1+2*FDEC_STRIDE] = src[0+3*FDEC_STRIDE] = (t3+2*t4+t5+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+1*FDEC_STRIDE] = src[2+2*FDEC_STRIDE] = src[1+3*FDEC_STRIDE] = (t4+2*t5+t6+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+2*FDEC_STRIDE] = src[2+3*FDEC_STRIDE] = (t5+2*t6+t7+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+3*FDEC_STRIDE] = (t6+2*t7+t7+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Diagonal-Down-Right"><a href="#Intra-4x4-Diagonal-Down-Right" class="headerlink" title="Intra_4x4_Diagonal_Down_Right"></a>Intra_4x4_Diagonal_Down_Right</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121003328.png" alt="Intra_4x4_Diagonal_Down_Right"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Diagonal_Down_Right</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_LEFT\</span></span><br><span class="line">    <span class="keyword">int</span> l0 = SRC(<span class="number">-1</span>,<span class="number">0</span>);\</span><br><span class="line">    <span class="keyword">int</span> l1 = SRC(<span class="number">-1</span>,<span class="number">1</span>);\</span><br><span class="line">    <span class="keyword">int</span> l2 = SRC(<span class="number">-1</span>,<span class="number">2</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> l3 = SRC(<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_ddr_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt = SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F2(t3,t2,t1);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t2,t1,t0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F2(t1,t0,lt);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t0,lt,l0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(lt,l0,l1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(l1,l2,l3);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下，后续类似代码不再进行宏定义展开：</span></span><br><span class="line"><span class="comment">     * int lt = src[-1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l0 = src[-1+0*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l1 = src[-1+1*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l2 = src[-1+2*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t0 = src[0+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t1 = src[1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t2 = src[2+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t3 = src[3+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * src[3+0*FDEC_STRIDE] = (t3+2*t2+t1+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[2+0*FDEC_STRIDE] = src[3+1*FDEC_STRIDE] = (t2+2*t1+t0+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[1+0*FDEC_STRIDE] = src[2+1*FDEC_STRIDE] = src[3+2*FDEC_STRIDE] = (t1+2*t0+lt+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+0*FDEC_STRIDE] = src[1+1*FDEC_STRIDE] = src[2+2*FDEC_STRIDE] = src[3+3*FDEC_STRIDE] = (t0+2*lt+l0+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+1*FDEC_STRIDE] = src[1+2*FDEC_STRIDE] = src[2+3*FDEC_STRIDE] = (lt+2*l0+l1+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+2*FDEC_STRIDE] = src[1+3*FDEC_STRIDE] = (l0+2*l1+l2+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+3*FDEC_STRIDE] = (l1+2*l2+l3+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Vertical-Right"><a href="#Intra-4x4-Vertical-Right" class="headerlink" title="Intra_4x4_Vertical_Right"></a>Intra_4x4_Vertical_Right</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004449.png" alt="Intra_4x4_Vertical_Right"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical_Right</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_vr_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt = SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(l2,l1,l0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)= F2(l1,l0,lt);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l0,lt,t0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F1(lt,t0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(lt,t0,t1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(t0,t1);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F1(t1,t2);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F1(t2,t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Horizontal-Down"><a href="#Intra-4x4-Horizontal-Down" class="headerlink" title="Intra_4x4_Horizontal_Down"></a>Intra_4x4_Horizontal_Down</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004515.png" alt="Intra_4x4_Horizontal_Down"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal_Down</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_hd_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt= SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F1(l2,l3);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l1,l2,l3);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F1(l1,l2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(l0,l1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F2(lt,l0,l1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)= F1(lt,l0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t0,lt,l0);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)= F2(t1,t0,lt);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F2(t2,t1,t0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Vertical-Left"><a href="#Intra-4x4-Vertical-Left" class="headerlink" title="Intra_4x4_Vertical_Left"></a>Intra_4x4_Vertical_Left</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004528.png" alt="Intra_4x4_Vertical_Left"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical_Left</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_vl_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    PREDICT_4x4_LOAD_TOP_RIGHT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F1(t0,t1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F1(t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F1(t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(t2,t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(t3,t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)= F1(t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t4,t5,t6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Horizontal-Up"><a href="#Intra-4x4-Horizontal-Up" class="headerlink" title="Intra_4x4_Horizontal_Up"></a>Intra_4x4_Horizontal_Up</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004541.png" alt="Intra_4x4_Horizontal_Up"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal_Up</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_hu_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F1(l0,l1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">1</span>)= F1(l1,l2);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)= F2(l1,l2,l3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F1(l2,l3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F2(l2,l3,l3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)=</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= l3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8x8-预测"><a href="#8x8-预测" class="headerlink" title="8x8 预测"></a>8x8 预测</h2><p>x264 中对 8x8 的预测模式如下：</p><div class="table-container"><table><thead><tr><th><code>intra8x8Predmodei[luma8x8BlkIdx]</code></th><th><code>Name of Intra8x8PredMode[luma8x8BlkIdx]</code></th><th>Function</th></tr></thead><tbody><tr><td>0</td><td><code>Intra_8x8_Vertical</code></td></tr><tr><td>1</td><td><code>Intra_8x8_Horizontal</code></td></tr><tr><td>2</td><td><code>Intra_8x8_DC</code></td></tr><tr><td>3</td><td><code>Intra_8x8_Diagonal_Down_Left</code></td></tr><tr><td>4</td><td><code>Intra_8x8_Diagonal_Down_Right</code></td></tr><tr><td>5</td><td><code>Intra_8x8_Vertical_Right</code></td></tr><tr><td>6</td><td><code>Intra_8x8_Horizontal_Down</code></td></tr><tr><td>7</td><td><code>Intra_8x8_Vertical_Left</code></td></tr><tr><td>8</td><td><code>Intra_8x8_Horizontal_Up</code></td></tr></tbody></table></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li><li>[2] <a href="http://lazybing.github.io/blog/2017/06/30/x264-intra-prediction/#intra4x4vertical-">X264 源码解析之帧内预测 - 懒人李冰</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文分析 &lt;code&gt;x264&lt;/code&gt; 库中的帧内预测的 &lt;code&gt;C&lt;/code&gt; 语言函数。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - ffmpeg 之 IO 架构分析</title>
    <link href="http://github.hezhaojiang.io/post/2021/ce615ee4/"/>
    <id>http://github.hezhaojiang.io/post/2021/ce615ee4/</id>
    <published>2021-01-13T05:11:40.000Z</published>
    <updated>2021-01-17T13:34:28.314Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>协议 (文件) 操作的顶层结构是 <code>AVIOContext</code>，该对象实现了带缓冲的读写操作</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210115000338.png" alt="协议操作对象结构"></p><a id="more"></a><p><code>ffmpeg</code> 的输入对象 <code>AVFormatContext</code> 的 <code>pb</code> 字段指向一个 <code>AVIOContext</code></p><p><code>AVIOContext</code> 的 <code>opaque</code> 实际指向一个 <code>URLContext</code> 对象，这个对象封装了协议对象及协议操作对象</p><pre><code>- `prot` 指向具体的协议操作对象 `URLProtocol`- `priv_data` 指向具体的协议对象</code></pre><p><code>URLProtocol</code> 为协议操作对象，针对每种协议，会有一个这样的对象，每个协议操作对象和一个协议对象关联</p><pre><code>- 比如，文件操作对象为 `ff_file_protocol` 关联的结构体是 `FileContext`</code></pre><h2 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ avformat_open_input()</span><br><span class="line">+---+ init_input()                              <span class="comment">/* 打开输入的视频数据并且探测视频的格式 */</span></span><br><span class="line">    +---- av_probe_input_buffer2()</span><br><span class="line">        +---- avio_read()</span><br><span class="line">        +---- av_probe_input_format2()</span><br><span class="line">            +---- av_probe_input_format3()</span><br><span class="line">    +---+ avio_open2()</span><br><span class="line">        +---+ ffurl_open_whitelist()</span><br><span class="line">            +---+ ffurl_alloc()</span><br><span class="line">                +---- url_find_protocol()</span><br><span class="line">                +---- url_alloc_for_protocol()</span><br><span class="line">            +---+ ffurl_connect()</span><br><span class="line">                +---- prot-&gt;url_open2()</span><br><span class="line">                +---- prot-&gt;url_open()</span><br><span class="line">        +---+ ffio_fdopen()</span><br><span class="line">            +---- avio_alloc_context()</span><br></pre></td></tr></table></figure><h2 id="init-input"><a href="#init-input" class="headerlink" title="init_input()"></a>init_input()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Open input file and probe the format if necessary. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                      AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVProbeData pd = &#123;filename, <span class="literal">NULL</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> score = AVPROBE_SCORE_RETRY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb) &#123;</span><br><span class="line">        s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;iformat)</span><br><span class="line">            <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                         s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE)</span><br><span class="line">            av_log(s, AV_LOG_WARNING, <span class="string">&quot;Custom AVIOContext makes no sense and&quot;</span></span><br><span class="line">                                      <span class="string">&quot;will be ignored with AVFMT_NOFILE format.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) ||</span><br><span class="line">        (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = av_probe_input_format2(&amp;pd, <span class="number">0</span>, &amp;score))))</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = s-&gt;io_open(s, &amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                 s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在短短的几行代码中包含了好几个 <code>return</code>，因此逻辑还是有点复杂的，我们可以梳理一下：</p><p>在函数的开头的 <code>score</code> 变量是一个判决 <code>AVInputFormat</code> 的分数的门限值，如果最后得到的 <code>AVInputFormat</code> 的分数低于该门限值，就认为没有找到合适的 <code>AVInputFormat</code>。<code>ffmpeg</code> 内部判断封装格式的原理实际上是对每种 <code>AVInputFormat</code> 给出一个分数，满分是 <code>100</code> 分，越有可能正确的 <code>AVInputFormat</code> 给出的分数就越高。最后选择分数最高的 <code>AVInputFormat</code> 作为推测结果。<code>score</code> 的值是一个宏定义 <code>AVPROBE_SCORE_RETRY</code>，我们可以看一下它的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_MAX       100 <span class="comment">///&lt; maximum score</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)</span></span><br></pre></td></tr></table></figure><p>由此我们可以得出 <code>score</code> 取值是 <code>25</code>，即如果推测后得到的最佳 <code>AVInputFormat</code> 的分值低于 <code>25</code>，就认为没有找到合适的  <code>AVInputFormat</code></p><p>整个函数的逻辑大体如下：</p><ol><li>当使用了自定义的 <code>AVIOContext</code> 的时候（<code>AVFormatContext</code> 中的 <code>AVIOContext</code> 不为空，即 <code>s-&gt;pb!=NULL</code>），如果指定了 <code>AVInputFormat</code> 就直接返回，如果没有指定就调用 <code>av_probe_input_buffer2()</code> 推测 <code>AVInputFormat</code>。这一情况出现的不算很多，但是当我们从内存中读取数据的时候（需要初始化自定义的 <code>AVIOContext</code>），就会执行这一步骤</li><li>在更一般的情况下，如果已经指定了 <code>AVInputFormat</code>，就直接返回；如果没有指定 <code>AVInputFormat</code>，就调用 <code>av_probe_input_format(NULL,…)</code> 根据文件路径判断文件格式。这里特意把 <code>av_probe_input_format()</code> 的第 1 个参数写成 <code>NULL</code>，是为了强调这个时候实际上并没有给函数提供输入数据，此时仅仅通过文件路径推测 <code>AVInputFormat</code></li><li>如果发现通过文件路径判断不出来文件格式，那么就需要打开文件探测文件格式了，这个时候会首先调用 <code>avio_open2()</code> 打开文件，然后调用 <code>av_probe_input_buffer2()</code> 推测 <code>AVInputFormat</code></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/finewind/article/details/39433055">2——FFMPEG 之协议 (文件) 操作 ——AVIOContext, URLContext, URLProtocol_finewind 的专栏 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;协议 (文件) 操作的顶层结构是 &lt;code&gt;AVIOContext&lt;/code&gt;，该对象实现了带缓冲的读写操作&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210115000338.png&quot; alt=&quot;协议操作对象结构&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 刷题总结 - 拓扑排序</title>
    <link href="http://github.hezhaojiang.io/post/2021/fd828132/"/>
    <id>http://github.hezhaojiang.io/post/2021/fd828132/</id>
    <published>2021-01-12T06:40:43.000Z</published>
    <updated>2021-01-13T14:12:07.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「先穿袜子，再穿鞋子」 —- 这就是一种拓扑排序</p><a id="more"></a><p>首先声明：拓扑排序并不是通常意义上的【排序】算法</p><h2 id="拓扑排序简介"><a href="#拓扑排序简介" class="headerlink" title="拓扑排序简介"></a>拓扑排序简介</h2><p>给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：</p><pre><code>对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。</code></pre><p>那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p><ol><li><p>如果图 G 中存在环，那么图 G 不存在拓扑排序（即只有「有向无环图」存在拓扑排序）</p></li><li><p>如果图 G 是有向无环图，那么它的拓扑排序可能不止一种</p></li></ol><p>在很多应用中， 有向无回路图用于说明事件发生的先后次序， 下图给出了一个实例，说明 Bumstead 教授早晨穿衣的过程。他必须先穿好某些衣服， 才能再穿其他衣服（如先穿袜子后才能穿鞋） ， 其他的一些衣服前可以按任意次序穿戴（如袜子和裤子）</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210112230616.png" alt="Bumstead 教授早晨穿衣的过程"></p><pre><code>图 a 为 Bumstead 教授对他所穿的衣服进行了拓扑排序每一条有向边 (u,v) 都意味若必须先穿衣服 u 再穿衣服 v深度优先搜索中的发现和完成时间都在每个顶点的旁边示出图 b 为 经过拓扑排序后的同一图形图中的各个顶点按照完成时间的递降顺序从左向右排列，注意所有的有向边都是从左指向右的</code></pre><h2 id="拓扑排序的实现"><a href="#拓扑排序的实现" class="headerlink" title="拓扑排序的实现"></a>拓扑排序的实现</h2><p>为了说明如何得到一个有向无环图的拓扑排序，我们首先需要了解有向图节点的入度（indegree）和出度（outdegree）的概念：</p><ul><li>入度：设有向图中有一节点 $v$，其入度即为当前所有从其他节点出发，终点为 $v$ 的的边的数目。也就是所有指向 $v$ 的有向边的数目。</li><li>出度：设有向图中有一节点 $v$，其出度即为当前所有起点为 $v$，指向其他节点的边的数目。也就是所有由 $v$ 发出的边的数目。</li></ul><p>在了解了入度和出度的概念之后，再根据拓扑排序的定义，我们自然就能够得出结论：要想完成拓扑排序，我们每次都应当从入度为 0 的节点开始遍历。因为只有入度为 0 的节点才能够成为拓扑排序的起点。否则根据拓扑排序的定义，只要一个节点 $v$ 的入度不为 0，则至少有一条边起始于其他节点而指向 $v$，那么这条边的起点在拓扑排序的顺序中应当位于 $v$ 之前，则 $v$ 不能成为当前遍历的起点。</p><p>由此我们可以进一步得出一个改进的深度优先遍历或广度优先遍历算法来完成拓扑排序。</p><h3 id="广度优先算法实现拓扑排序"><a href="#广度优先算法实现拓扑排序" class="headerlink" title="广度优先算法实现拓扑排序"></a>广度优先算法实现拓扑排序</h3><p>广度优先算法实现拓扑排序需要多保存每一个节点对应的入度（普通遍历算法只需要保存节点之间的关系），并在遍历的每一层选取入度为 0 的节点开始遍历（普通遍历算法则可以从该吃呢个任意一个节点开始遍历）。这个算法描述如下：</p><ol><li>保存每一个节点与其他节点之间的关系，可以使用邻接表或者哈希表</li><li>计算并保存每一个节点的入度，可以使用数组</li><li>遍历选取入度为 0 的节点，并将该节点加入队列</li><li>取队列中的节点，加入排序结果列表，并将该节点的子节点的入度减 1</li><li>重复步骤 5，直到队列为空</li><li>如果排序结果列表和节点总数相同，代表遍历完了所有节点，否则说明有节点没有遍历到<ul><li>如果遍历完所有的节点，则排序结果列表即为当前图的拓扑排序</li><li>如果无法遍历完所有的节点，则意味着当前图不是有向无环图，不存在拓扑排序</li></ul></li></ol><h2 id="拓扑排序题目解析"><a href="#拓扑排序题目解析" class="headerlink" title="拓扑排序题目解析"></a>拓扑排序题目解析</h2><h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h3><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li>「力扣」第 207 题：课程表（中等）</li><li>「力扣」第 210 题：课程表 II（中等）</li><li>「力扣」第 301 题：最小高度树（中等）</li><li>「力扣」第 802 题：找到最终的安全状态（中等）</li><li>「力扣」第 1203 题：项目管理（困难）</li><li>「力扣」第 630 题：课程表 III（困难）</li><li>「力扣」第 329 题：矩阵中的最长递增路径（困难）</li><li>「力扣」第 1245 题：树的直径（中等）</li><li>「力扣」第 444 题：序列重建（中等）</li><li>「力扣」第 1136 题：平行课程（困难）</li><li>「力扣」第 269 题：火星词典（困难）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/">课程表 - 课程表 - 力扣（LeetCode）</a></li><li>[2] <a href="https://www.jianshu.com/p/3347f54a3187">深入理解拓扑排序（Topological sort) - 简书</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;「先穿袜子，再穿鞋子」 —- 这就是一种拓扑排序&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.hezhaojiang.io/categories/Leetcode/"/>
    
    
    <category term="图论" scheme="http://github.hezhaojiang.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - ffmpeg 关键结构体</title>
    <link href="http://github.hezhaojiang.io/post/2021/e03178b1/"/>
    <id>http://github.hezhaojiang.io/post/2021/e03178b1/</id>
    <published>2021-01-08T08:53:09.000Z</published>
    <updated>2021-01-13T13:48:44.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><code>AVFormatContext</code> : 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息</li><li><code>AVInputFormat</code> : 每种封装格式（例如 FLV, MKV, MP4, AVI）对应一个该结构体</li><li><code>AVStream</code> : 视频文件中每个视频（音频）流对应一个该结构体</li><li><code>AVCodecContext</code> : 编码器上下文结构体，保存了视频（音频）编解码相关信息</li><li><code>AVCodec</code> : 每种视频（音频）编解码器 (例如 H.264 解码器) 对应一个该结构体</li><li><code>AVPacket</code> : 存储一帧压缩编码数据</li><li><code>AVFrame</code> : 存储一帧解码后像素（采样）数据</li></ul><a id="more"></a><h2 id="协议封装-amp-解协议"><a href="#协议封装-amp-解协议" class="headerlink" title="协议封装 &amp; 解协议"></a>协议封装 &amp; 解协议</h2><h3 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h3><p><code>AVIOContext</code> 是 <code>ffmpeg</code> 管理输入输出数据的结构体</p><h4 id="AVIOContext-相关函数"><a href="#AVIOContext-相关函数" class="headerlink" title="AVIOContext 相关函数"></a>AVIOContext 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate and initialize an AVIOContext for buffered I/O. It must be later freed with avio_context_free().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param buffer Memory block for input/output operations via AVIOContext.</span></span><br><span class="line"><span class="comment"> *        The buffer must be allocated with av_malloc() and friends.</span></span><br><span class="line"><span class="comment"> *        It may be freed and replaced with a new buffer by libavformat.</span></span><br><span class="line"><span class="comment"> *        AVIOContext.buffer holds the buffer currently in use, which must be later freed with av_free().</span></span><br><span class="line"><span class="comment"> * @param buffer_size The buffer size is very important for performance.</span></span><br><span class="line"><span class="comment"> *        For protocols with fixed blocksize it should be set to this blocksize.</span></span><br><span class="line"><span class="comment"> *        For others a typical size is a cache page, e.g. 4kb.</span></span><br><span class="line"><span class="comment"> * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.</span></span><br><span class="line"><span class="comment"> * @param opaque An opaque pointer to user-specific data.</span></span><br><span class="line"><span class="comment"> * @param read_packet  A function for refilling the buffer, may be NULL.</span></span><br><span class="line"><span class="comment"> *        For stream protocols, must never return 0 but rather a proper AVERROR code.</span></span><br><span class="line"><span class="comment"> * @param write_packet A function for writing the buffer contents, may be NULL.</span></span><br><span class="line"><span class="comment"> *        The function may not change the input buffers content.</span></span><br><span class="line"><span class="comment"> * @param seek A function for seeking to specified byte position, may be NULL.</span></span><br><span class="line"><span class="comment"> * @return Allocated AVIOContext or NULL on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVIOContext *<span class="title">avio_alloc_context</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">buffer</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> buffer_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> write_flag,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *opaque,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*read_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*write_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int64_t</span> (*<span class="built_in">seek</span>)(<span class="keyword">void</span> *opaque, <span class="keyword">int64_t</span> offset, <span class="keyword">int</span> whence))</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVIOContext-成员变量"><a href="#AVIOContext-成员变量" class="headerlink" title="AVIOContext 成员变量"></a>AVIOContext 成员变量</h4><ul><li><code>unsigned char *buffer;</code> : 缓存开始位置</li><li><code>int buffer_size;</code> : 缓存大小（默认 <code>32768</code>）</li><li><code>unsigned char *buf_ptr;</code> : 当前指针读取到的位置</li><li><code>unsigned char *buf_end;</code> : 缓存结束的位置</li><li><code>void *opaque;</code> : <code>URLContext</code> 结构体</li><li><code>int64_t pos;</code> : 文件读取指针位置</li><li><code>int eof_reached;</code> : 在读取失败或读取完成时置位</li><li><code>(*read_packet)</code> : 读取音视频数据的函数</li><li><code>(*write_packet)</code> : 写入音视频数据的函数</li><li><code>(*read_pause)</code> : 暂停或恢复网络流媒体协议的播放</li></ul><h3 id="URLContext-amp-URLProtocol"><a href="#URLContext-amp-URLProtocol" class="headerlink" title="URLContext &amp; URLProtocol"></a>URLContext &amp; URLProtocol</h3><p><code>URLContext</code> &amp; <code>URLProtocol</code> 并不在 <code>ffmpeg</code> 提供的头文件中，而是在源代码中</p><h4 id="URLContext-amp-URLProtocol-定义"><a href="#URLContext-amp-URLProtocol-定义" class="headerlink" title="URLContext &amp; URLProtocol 定义"></a>URLContext &amp; URLProtocol 定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLContext</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;    <span class="comment">/**&lt;information for av_log(). Set by url_open(). */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> *<span class="title">prot</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *priv_data;</span><br><span class="line">    <span class="keyword">char</span> *filename;             <span class="comment">/**&lt; specified URL */</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> max_packet_size;        <span class="comment">/**&lt; if non zero, the stream is packetized with this max packet size */</span></span><br><span class="line">    <span class="keyword">int</span> is_streamed;            <span class="comment">/**&lt;true if streamed (no seek possible), default = false */</span></span><br><span class="line">    <span class="keyword">int</span> is_connected;</span><br><span class="line">    AVIOInterruptCB interrupt_callback;</span><br><span class="line">    <span class="keyword">int64_t</span> rw_timeout;         <span class="comment">/**&lt;maximum time to wait for (network) read/write operation completion, in mcs */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_whitelist;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_blacklist;</span><br><span class="line">    <span class="keyword">int</span> min_packet_size;        <span class="comment">/**&lt; if non zero, the stream is packetized with this min packet size */</span></span><br><span class="line">&#125; URLContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span>     (*url_open)( URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This callback is to be used by protocols which open further nested</span></span><br><span class="line"><span class="comment">     * protocols. options are then to be passed to ffurl_open()/ffurl_connect()</span></span><br><span class="line"><span class="comment">     * for those nested protocols.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>     (*url_open2)(URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags, AVDictionary **options);</span><br><span class="line">    <span class="keyword">int</span>     (*url_accept)(URLContext *s, URLContext **c);</span><br><span class="line">    <span class="keyword">int</span>     (*url_handshake)(URLContext *c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read data from the protocol.</span></span><br><span class="line"><span class="comment">     * If data is immediately available (even less than size), EOF is</span></span><br><span class="line"><span class="comment">     * reached or an error occurs (including EINTR), return immediately.</span></span><br><span class="line"><span class="comment">     * Otherwise:</span></span><br><span class="line"><span class="comment">     * In non-blocking mode, return AVERROR(EAGAIN) immediately.</span></span><br><span class="line"><span class="comment">     * In blocking mode, wait for data/EOF/error with a short timeout (0.1s),</span></span><br><span class="line"><span class="comment">     * and return AVERROR(EAGAIN) on timeout.</span></span><br><span class="line"><span class="comment">     * Checking interrupt_callback, looping on EINTR and EAGAIN and until</span></span><br><span class="line"><span class="comment">     * enough data has been read is left to the calling function; see</span></span><br><span class="line"><span class="comment">     * retry_transfer_wrapper in avio.c.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>     (*url_read) (URLContext *h, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int</span>     (*url_write)(URLContext *h, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_seek) (URLContext *h, <span class="keyword">int64_t</span> pos, <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int</span>     (*url_close)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_read_pause)(URLContext *h, <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_read_seek)(URLContext *h, <span class="keyword">int</span> stream_index,</span><br><span class="line">                             <span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_file_handle)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_multi_file_handle)(URLContext *h, <span class="keyword">int</span> **handles,</span><br><span class="line">                                     <span class="keyword">int</span> *numhandles);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_short_seek)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_shutdown)(URLContext *h, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_data_class;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*url_check)(URLContext *h, <span class="keyword">int</span> mask);</span><br><span class="line">    <span class="keyword">int</span> (*url_open_dir)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_read_dir)(URLContext *h, AVIODirEntry **next);</span><br><span class="line">    <span class="keyword">int</span> (*url_close_dir)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_delete)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_move)(URLContext *h_src, URLContext *h_dst);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *default_whitelist;</span><br><span class="line">&#125; URLProtocol;</span><br></pre></td></tr></table></figure><p>在 <code>URLProtocol</code> 结构体中，除了一些回调函数接口之外，有一个变量 <code>const char *name</code>，该变量存储了协议的名称。每一种输入协议都对应这样一个结构体对象。比如说，文件协议中代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="keyword">const</span> URLProtocol ff_file_protocol = &#123;</span><br><span class="line">    .name                = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .url_open            = file_open,</span><br><span class="line">    .url_read            = file_read,</span><br><span class="line">    .url_write           = file_write,</span><br><span class="line">    .url_seek            = file_seek,</span><br><span class="line">    .url_close           = file_close,</span><br><span class="line">    .url_get_file_handle = file_get_handle,</span><br><span class="line">    .url_check           = file_check,</span><br><span class="line">    .url_delete          = file_delete,</span><br><span class="line">    .url_move            = file_move,</span><br><span class="line">    .priv_data_size      = <span class="keyword">sizeof</span>(FileContext),</span><br><span class="line">    .priv_data_class     = &amp;file_class,</span><br><span class="line">    .url_open_dir        = file_open_dir,</span><br><span class="line">    .url_read_dir        = file_read_dir,</span><br><span class="line">    .url_close_dir       = file_close_dir,</span><br><span class="line">    .default_whitelist   = <span class="string">&quot;file,crypto,data&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="封装-amp-解封装"><a href="#封装-amp-解封装" class="headerlink" title="封装 &amp; 解封装"></a>封装 &amp; 解封装</h2><h3 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h3><h4 id="AVFormatContext-相关函数"><a href="#AVFormatContext-相关函数" class="headerlink" title="AVFormatContext 相关函数"></a>AVFormatContext 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个 AVFormatContext</span></span><br><span class="line"><span class="function">AVFormatContext *<span class="title">avformat_alloc_context</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVFormatContext 及其所有 AVStream</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avformat_free_context</span><span class="params">(AVFormatContext *s)</span></span>;</span><br><span class="line"><span class="comment">// 打开一个输入流并读取报头，该函数不会打开编解码器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, ff_const59 AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br><span class="line"><span class="comment">// 读取媒体文件的数据包以获取流信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVFormatContext-成员变量"><a href="#AVFormatContext-成员变量" class="headerlink" title="AVFormatContext 成员变量"></a>AVFormatContext 成员变量</h4><ul><li><code>struct AVInputFormat *iformat;</code> : 输入音视频的 <code>AVInputFormat</code></li><li><code>struct AVOutputFormat *oformat;</code> : 输出音视频的 <code>AVInputFormat</code></li><li><code>AVIOContext *pb;</code> : 输入 / 输出音视频数据的缓存</li><li><code>int64_t duration;</code> : 输入 / 输出音视频的时长（以微秒为单位）</li><li><code>int64_t bit_rate;</code> : 输入 / 输出音视频的码率</li><li><code>unsigned int nb_streams;</code> ： 输入 / 输出音视频的 <code>AVStream</code> 个数</li><li><code>AVStream **streams;</code> ： 输入 / 输出音视频的每个视频（音频流）</li><li><code>AVDictionary *metadata;</code> ： 元数据</li></ul><h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h3><p>视频文件中每个视频（音频）流对应一个 <code>AVStream</code> 对象</p><ul><li>在解封装时，<code>AVStream</code> 对象由 <code>libavformat</code> 中的函数 <code>xxxx_read_header()</code> 调用 <code>avformat_open_input()</code> 创建</li><li>如果解封装时，未在文件中读到文件头，即标志位 <code>AVFMTCTX_NOHEADER</code> 被置位，由函数 <code>xxxx_read_packet()</code> 调用 <code>avformat_open_input()</code> 创建</li><li>在封装时，<code>AVStream</code> 对象由用户调用函数 <code>avformat_new_stream()</code> 创建</li><li>调用 <code>libavformat</code> 中的函数 <code>avformat_free_context()</code> 销毁对象</li></ul><h4 id="AVStream-相关函数"><a href="#AVStream-相关函数" class="headerlink" title="AVStream 相关函数"></a>AVStream 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a new stream to a media file.</span></span><br><span class="line"><span class="comment"> * @param s media file handle</span></span><br><span class="line"><span class="comment"> * @param c If non-NULL, the AVCodecContext corresponding to the new stream will be initialized to use this codec.</span></span><br><span class="line"><span class="comment"> * This is needed for e.g. codec-specific defaults to be set, so codec should be provided if it is known.</span></span><br><span class="line"><span class="comment"> * @return newly created stream or NULL on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> AVCodec *c)</span></span></span><br></pre></td></tr></table></figure><h4 id="AVStream-成员变量"><a href="#AVStream-成员变量" class="headerlink" title="AVStream 成员变量"></a>AVStream 成员变量</h4><ul><li><code>int index</code> : stream index in AVFormatContext</li><li><code>AVCodecContext *codec;</code> : 指向该视频 / 音频流的 AVCodecContext 它们是一一对应的关系</li><li><code>AVRational time_base;</code> : 该流的时基 通过该值可以把 PTS/DTS 转化为真正的时间</li><li><code>int64_t duration;</code> : 该视频 / 音频流长度</li><li><code>AVRational r_frame_rate;</code> : 该流的帧率</li><li><code>AVDictionary *metadata;</code> : 元数据信息</li><li><code>AVRational avg_frame_rate;</code> : 平均帧率（注 : 对视频来说，这个挺重要的）</li><li><code>AVPacket attached_pic;</code> : 附带的图片。比如说一些 MP3，AAC 音频文件附带的专辑封面</li><li><code>AVCodecParameters *codecpar;</code> : 与此流相关的编解码器参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVRational 可以用来表示无理数：</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator 分子</span></span><br><span class="line">    <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator 分母</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><h3 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h3><p>该结构被称为 <code>demuxer</code>，是音视频文件的一个解封装器</p><blockquote><p><code>AVOutputFormat</code> 和 <code>AVInputFormat</code> 结构类似，是音视频文件的封装器</p></blockquote><h4 id="AVInputFormat-相关函数"><a href="#AVInputFormat-相关函数" class="headerlink" title="AVInputFormat 相关函数"></a>AVInputFormat 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If f is NULL, returns the first registered input format,</span></span><br><span class="line"><span class="comment"> * if f is non-NULL, returns the next registered input format after f or NULL if f is the last one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">attribute_deprecated AVInputFormat  *<span class="title">av_iformat_next</span><span class="params">(<span class="keyword">const</span> AVInputFormat  *f)</span></span>;</span><br></pre></td></tr></table></figure><p>遍历 <code>ffmpeg</code> 中的解封装器的方法：</p><ol><li>注册所有解封装器：<code>av_register_all();</code>。注意，需要调用该函数才可以将所有注册的解封装器连接为一个链表</li><li>声明一个 <code>AVInputFormat</code> 类型的指针，比如说 <code>AVInputFormat* first_f = nullptr;</code></li><li>调用 <code>av_iformat_next()</code> 函数，即可获得指向链表下一个解封装器的指针，循环往复可以获得所有解码器的信息</li></ol><h4 id="AVInputFormat-成员变量"><a href="#AVInputFormat-成员变量" class="headerlink" title="AVInputFormat 成员变量"></a>AVInputFormat 成员变量</h4><p>每种文件格式对应了一个 <code>AVInputFormat</code> 对象，这些对象中的成员变量基本为 <code>const</code> 类型</p><ul><li><code>const char *name;</code> : 封装格式名称</li><li><code>const char *long_name;</code> : 封装格式的长名称</li><li><code>const char *extensions;</code> : 封装格式的扩展名</li><li><code>int raw_codec_id;</code> : 封装格式 <code>ID</code></li><li>一些封装格式处理的接口回调函数，如 <code>read_header</code>, <code>read_packet</code>, <code>read_close</code>, <code>read_seek</code> 等</li></ul><h3 id="编码-amp-解码"><a href="#编码-amp-解码" class="headerlink" title="编码 &amp; 解码"></a>编码 &amp; 解码</h3><h3 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h3><h3 id="AVCodecContext-相关函数"><a href="#AVCodecContext-相关函数" class="headerlink" title="AVCodecContext 相关函数"></a>AVCodecContext 相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个 AVCodecContext，并将其字段设置为默认值</span></span><br><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="keyword">const</span> AVCodec *codec)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVCodecContext 及其相关内容，并向提供的指针写入 nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avcodec_free_context</span><span class="params">(AVCodecContext **avctx)</span></span>;</span><br><span class="line"><span class="comment">// 关闭一个给定的 AVCodecContext 并释放所有与它相关的数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_close</span><span class="params">(AVCodecContext *avctx)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fill the codec context based on the values from the supplied codec parameters.</span></span><br><span class="line"><span class="comment"> * Any allocated fields in codec that have a corresponding field in par are</span></span><br><span class="line"><span class="comment"> * freed and replaced with duplicates of the corresponding field in par.</span></span><br><span class="line"><span class="comment"> * Fields in codec that do not have a counterpart in par are not touched.</span></span><br><span class="line"><span class="comment"> * @return &gt;= 0 on success, a negative AVERROR code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec, <span class="keyword">const</span> AVCodecParameters *par)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVCodecContext-成员变量"><a href="#AVCodecContext-成员变量" class="headerlink" title="AVCodecContext 成员变量"></a>AVCodecContext 成员变量</h4><ul><li><code>const struct AVCodec  *codec;</code> : 编解码器的 <code>AVCodec</code></li><li><code>int width, height;</code> : 图像的宽高（只针对视频）</li><li><code>int coded_width, coded_height;</code> 未裁剪的图像宽高</li><li><code>enum AVPixelFormat pix_fmt;</code> : 像素格式（只针对视频）</li><li><code>AVRational time_base;</code> : 帧率的信息</li><li><code>int sample_rate;</code> : 采样率（只针对音频）</li><li><code>int channels;</code> : 采样率（只针对音频）</li><li><code>enum AVSampleFormat sample_fmt;</code> : 采样格式（只针对音频）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    **** width&#x2F;coded_width &amp; height&#x2F;coded_height ****</span><br><span class="line">一些编码器要求帧尺寸是特定数字的倍数，例如 x264 的帧尺寸是 16 的倍数</span><br><span class="line">因此，如果需要，编码器将把帧填充到合适的数字，并为解码器存储裁剪值</span><br><span class="line">coded_width, coded_height 是裁剪前的大小</span><br><span class="line">width, height 是裁剪后的大小</span><br></pre></td></tr></table></figure><h3 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h3><p>AVCodec 是存储编解码器信息的结构体</p><h4 id="AVCodec-相关函数"><a href="#AVCodec-相关函数" class="headerlink" title="AVCodec 相关函数"></a>AVCodec 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 c 为空，返回第一个注册的编解码器</span></span><br><span class="line"><span class="comment">// 如果 c 非空，返回 c 之后的下一个注册编解码器，如果 c 是最后一个编解码器，返回 nullptr</span></span><br><span class="line"><span class="function">attribute_deprecated AVCodec *<span class="title">av_codec_next</span><span class="params">(<span class="keyword">const</span> AVCodec *c)</span></span>;</span><br><span class="line"><span class="comment">// 查找具有匹配编解码器 ID 的已注册解码器</span></span><br><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br><span class="line"><span class="comment">// 初始化 AVCodecContext 使用给定的 AVCodec。在使用这个函数之前，必须使用 avcodec_alloc_context3() 分配上下文。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>遍历 <code>ffmpeg</code> 中的解码器信息的方法：</p><ol><li>注册所有编解码器：<code>av_register_all();</code>。注意，需要调用该函数才可以将所有注册的解码器连接为一个链表</li><li>声明一个 <code>AVCodec</code> 类型的指针，比如说 <code>AVCodec* first_c = nullptr;</code></li><li>调用 <code>av_codec_next()</code> 函数，即可获得指向链表下一个解码器的指针，循环往复可以获得所有解码器的信息。注意，如果想要获得指向第一个解码器的指针，则需要将该函数的参数设置为 <code>nullptr</code></li></ol><h4 id="AVCodec-成员变量"><a href="#AVCodec-成员变量" class="headerlink" title="AVCodec 成员变量"></a>AVCodec 成员变量</h4><ul><li><code>const char *name;</code> : 编解码器的名字，比较短</li><li><code>const char *long_name;</code> : 编解码器的名字，全称，比较长</li><li><code>enum AVMediaType type;</code> : 指明了类型，是视频，音频，还是字幕</li><li><code>enum AVCodecID id;</code> : ID，不重复</li><li><code>const AVRational *supported_framerates;</code> : 支持的帧率（仅视频）</li><li><code>const enum AVPixelFormat *pix_fmts;</code> : 支持的像素格式（仅视频）</li><li><code>const int *supported_samplerates;</code> : 支持的采样率（仅音频）</li><li><code>const enum AVSampleFormat *sample_fmts;</code> : 支持的采样格式（仅音频）</li><li><code>const uint64_t *channel_layouts;</code> : 支持的声道数（仅音频）</li><li><code>int priv_data_size;</code> : 私有数据的大小</li></ul><p>每一个编解码器对应一个该结构体，查看一下 <code>ffmpeg</code> 的源代码，我们可以看一下 <code>H.264</code> 解码器的结构体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h264.c</span></span><br><span class="line">AVCodec ff_h264_decoder = &#123;</span><br><span class="line">    .name                  = <span class="string">&quot;h264&quot;</span>,</span><br><span class="line">    .long_name             = NULL_IF_CONFIG_SMALL(<span class="string">&quot;H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10&quot;</span>),</span><br><span class="line">    .type                  = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id                    = AV_CODEC_ID_H264,</span><br><span class="line">    .priv_data_size        = <span class="keyword">sizeof</span>(H264Context),</span><br><span class="line">    .init                  = h264_decode_init,</span><br><span class="line">    .<span class="built_in">close</span>                 = h264_decode_end,</span><br><span class="line">    .decode                = h264_decode_frame,</span><br><span class="line">    .capabilities          = <span class="comment">/*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/</span> AV_CODEC_CAP_DR1 |</span><br><span class="line">                             AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS |</span><br><span class="line">                             AV_CODEC_CAP_FRAME_THREADS,</span><br><span class="line">    .hw_configs            = (<span class="keyword">const</span> AVCodecHWConfigInternal *<span class="keyword">const</span> []) &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_EXPORTS_CROPPING |</span><br><span class="line">                             FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP,</span><br><span class="line">    .<span class="built_in">flush</span>                 = h264_decode_flush,</span><br><span class="line">    .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),</span><br><span class="line">    .profiles              = NULL_IF_CONFIG_SMALL(ff_h264_profiles),</span><br><span class="line">    .priv_class            = &amp;h264_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="音视频数据"><a href="#音视频数据" class="headerlink" title="音视频数据"></a>音视频数据</h2><h3 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h3><p><code>AVPacket</code> 是存储压缩编码数据相关信息的结构体</p><h4 id="AVPacket-相关函数"><a href="#AVPacket-相关函数" class="headerlink" title="AVPacket 相关函数"></a>AVPacket 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回流的下一帧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br><span class="line"><span class="comment">// 向解码器提供原始数据包数据作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVPacket-结构体定义"><a href="#AVPacket-结构体定义" class="headerlink" title="AVPacket 结构体定义"></a>AVPacket 结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVPacket</span> &#123;</span></span><br><span class="line">    AVBufferRef *buf;</span><br><span class="line">    <span class="keyword">int64_t</span> pts;    <span class="comment">///&lt; 显示时间戳</span></span><br><span class="line">    <span class="keyword">int64_t</span> dts;    <span class="comment">///&lt; 解码时间戳</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data;  <span class="comment">///&lt; 压缩编码数据</span></span><br><span class="line">    <span class="keyword">int</span>   <span class="built_in">size</span>;     <span class="comment">///&lt; 压缩编码数据大小</span></span><br><span class="line">    <span class="keyword">int</span>   stream_index; <span class="comment">///&lt; 所属的 AVStream</span></span><br><span class="line">    <span class="keyword">int</span>   flags;    <span class="comment">///&lt; A combination of AV_PKT_FLAG values</span></span><br><span class="line">    AVPacketSideData *side_data;</span><br><span class="line">    <span class="keyword">int</span> side_data_elems;</span><br><span class="line">    <span class="keyword">int64_t</span> duration;</span><br><span class="line">    <span class="keyword">int64_t</span> pos;    <span class="comment">///&lt; byte position in stream, -1 if unknown</span></span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   *** 对于 H.264 来说。1 个 AVPacket 的 data 通常对应一个 NALU ***</span><br><span class="line">通过查看 ffmpeg 源代码我们发现，AVPacket 中的数据起始处没有分隔符 0x00000001</span><br><span class="line">也不是 0x65、0x67、0x68、0x41 等字节</span><br><span class="line">所以 AVPacket 肯定这不是标准的 NALU</span><br><span class="line">其实，AVPacket 前 4 个字表示的是 NALU 的长度，从第 5 个字节开始才是 NALU 的数据</span><br><span class="line">所以直接将 AVPacket 前 4 个字节替换为 0x00000001 即可得到标准的 NALU 数据</span><br></pre></td></tr></table></figure><h3 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h3><h4 id="AVFrame-相关函数"><a href="#AVFrame-相关函数" class="headerlink" title="AVFrame 相关函数"></a>AVFrame 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配 AVFrame 并将其字段设置为默认值</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVFrame 和其中所有动态分配的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span>;</span><br><span class="line"><span class="comment">// 从解码器返回已解码的输出数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVPacket-成员变量"><a href="#AVPacket-成员变量" class="headerlink" title="AVPacket 成员变量"></a>AVPacket 成员变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFrame</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_NUM_DATA_POINTERS 8</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data[AV_NUM_DATA_POINTERS];    <span class="comment">// 解码后原始数据 对视频来说是 YUV，RGB，对音频来说是 PCM</span></span><br><span class="line">    <span class="keyword">int</span> linesize[AV_NUM_DATA_POINTERS];     <span class="comment">// data 中一行数据的大小。注意：未必等于图像的宽，一般大于图像的宽</span></span><br><span class="line">    <span class="keyword">uint8_t</span> **extended_data;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;  <span class="comment">// 视频帧宽和高（1920x1080, 1280x720 ...）</span></span><br><span class="line">    <span class="keyword">int</span> nb_samples;     <span class="comment">// 音频的一个 AVFrame 中可能包含多个音频帧，在此标记包含了几个</span></span><br><span class="line">    <span class="keyword">int</span> format;         <span class="comment">// 解码后原始数据类型（YUV420, YUV422, RGB24 ...）</span></span><br><span class="line">    <span class="keyword">int</span> key_frame;      <span class="comment">// 1 -&gt; keyframe, 0-&gt; not</span></span><br><span class="line">    <span class="keyword">enum</span> AVPictureType pict_type;   <span class="comment">// 帧类型（I, B, P ...）</span></span><br><span class="line">    AVRational sample_aspect_ratio; <span class="comment">// 宽高比（16:9, 4:3 ...）</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts;        <span class="comment">// 显示时间戳</span></span><br><span class="line">    <span class="keyword">int64_t</span> pkt_dts;</span><br><span class="line">    <span class="keyword">int</span> coded_picture_number;   <span class="comment">// 编码帧序号</span></span><br><span class="line">    <span class="keyword">int</span> display_picture_number; <span class="comment">// 显示帧序号</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125; AVFrame;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] 基于 FFmpeg + SDL 的视频播放器的制作 — 雷霄骅</li><li>[2] <a href="https://blog.csdn.net/leixiaohua1020/article/details/11693997">FFMPEG 中最关键的结构体之间的关系_雷霄骅 (leixiaohua1020) 的专栏 - CSDN 博客_ffmpeg 结构体</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AVFormatContext&lt;/code&gt; : 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVInputFormat&lt;/code&gt; : 每种封装格式（例如 FLV, MKV, MP4, AVI）对应一个该结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVStream&lt;/code&gt; : 视频文件中每个视频（音频）流对应一个该结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVCodecContext&lt;/code&gt; : 编码器上下文结构体，保存了视频（音频）编解码相关信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVCodec&lt;/code&gt; : 每种视频（音频）编解码器 (例如 H.264 解码器) 对应一个该结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVPacket&lt;/code&gt; : 存储一帧压缩编码数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVFrame&lt;/code&gt; : 存储一帧解码后像素（采样）数据&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - ffmpeg 命令行</title>
    <link href="http://github.hezhaojiang.io/post/2021/4765df61/"/>
    <id>http://github.hezhaojiang.io/post/2021/4765df61/</id>
    <published>2021-01-04T06:38:32.000Z</published>
    <updated>2021-01-13T13:48:34.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>ffmpeg</code> 是一个基于 <code>ffmpeg</code> 库的经典转码程序，几乎被所有的知名系统、软件工具、服务器后台等静默使用，通过命令行启动转码，这里主要以命令行语法讲解为主。</p><a id="more"></a><h2 id="查看-ffmpeg-帮助命令"><a href="#查看-ffmpeg-帮助命令" class="headerlink" title="查看 ffmpeg 帮助命令"></a>查看 ffmpeg 帮助命令</h2><p>在学习任何一个命令行程序前，首先要知道如何查看对应命令的帮助，在一般情况下，<code>linux</code> 平台下程序的帮助信息是通过 <code>程序名 -h</code> 的方式进行输出，<code>ffmpeg</code> 亦是如此。</p><p>精简帮助命令：<code>ffmpeg –h</code><br>更多帮助命令：<code>ffmpeg –h long</code><br>完整帮助命令：<code>ffmpeg –h full</code></p><h2 id="ffmpeg-的语法格式"><a href="#ffmpeg-的语法格式" class="headerlink" title="ffmpeg 的语法格式"></a>ffmpeg 的语法格式</h2><p>ffmpeg 的语法格式如下所示</p><pre><code>ffmpeg [输入源参数] -i [输入 URL] [输出参数] [输出 URL]其中 [输入源参数] 和 [输出参数] 的语法格式为：[options] [value(可以省略)] ... ...</code></pre><p>示例 1：</p><pre><code>ffmpeg -f mpegts -i &quot;http://AVTestFile/AVNormal/52&quot; -vcodec x264Encoder -r 15 -b:v 256000 -vf scale=800:600 -an -copyts -y &quot;51.avi&quot;* 输入源使用 mpegts 容器 http 协议的 URL* -vcodec x264Encoder 使用 x264Encoder 视频编码器* -r 15 视频帧率 15 fps* -b:v 256000 视频编码码率 265Kbps* -vf scale=800:600 使用视频滤器 scale 进行缩放到 800x600 尺寸* -an 禁用音频* -copyts 时间戳拷贝* -y 覆盖输出文件* 输出 URL 默认使用 file 协议，输出到文件 51.avi</code></pre><p>示例 2：</p><pre><code>ffmpeg -i BaiCaoYuan.mp4 -ss 00:00:19 -t 00:06:48 -dcodec copy -b:v 4000K -y cut.mp4* 输入源使用 file 协议，为 BaiCaoYuan.mp4 文件* -dcodec copy 使用与源视频一致的编解码器* -b:v 4000K 视频编码码率 4000Kbps* -y 覆盖输出文件* 输出 URL 默认使用 file 协议，输出到文件 cut.mp4</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><div class="table-container"><table><thead><tr><th>参数</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>-t duration</td><td>-t 00:06:48</td><td>设置处理时间，格式为hh:mm:ss</td></tr><tr><td>-ss position</td><td>-ss 00:00:19</td><td>设置起始时间，格式为hh:mm:ss</td></tr><tr><td>-b:v bitrate</td><td>-b:v 256000</td><td>设置视频码率</td></tr><tr><td>-b:a bitrate</td><td>-b:a 320000</td><td>设置音频码率</td></tr><tr><td>-r fps</td><td>-r 25</td><td>设置帧率</td></tr><tr><td>-s wxh</td><td>-s 800x600</td><td>设置帧大小，格式为WxH</td></tr><tr><td>-c:v codec</td><td>-c:v h264</td><td>设置视频编码器</td></tr><tr><td>-c:a codec</td><td>-c:a aac</td><td>设置音频编码器</td></tr><tr><td>-ar freq</td><td>-ar 44100</td><td>设置音频采样率</td></tr></tbody></table></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] 基于 FFmpeg + SDL 的视频播放器的制作 — 雷霄骅</li><li>[2] 多媒体编程开发之 FFmpeg 基础库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ffmpeg&lt;/code&gt; 是一个基于 &lt;code&gt;ffmpeg&lt;/code&gt; 库的经典转码程序，几乎被所有的知名系统、软件工具、服务器后台等静默使用，通过命令行启动转码，这里主要以命令行语法讲解为主。&lt;/p&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - YUV 格式详解</title>
    <link href="http://github.hezhaojiang.io/post/2021/a4daf22d/"/>
    <id>http://github.hezhaojiang.io/post/2021/a4daf22d/</id>
    <published>2021-01-03T05:07:20.000Z</published>
    <updated>2021-01-20T14:21:26.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>YUV</code> 是一种彩色编码系统，主要用在视频、图形处理流水线中 (pipeline)。相对于 RGB 颜色空间，设计 <code>YUV</code> 的目的就是为了编码、传输的方便，减少带宽占用和信息出错。</p><p>人眼的视觉特点是对亮度更铭感，对位置、色彩相对来说不铭感。在视频编码系统中为了降低带宽，可以保存更多的亮度信息 (luma)，保存较少的色差信息 (chroma)。</p><a id="more"></a><h2 id="YUV-的相似概念"><a href="#YUV-的相似概念" class="headerlink" title="YUV 的相似概念"></a>YUV 的相似概念</h2><p><code>Y’UV</code>、<code>YUV</code>、<code>YCbCr</code>、<code>YPbPr</code> 几个概念其实是一回事儿。</p><p>由于历史关系，<code>Y’UV</code>、<code>YUV</code> 主要是用在彩色电视中，用于模拟信号表示。</p><p><code>YCbCr</code> 是用在数字视频、图像的压缩和传输，如 <code>MPEG</code>、<code>JPEG</code>。</p><p>今天大家所讲的 <code>YUV</code> 其实就是指 <code>YCbCr</code>。<code>Y</code> 表示亮度（luma），<code>CbCr</code> 表示色度（chroma）。</p><p>luminance 亮度，<code>luma</code> 是在视频编码系统中指亮度值；chrominance 色度，<code>chroma</code> 是在视频编码系统中指色度值。</p><p><code>Y’UV</code> 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是 (<code>UV</code>)，那么在彩色电视显示的时候指显示亮度信息。</p><p><code>Y’UV</code> 不是 <code>Absolute Color Space</code>，只是一种 <code>RGB</code> 的信息编码，实际的显示还是通过 <code>RGB</code> 来显示。<code>Y’,U,V</code> 叫做不同的 component。</p><h2 id="YUV-后数字的含义"><a href="#YUV-后数字的含义" class="headerlink" title="YUV 后数字的含义"></a>YUV 后数字的含义</h2><pre><code>我们一般理解为 yuv444，yuv422，yuv420 的解释是后面三个数字分别对应前面三个字母。拿 yuv422 来说：y 对应 4，表示 4 个图形像素中，每个都有亮度值u 对应 2，表示 4 个图形像素中，Cb 占用两个像素v 对应 2，表示 4 个图形像素中，Cr 占用两个像素但是对于 yuv420 解释就不对了，不能说 4 个图形像素中，Cr 占用 0 个像素吧？</code></pre><p>我们通过下图来理解一下 <code>yuv</code> 各种格式后面数字的含义。图来源于 <a href="https://link.zhihu.com/?target=http%3A//dougkerr.net/Pumpkin/articles/Subsampling.pdf">Chrominance Subsampling in Digital Images</a></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210103211447.png" alt="YUV"></p><p>如上图中所示，左侧一列，每一个小矩形是图形像素表示，黑框矩形是色度像素表示，小黑点是表示色度像素值 (Cb + Cr)，表示图形像素和色度像素在水平和垂直方向的比例关系。比如，</p><pre><code>- 4:4:0 水平方向是 1/1，垂直方向是 1/2，表示 1 个色度像素对应了 2 个图形像素。- 4:2:2 水平方向是 1/2，垂直方向是 1/1，表示 1 个色度像素对应了 2 个图形像素。- 4:2:0 水平方向是 1/2，垂直方向是 1/2，表示 1 个色度像素对应了 4 个图形像素。</code></pre><p>右侧一列是二次采样模式记号表示, 是 <code>J:a:b</code> 模式，即 YUV 后数字表示的模式。图中实心黑色圆圈表示包含色度像素 (Cb + Cr），空心圆圈表示不包含色度像素。</p><pre><code>对于 J:a:b 模式，定义了一个 J x 2 的矩形参考块J 通常是 4，此参考块就是宽度有 4 个像素、高度有 2 个像素的矩形a 表示参考块的第一行包含的色度像素样本数b 表示在参考块的第二行包含的色度像素样本数- 4:4:0 参考块第 1 行包含 4 个色度样本，第 2 行没有包含色度样本。- 4:2:2 参考块第 1 行包含 2 个色度样本，第 2 行也包含 2 个色度样本，他们是交替出现。- 4:2:0 参考块第 1 行包含 2 个色度样本，第 2 行没有包含色度样本。</code></pre><blockquote><p>存在的一个例外是 4:1:0，其在每个亮度平面分辨率为 4 x 4 的块内提供一个色度样本。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://zhuanlan.zhihu.com/p/85620611">如何理解 YUV ？ - 知乎</a></li><li>[2] 多媒体编程开发之 FFmpeg 基础库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;YUV&lt;/code&gt; 是一种彩色编码系统，主要用在视频、图形处理流水线中 (pipeline)。相对于 RGB 颜色空间，设计 &lt;code&gt;YUV&lt;/code&gt; 的目的就是为了编码、传输的方便，减少带宽占用和信息出错。&lt;/p&gt;
&lt;p&gt;人眼的视觉特点是对亮度更铭感，对位置、色彩相对来说不铭感。在视频编码系统中为了降低带宽，可以保存更多的亮度信息 (luma)，保存较少的色差信息 (chroma)。&lt;/p&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="YUV" scheme="http://github.hezhaojiang.io/tags/YUV/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - Windows 安装 ffmpeg</title>
    <link href="http://github.hezhaojiang.io/post/2021/a1b64acb/"/>
    <id>http://github.hezhaojiang.io/post/2021/a1b64acb/</id>
    <published>2021-01-03T04:00:27.000Z</published>
    <updated>2021-01-13T13:49:29.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <code>Windows</code> 上编译 <code>ffmpeg</code> 没有在 <code>linux</code> 上简单方便，在此记录编译过程</p><a id="more"></a><h2 id="配置-MSVC-编译环境"><a href="#配置-MSVC-编译环境" class="headerlink" title="配置 MSVC 编译环境"></a>配置 MSVC 编译环境</h2><p>配置环境变量如下（VS2019）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PATH</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\bin\Hostx64\x64\</span><br><span class="line"><span class="comment"># INCLUDE</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\winrt</span><br><span class="line"><span class="comment"># LIB</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\lib\x64</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.18362.0\um\x64</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.18362.0\ucrt\x64</span><br></pre></td></tr></table></figure><h2 id="MSYS2-的安装与配置"><a href="#MSYS2-的安装与配置" class="headerlink" title="MSYS2 的安装与配置"></a>MSYS2 的安装与配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到以下内容</span></span><br><span class="line">rem <span class="built_in">set</span> MSYS2_PATH_TYPE=inherit</span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line"><span class="built_in">set</span> MSYS2_PATH_TYPE=inherit</span><br></pre></td></tr></table></figure><p>执行 <code>cl</code> 命令查看输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cl</span></span><br><span class="line">用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29335 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">用法: cl [ 选项... ] 文件名... [ /link 链接选项... ]</span><br></pre></td></tr></table></figure><p>如果是以上返回则配置成功</p><p>如果提示 <code>bash: cl: 未找到命令</code> 则需要检查是不是上述配置出了问题，或者重启电脑再试一下。</p><h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果网络连接不上，可以尝试使用代理</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;127.0.0.1:10809&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;127.0.0.1:10809&quot;</span></span><br><span class="line"><span class="comment"># 安装以下依赖</span></span><br><span class="line">pacman -S nasm</span><br><span class="line">pacman -S yasm</span><br><span class="line">pacman -S make cmake</span><br><span class="line">pacman -S diffutils</span><br><span class="line">pacman -S pkg-config</span><br><span class="line">pacman -S git</span><br><span class="line">pacman -S mingw-w64-x86_64-SDL2</span><br></pre></td></tr></table></figure><h2 id="编译-x264"><a href="#编译-x264" class="headerlink" title="编译 x264"></a>编译 x264</h2><h2 id="编译-x265"><a href="#编译-x265" class="headerlink" title="编译 x265"></a>编译 x265</h2><h2 id="编译-ffmpeg"><a href="#编译-ffmpeg" class="headerlink" title="编译 ffmpeg"></a>编译 ffmpeg</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="built_in">enable</span>-yasm --<span class="built_in">enable</span>-asm --toolchain=msvc --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-static</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;code&gt;Windows&lt;/code&gt; 上编译 &lt;code&gt;ffmpeg&lt;/code&gt; 没有在 &lt;code&gt;linux&lt;/code&gt; 上简单方便，在此记录编译过程&lt;/p&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 libevent - 时间管理</title>
    <link href="http://github.hezhaojiang.io/post/2020/39d8a9e7/"/>
    <id>http://github.hezhaojiang.io/post/2020/39d8a9e7/</id>
    <published>2020-12-30T08:24:28.000Z</published>
    <updated>2021-01-13T13:54:23.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了支持定时器，<code>libevent</code> 必须和系统时间打交道，z 在 <code>event_add</code> 时，用户制定了一个超时时间，这个超时时间是一个相对时间，但在 <code>event_add</code> 函数内部，<code>libevent</code> 将其转换为了绝对时间，这就带来了一个问题：在系统时间改变时，<code>libevent</code> 需要修改 <code>event</code> 的绝对时间，为此 <code>libevent</code> 内部有以下几种解决方案：</p><ol><li>使用单调时间 <code>monotonic time</code></li><li>使用系统时间生成 <code>fake monotonic time</code></li><li>使用系统时间（已弃用）</li></ol><a id="more"></a><h2 id="使用-monotonic-时间"><a href="#使用-monotonic-时间" class="headerlink" title="使用 monotonic 时间"></a>使用 monotonic 时间</h2><h3 id="什么是-monotonic-时间"><a href="#什么是-monotonic-时间" class="headerlink" title="什么是 monotonic 时间"></a>什么是 monotonic 时间</h3><p><code>monotonic time</code> 字面意思是单调时间，实际上它指的是系统启动以后流逝的时间，这是由变量 <code>jiffies</code> 来记录的。</p><p>系统每次启动时 <code>jiffies</code> 初始化为 0，每来一个 <code>timer interrupt</code>，<code>jiffies</code> 加 <code>1</code>，也就是说它代表系统启动后流逝的 <code>tick</code> 数</p><h3 id="是否使用-monotonic-时间"><a href="#是否使用-monotonic-时间" class="headerlink" title="是否使用 monotonic 时间"></a>是否使用 monotonic 时间</h3><p>决定 <code>libevent</code> 是否使用 <code>monotonic</code> 时间取决于系统是否支持 <code>monotonic</code> 时间，<code>libevent</code> 对其有两处判断，一处在编译时判断，一处在运行时判断：</p><h4 id="编译时判断"><a href="#编译时判断" class="headerlink" title="编译时判断"></a>编译时判断</h4><p>通过 <code>Cmake</code> 判断系统环境，来确定获取 <code>monotonic</code> 时间的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMakeLists.txt:</span></span><br><span class="line">CHECK_FUNCTION_EXISTS_EX(clock_gettime EVENT__HAVE_CLOCK_GETTIME)</span><br><span class="line">CHECK_FUNCTION_EXISTS_EX(mach_absolute_time EVENT__HAVE_MACH_ABSOLUTE_TIME)</span><br><span class="line"></span><br><span class="line"><span class="comment">// time-internal.h:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(EVENT__HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_POSIX_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(EVENT__HAVE_MACH_ABSOLUTE_TIME)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MACH_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_WIN32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_WIN32_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_FALLBACK_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>根据 <code>time-internal.h</code> 中的四个不同的宏定义，<code>libevent</code> 定义了四个 <code>evutil_configure_monotonic_time_</code> 函数，本文主要分析 <code>HAVE_POSIX_MONOTONIC</code> 宏定义下的 <code>evutil_configure_monotonic_time_</code> 函数。</p><h4 id="运行时判断"><a href="#运行时判断" class="headerlink" title="运行时判断"></a>运行时判断</h4><p><code>libevent</code> 会在 <code>event_base</code> 创建时对 <code>monotonic</code> 时间的支持进行判断，判断方式为：调用不同平台下的 <code>monotonic</code> 时间获取函数，如果能正确返回，则代表该平台支持 <code>monotonic</code> 时间，<code>libevent</code> 后续使用 <code>gettime</code> 获取时间均会使用 <code>monotonic</code> 时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The POSIX clock_gettime() interface provides a few ways to get at a monotonic clock.</span></span><br><span class="line"><span class="comment">   CLOCK_MONOTONIC is most widely supported.</span></span><br><span class="line"><span class="comment">   Linux also provides a CLOCK_MONOTONIC_COARSE with accuracy of about 1-4 msec.</span></span><br><span class="line"><span class="comment">   On all platforms I&#x27;m aware of, CLOCK_MONOTONIC really is monotonic.</span></span><br><span class="line"><span class="comment">   Platforms don&#x27;t agree about whether it should jump on a sleep/resume. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_configure_monotonic_time_</span><span class="params">(struct evutil_monotonic_timer *base, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* CLOCK_MONOTONIC exists on FreeBSD, Linux, and Solaris.  You need to check for it at runtime,</span></span><br><span class="line"><span class="comment">     * because some older kernel versions won&#x27;t have it working. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> fallback = flags &amp; EV_MONOT_FALLBACK;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fallback &amp;&amp; clock_gettime(CLOCK_MONOTONIC, &amp;ts) == <span class="number">0</span>) &#123;</span><br><span class="line">        base-&gt;monotonic_clock = CLOCK_MONOTONIC;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CLOCK_MONOTONIC &lt; <span class="number">0</span>) event_errx(<span class="number">1</span>,<span class="string">&quot;I didn&#x27;t expect CLOCK_MONOTONIC to be &lt; 0&quot;</span>);</span><br><span class="line">    base-&gt;monotonic_clock = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>libevent</code> 所在的系统支持 <code>monotonic</code> 时间，那么根本就不用考虑用户手动修改系统时间这坑爹的事情。但如果所在的系统没有支持 <code>monotonic</code> 时间，那么 <code>libevent</code> 就只能使用 <code>evutil_gettimeofday</code> 获取一个用户能修改的时间。</p><h2 id="使用-fake-monotonic-时间"><a href="#使用-fake-monotonic-时间" class="headerlink" title="使用 fake monotonic 时间"></a>使用 fake monotonic 时间</h2><p>从上述分析中可以看到，在平台不支持 <code>base-&gt;monotonic_clock</code> 会被 <code>libevent</code> 置为 <code>-1</code>，此时调用 <code>gettime</code> 就会调用 <code>evutil_gettimeofday</code> 来获取系统时间，并通过 <code>adjust_monotonic_time</code> 将获取到的系统时间调整为一个单调递增的时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_gettime_monotonic_</span><span class="params">(struct evutil_monotonic_timer *base, struct timeval *tp)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;monotonic_clock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (evutil_gettimeofday(tp, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// evutil_gettimeofday 调用 gettimeofday 函数</span></span><br><span class="line">        adjust_monotonic_time(base, tp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(base-&gt;monotonic_clock, &amp;ts) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    tp-&gt;tv_sec = ts.tv_sec;</span><br><span class="line">    tp-&gt;tv_usec = ts.tv_nsec / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettime</span><span class="params">(struct event_base *base, struct timeval *tp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;tv_cache.tv_sec) &#123;</span><br><span class="line">        *tp = base-&gt;tv_cache;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (evutil_gettime_monotonic_(&amp;base-&gt;monotonic_timer, tp) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统时间到-fake-monotonic-时间的转化"><a href="#系统时间到-fake-monotonic-时间的转化" class="headerlink" title="系统时间到 fake monotonic 时间的转化"></a>系统时间到 fake monotonic 时间的转化</h3><p><code>libevent</code> 获取到系统时间后，会调用 <code>adjust_monotonic_time</code> 生成 <code>fake monotonic</code> 时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function assumes it&#x27;s called repeatedly with a not-actually-so-monotonic time source whose outputs</span></span><br><span class="line"><span class="comment">   are in &#x27;tv&#x27;. It implements a trivial ratcheting mechanism so that the values never go backwards. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust_monotonic_time</span><span class="params">(struct evutil_monotonic_timer *base, struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* tv 输入的是 real time，输出为 fake monotonic time */</span></span><br><span class="line">    evutil_timeradd(tv, &amp;base-&gt;adjust_monotonic_clock, tv); <span class="comment">// evutil_timeradd(a,b,c) &lt;--&gt; c = a + b</span></span><br><span class="line">    <span class="comment">// 如果 tv &lt; last_time 表明用户向前调整时间了，需要校正时间</span></span><br><span class="line">    <span class="keyword">if</span> (evutil_timercmp(tv, &amp;base-&gt;last_time, &lt;)) &#123; <span class="comment">// evutil_timercmp(a,b,op) &lt;--&gt; a op b</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">adjust</span>;</span> <span class="comment">// 保存差值</span></span><br><span class="line">        evutil_timersub(&amp;base-&gt;last_time, tv, &amp;adjust); <span class="comment">// evutil_timersub(a,b,c) &lt;--&gt; c = a - b</span></span><br><span class="line">        evutil_timeradd(&amp;adjust, &amp;base-&gt;adjust_monotonic_clock, &amp;base-&gt;adjust_monotonic_clock);</span><br><span class="line">        *tv = base-&gt;last_time;</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;last_time = *tv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出，如果用户没有向前调整时间，则 <code>adjust_monotonic_time</code> 函数返回的就是真实的时间，如果用户向前调整了时间，<code>libevent</code> 会将用户向前调整的时间累计到 <code>base-&gt;adjust_monotonic_clock</code> 参数中，再之后获取的时间就都会被 <code>adjust_monotonic_time</code> 函数加上 <code>base-&gt;adjust_monotonic_clock</code> 再返回出来，从而实现时间的单调递增，即 <code>fake monotonic</code> 时间</p><h2 id="使用系统时间"><a href="#使用系统时间" class="headerlink" title="使用系统时间"></a>使用系统时间</h2><p>该部分内容已被 <code>libevent</code> 于 <code>2012</code> 年弃用，如读者有兴趣，可以查看 <a href="https://blog.csdn.net/luotuo44/article/details/38661787">参考资料[2]</a> 中的分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Revision: f5e4eb05e5bdf61b0a1b11f99effaf835a8796ce</span><br><span class="line">Author: Nick Mathewson &lt;nickm@torproject.org&gt;</span><br><span class="line">Date: 2012&#x2F;4&#x2F;21 1:14:10</span><br><span class="line">Message:</span><br><span class="line">Refactor monotonic timer handling into a new type and set of functions; add a gettimeofday-based ratcheting implementation</span><br><span class="line">Now, event.c can always assume that we have a monotonic timer; thismakes event.c easier to write.</span><br><span class="line">----</span><br><span class="line">Modified: event-internal.h</span><br><span class="line">Modified: event.c</span><br><span class="line">Modified: evutil_time.c</span><br><span class="line">Modified: time-internal.h</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li><li>[2] <a href="https://blog.csdn.net/luotuo44/article/details/38661787">Libevent 源码分析 - Libevent 时间管理 luotuo44 的专栏 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了支持定时器，&lt;code&gt;libevent&lt;/code&gt; 必须和系统时间打交道，z 在 &lt;code&gt;event_add&lt;/code&gt; 时，用户制定了一个超时时间，这个超时时间是一个相对时间，但在 &lt;code&gt;event_add&lt;/code&gt; 函数内部，&lt;code&gt;libevent&lt;/code&gt; 将其转换为了绝对时间，这就带来了一个问题：在系统时间改变时，&lt;code&gt;libevent&lt;/code&gt; 需要修改 &lt;code&gt;event&lt;/code&gt; 的绝对时间，为此 &lt;code&gt;libevent&lt;/code&gt; 内部有以下几种解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用单调时间 &lt;code&gt;monotonic time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用系统时间生成 &lt;code&gt;fake monotonic time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用系统时间（已弃用）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="libevent" scheme="http://github.hezhaojiang.io/tags/libevent/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 libevent - 优先级管理</title>
    <link href="http://github.hezhaojiang.io/post/2020/27de5435/"/>
    <id>http://github.hezhaojiang.io/post/2020/27de5435/</id>
    <published>2020-12-30T05:15:02.000Z</published>
    <updated>2021-01-13T13:54:53.723Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>event_base</code> 允许用户对它里面的 <code>event</code> 设置优先级，这样可以使得有些更重要的 <code>event</code> 能够得到优先处理。</p><a id="more"></a><h2 id="实现优先级"><a href="#实现优先级" class="headerlink" title="实现优先级"></a>实现优先级</h2><p><code>libevent</code> 实现优先级功能的方法是：用一个激活队列数组来存放激活 <code>event</code>。即数组的元素是一个激活队列，所以有多个激活队列。并且规定不同的队列有不同的优先级。</p><p>可以通过 <code>event_base_priority_init</code> 函数设置 <code>event_base</code> 的优先级个数，该函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_priority_init</span><span class="params">(struct event_base *base, <span class="keyword">int</span> npriorities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, r = <span class="number">-1</span>;</span><br><span class="line">    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">if</span> (N_ACTIVE_CALLBACKS(base) || npriorities &lt; <span class="number">1</span> || npriorities &gt;= EVENT_MAX_PRIORITIES) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">if</span> (npriorities == base-&gt;nactivequeues) <span class="keyword">goto</span> ok;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;nactivequeues) &#123;</span><br><span class="line">        mm_free(base-&gt;activequeues);</span><br><span class="line">        base-&gt;nactivequeues = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Allocate our priority queues */</span></span><br><span class="line">    base-&gt;activequeues = (struct evcallback_list *)mm_calloc(npriorities, <span class="keyword">sizeof</span>(struct evcallback_list));</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;activequeues == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        event_warn(<span class="string">&quot;%s: calloc&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;nactivequeues = npriorities;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; base-&gt;nactivequeues; ++i) TAILQ_INIT(&amp;base-&gt;activequeues[i]);</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">return</span> (r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面一个判断可知，因为 <code>event_base_dispatch</code> 函数会改动激活事件的个数，即会使得 <code>N_ACTIVE_CALLBACKS(base)</code> 为真。所以 <code>event_base_priority_init</code> 函数要在 <code>event_base_dispatch</code> 函数之前调用。此外要设置的优先级个数，要小于 <code>EVENT_MAX_PRIORITIES</code>。这个宏是在 <code>event.h</code> 文件中定义，在 <code>2.1.11</code> 版本中，该宏被定义成 <code>256</code>。在调用 <code>event_base_new</code> 得到的 <code>event_base</code> 只有一个优先级，也就是所有 <code>event</code> 都是同级的。</p><p>上面的代码调用 <code>mm_alloc</code> 分配了一个优先级数组。不同优先级的 <code>event</code> 会被放到数组的不同位置上 (下面可以看到这一点)。这样就可以区分不同 <code>event</code> 的优先级了。以后处理 <code>event</code> 时，就可以从高优先级到低优先级处理 <code>event</code>。</p><h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><p>上面是设置 <code>event_base</code> 的优先级个数。现在来看一下怎么设置 <code>event</code> 的优先级。可以通过 <code>event_priority_set</code> 函数设置，该函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set&#x27;s the priority of an event - if an event is already scheduled changing the priority is going to fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *ev, <span class="keyword">int</span> pri)</span> </span>&#123;</span><br><span class="line">    event_debug_assert_is_setup_(ev);</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_ACTIVE) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (pri &lt; <span class="number">0</span> || pri&gt;= ev-&gt;ev_base-&gt;nactivequeues) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    ev-&gt;ev_pri = pri;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码的第一个判断中，可以知道当 <code>event</code> 的状态是 <code>EVLIST_ACTIVE</code> 时，就不能对这个 <code>event</code> 进行优先级设置了。因此，如果要对 <code>event</code> 进行优先级设置，那么得在调用 <code>event_base_dispatch</code> 函数之前。因为一旦调用了 <code>event_base_dispatch</code>，那么 <code>event</code> 就随时可能变成 <code>EVLIST_ACTIVE</code> 状态。</p><h2 id="按优先级激活队列"><a href="#按优先级激活队列" class="headerlink" title="按优先级激活队列"></a>按优先级激活队列</h2><p>现在看一下一个 <code>event</code> 是怎么插入到 <code>event_base</code> 的优先级数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_queue_insert_active</span><span class="params">(struct event_base *base, struct event_callback *evcb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* #define ev_pri ev_evcallback.evcb_pri 事件优先级 */</span></span><br><span class="line">    EVUTIL_ASSERT(evcb-&gt;evcb_pri &lt; base-&gt;nactivequeues);</span><br><span class="line">    <span class="comment">/* 插入到对应优先级的激活队列尾部 */</span></span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;base-&gt;activequeues[evcb-&gt;evcb_pri], evcb, evcb_active_next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>event</code> 插入到 <code>event_base</code> 的优先级数组中后，会被按照优先级顺序被调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">event_process_active</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* 按优先级遍历激活队列中的事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; base-&gt;nactivequeues; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TAILQ_FIRST(&amp;base-&gt;activequeues[i]) != <span class="literal">NULL</span>) &#123; <span class="comment">/* 同一个优先级下可以有多个事件 */</span></span><br><span class="line">            base-&gt;event_running_priority = i; <span class="comment">/* 设置当前的优先级 */</span></span><br><span class="line">            activeq = &amp;base-&gt;activequeues[i]; <span class="comment">/* 获取优先级 i 下的所有 event 组成的链表 */</span></span><br><span class="line">            <span class="comment">/* 遍历 activeq 链表，调用其中每个 event 的回调函数 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; limit_after_prio) c = event_process_active_single_queue(base, activeq, INT_MAX, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span> c = event_process_active_single_queue(base, activeq, maxcb, endtime);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="keyword">goto</span> done; <span class="comment">/* c 是执行的非内部事件数目 */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c&gt; <span class="number">0</span>) <span class="comment">/* Processed a real event; do not consider lower-priority events */</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* If we get here, all of the events we processed were internal. Continue. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认优先级"><a href="#默认优先级" class="headerlink" title="默认优先级"></a>默认优先级</h2><p>默认优先级是在新建 <code>event</code> 结构体时设置的。不错，看下面的 <code>event_assign</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_assign</span><span class="params">(struct event *ev, struct event_base *base, <span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">short</span> events, <span class="keyword">void</span> (*callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* by default, we put new events into the middle priority */</span></span><br><span class="line">        ev-&gt;ev_pri = base-&gt;nactivequeues / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li><li>[2] <a href="https://blog.csdn.net/luotuo44/article/details/38512719">Libevent源码分析 event优先级设置 luotuo44的专栏 - CSDN博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;event_base&lt;/code&gt; 允许用户对它里面的 &lt;code&gt;event&lt;/code&gt; 设置优先级，这样可以使得有些更重要的 &lt;code&gt;event&lt;/code&gt; 能够得到优先处理。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="libevent" scheme="http://github.hezhaojiang.io/tags/libevent/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建 - Hexo 换机指导</title>
    <link href="http://github.hezhaojiang.io/post/2020/6a28acc4/"/>
    <id>http://github.hezhaojiang.io/post/2020/6a28acc4/</id>
    <published>2020-12-20T00:22:19.000Z</published>
    <updated>2021-01-13T14:04:40.687Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于最近更换电脑，需要将旧电脑的一些资料转移至新电脑，其中 <code>Hexo</code> 的资料转移过程中踩了不少坑，所以在此记录以下，防止后续换机时继续踩坑。</p><a id="more"></a><h2 id="安装-Hexo-环境"><a href="#安装-Hexo-环境" class="headerlink" title="安装 Hexo 环境"></a>安装 Hexo 环境</h2><p>首先需要在新电脑上安装 <code>Hexo</code> 环境</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>这里是第一个坑，安装的 <code>Node.js</code> 建议版本为 12.14，如果安装的版本过高，后续 <code>hexo</code> 命令执行时可能会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(node:2396) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</span><br><span class="line">(Use &#96;node --trace-warnings ...&#96; to show where the warning was created)</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency</span><br></pre></td></tr></table></figure><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装好 <code>Node.js</code> 后直接安装 <code>Hexo</code>，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>安装完发现无法运行 <code>Hexo</code> 命令，需要进行如下设置：</p><ol><li><p>以管理员身份运行 <code>powershell</code></p></li><li><p>执行 <code>set-executionpolicy remotesigned</code></p></li></ol><h2 id="拷贝-Hexo-资料文件夹"><a href="#拷贝-Hexo-资料文件夹" class="headerlink" title="拷贝 Hexo 资料文件夹"></a>拷贝 Hexo 资料文件夹</h2><p>拷贝除 .deploy_git 和 public 文件夹以外的所有内容</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201220200545.png" alt="Hexo文件夹"></p><p>此时即可用 <code>hexo g</code> 等命令正常使用 <code>Hexo</code> 了~~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于最近更换电脑，需要将旧电脑的一些资料转移至新电脑，其中 &lt;code&gt;Hexo&lt;/code&gt; 的资料转移过程中踩了不少坑，所以在此记录以下，防止后续换机时继续踩坑。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="http://github.hezhaojiang.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="http://github.hezhaojiang.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - MP4 封装格式</title>
    <link href="http://github.hezhaojiang.io/post/2020/e90af351/"/>
    <id>http://github.hezhaojiang.io/post/2020/e90af351/</id>
    <published>2020-11-29T07:39:12.000Z</published>
    <updated>2021-01-13T13:51:44.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>mp4</code> 文件封装格式，对应的标准为 <code>ISO/IEC 14496-12</code> 和 <code>ISO/IEC 14496-14</code>。</p><p><code>ISO/IEC 14496-12</code> 定义了一种封装媒体数据的基础文件格式，<code>mp4</code>、<code>3gp</code>、<code>ismv</code> 等我们常见媒体封装格式都是以这种基础文件格式为基础衍生的。</p><p><code>ISO/IEC 14496-14</code> 基于 <code>ISO-14496-12</code> 定义了 <code>mp4</code> 文件格式。</p><a id="more"></a><h2 id="基础文件格式-Box"><a href="#基础文件格式-Box" class="headerlink" title="基础文件格式 - Box"></a>基础文件格式 - Box</h2><p>按照 <code>ISO-14496-12</code>，文件由一系列对象 <code>Box</code> 构成, <code>Box</code> 可以嵌套包含其他 <code>Box</code></p><p><code>Box</code> 分为两类: 一类是元数据 <code>Box</code>，一类是媒体数据 <code>Box</code></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130213738.png" alt="Box"></p><p><code>Box Header</code> 的格式可用如下代码表示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">Box</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) boxtype, optional <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>)[<span class="number">16</span>] extended_type)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">size</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> type </span>= boxtype;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> largesize</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// box extends to end of file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (boxtype == <span class="string">&quot;uuid&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>)[<span class="number">16</span>] usertype = extended_type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些 <code>Box</code> 对象的 <code>Box Header</code> 可能会包含有版本号和标志域:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">FullBox</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) boxtype, <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>) v, <span class="built_in">bit</span>(<span class="number">24</span>) f)</span> extends <span class="title">Box</span><span class="params">(boxtype)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> version </span>= v;</span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">24</span>) flags = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MP4-格式介绍"><a href="#MP4-格式介绍" class="headerlink" title="MP4 格式介绍"></a>MP4 格式介绍</h2><p><code>Box</code> 种类非常多，下图中例举了一些重要的 <code>Box</code> 类型:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130214743.png" alt="MP4"></p><ol><li>分析时会从外到里进行分析，先分析第一层的 <code>Box</code> 各个字段，再分析第二层 <code>Box</code> 各个字段，以此类推</li><li><code>Box</code> 由于种类非常多，这里只分析一个标准的 <code>mp4</code> 文件的 <code>Box</code> 含义</li><li><code>Box</code> 里面字段也不是所有的都需要关注，我们只需要关注核心和有用的，对于一些不太用的就可以忽略不计了</li></ol><h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><p>使用 <code>mp4info</code> 打开一个 <code>mp4</code> 文件，可以看到，该 <code>mp4</code> 文件第一层 <code>Box</code> 有 <code>4</code> 种:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130215440.png" alt="第一层"></p><ol><li><code>ftyp</code></li><li><code>free</code></li><li><code>mdat</code></li><li><code>moov</code></li></ol><p>我们逐个分析该 <code>4</code> 种 <code>Box</code> 的含义和内容。</p><h3 id="ftyp"><a href="#ftyp" class="headerlink" title="ftyp"></a>ftyp</h3><p><code>ftyp</code> 是 <code>mp4</code> 文件的第一个 <code>Box</code>，包含了视频文件使用的编码格式、标准等，这个 <code>Box</code> 作用基本就是 <code>mp4</code> 这种封装格式的标识，同时在一份 <code>mp4</code> 文件中只有一个这样的 <code>Box</code>。<code>ftyp box</code> 通常放在文件的开始，通过对该 <code>Box</code> 解析可以让我们的软件（播放器、demux、解析器）知道应该使用哪种协议对这该文件解析，是后续解读文件基础。</p><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130234447.png" alt="ftyp box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class FileTypeBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;ftyp&quot;</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> major_brand</span>;           <span class="comment">// 不同厂商要实现这种规范都要向 ISO 注册的一个四字节的标识码</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> minor_version</span>;         <span class="comment">// 商标版本号</span></span><br><span class="line">    unsigned int(32) compatible_brands[];   // 兼容其他的版本号，表示可以兼容和遵从那些协议标准，是一个列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 1C</code> 表示该 <code>Box</code> 长度为 <code>28</code> 字节</li><li>Box type: <code>0x66 74 79 70</code> 是 <code>ftyp</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>major brand: <code>0x69 73 6F 6D</code> 是 <code>isom</code> 的 <code>ASCII</code> 值，说明本文件是符合这个规范的。</li><li>minor version: <code>0x00 00 02 00</code> 代表 <code>isom</code> 的版本号</li><li>compatible brand: <code>0x69 73 6F 6D 69 73 6F 32 6D 70 34 31</code> <code>ASCII</code> 值为 <code>iosmios2mp4l</code> 表示本文件可以兼容的协议和标准</li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130235834.png" alt="ftyp Mp4Explorer"></p><h3 id="moov"><a href="#moov" class="headerlink" title="moov"></a>moov</h3><ul><li><code>Container</code>: <code>File</code></li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p><code>moov Box</code> 这个 <code>Box</code> 也是 <code>MP4</code> 文件中必须有但是只存在一个的 <code>Box</code>, 这个 <code>Box</code> 里面一般存的是媒体文件的元数据，这个 <code>Box</code> 本身是很简单的，是一种 Container <code>Box</code>，里面的数据是子 <code>Box</code>, 自己更像是一个分界标识。</p><p>所谓的媒体元数据主要包含类似 <code>SPS</code>、<code>PPS</code> 的编解码参数信息，还有音视频的时间戳等信息。对于 <code>MP4</code> 还有一个重要的采样表 <code>stbl</code> 信息，这里面定义了采样 <code>Sample</code>、<code>Chunk</code>、<code>Track</code> 的映射关系，是 <code>MP4</code> 能够进行随机拖动和播放的关键，也是需要好好理解的部分，对于实现一些音视频特殊操作很有帮助。</p><p>根据 <code>ISO-14496-12</code>，文件中必须要包括唯一一个元数据容器: <code>Movie Box(moov)</code>，该 <code>Box</code> 一般在文件的头部或尾部，方便定位。</p><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201000619.png" alt="moov box"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MovieBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;moov&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 2E 49</code> 表示该 <code>Box</code> 长度为 <code>11849</code> 字节</li><li>Box type: <code>0x6D 6F 6F 76</code> 就是 <code>moov</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#mvhd">第二层 - mvhd</a></li><li>参见: <a href="#iods">第二层 - iods</a></li><li>参见: <a href="#trak">第二层 - trak</a></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201000000.png" alt="moov Mp4Explorer"></p><h3 id="mdat"><a href="#mdat" class="headerlink" title="mdat"></a>mdat</h3><p><code>mdat Box</code> 这个 <code>Box</code> 是存储音视频数据的 <code>Box</code>，要从这个 <code>Box</code> 解封装出真实的媒体数据。当然这个 <code>Box</code> 一般都会存在，但是不是必须的。</p><p>说明:</p><ol><li><code>mdat Box</code> 基本组成还是有头部和数据两部分组成，但是这里注意如果 <code>Box length</code> 长度不够时，要用后面 <code>8</code> 字节的扩展长度字段，<code>Box Type</code> 还是 <code>mdat</code> 的 <code>ASCII</code> 码值</li><li>真实的数据字段是一个个 <code>NALU header</code> + <code>NALU Data</code>，但是没有用 <code>NALU</code> 的分解符 <code>00 00 00 01</code>, 是在每个 <code>NALU</code> 前面加了长度字段，和 <code>RTP</code> 打包类似</li><li>这里的 <code>NLAU</code> 一般不再包含 <code>SPS</code> <code>PPS</code> 等数据，这些数据已经放到 <code>moov Box</code> 里面了，至于是如何放到 <code>moov Box</code> 的，下面文章会讲解。这里一般 <code>NALU</code> 类型就是 <code>I\B\P</code> 帧数据以及 <code>SEI</code> 用户增强信息</li></ol><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201001516.png" alt="mdat box"></p><ul><li>Box Header<ul><li>Box Length: <code>0x00 25 4B F7</code> 表示该 <code>Box</code> 长度为 <code>2444279</code> 字节，即后面的 <code>NALU</code> 整个长度为 <code>2444279 - 8 = 2444271</code> 字节</li><li>Box type: <code>0x6D 64 61 74</code> 这就是 <code>mdat</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><code>free Box</code> 中的内容是无关紧要的，可以被忽略即该 <code>Box</code> 被删除后，不会对播放产生任何影响。这种类型的 <code>Box</code> 也不是必须的，可有可无，类似的 <code>Box</code> 还有 <code>sikp Box</code>. 虽然在解析是可以忽略，但是需要注意该 <code>Box</code> 的删除对其它 <code>Box</code> 的偏移量影响，特别是当 <code>moov Box</code> 放到 <code>mdat Box</code> 后面的情况。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201222436.png" alt="free box"></p><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 08</code> 表示该 <code>Box</code> 长度为 <code>9</code> 字节</li><li>Box type: <code>0x66 72 65 65</code> 这就是 <code>free</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data</li></ul><h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><p>从第二层开始，后续的每一层基本都封装于 <code>moov Box</code>。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201224431.png" alt="moov Box"></p><h3 id="mvhd"><a href="#mvhd" class="headerlink" title="mvhd"></a>mvhd</h3><p>这个 Box 也是全文件唯一的一个 Box, 一般处于 moov Box 的第一个子 Box, 这个 Box 对整个媒体文件所包含的媒体数据（包含 Video track 和 Audio Track 等）进行全面的描述。其中包含了媒体的创建和修改时间，默认音量、色域、时长等信息。</p><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201231209.png" alt="mvhd Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MovieHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;mvhd&quot;</span>, version, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 文件媒体在 1 秒时间内的刻度值，可以理解为 1 秒长度的时间单元数，这个只用来计算了该 Mp4 文件的长度，但是没有参与 PTS 和 DTS 的计算。</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 文件媒体在 1 秒时间内的刻度值，可以理解为 1 秒长度的时间单元数，这个只用来计算了该 Mp4 文件的长度，但是没有参与 PTS 和 DTS 的计算。</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> rate </span>= <span class="number">0x00010000</span>; <span class="comment">// 推荐播放速率，[16.16] 格式，1.0 表示 1 倍速播放</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> volume </span>= <span class="number">0x0100</span>;   <span class="comment">// 与 rate 类似，[8.8] 格式，1.0 表示最大音量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">bit</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">    const unsigned int(32)[2] reserved = 0;</span><br><span class="line">    template int(32)[9] matrix =</span><br><span class="line">    &#123;<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x40000000</span>&#125;; <span class="comment">// Unity matrix</span></span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">32</span>)[<span class="number">6</span>] pre_defined = <span class="number">0</span>;     <span class="comment">// 预览相关的信息，一般都是填充 0，所以不用太关心</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> next_track_ID</span>; <span class="comment">// 下一个 Track 使用的 id 号，通过该值减去 1 可以判断当前文件的 Track 数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 6c</code> 表示该 <code>Box</code> 长度为 <code>108</code> 字节</li><li>Box type: <code>0x6d 76 68 64</code> 这就是 <code>mvhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>creation time: <code>0x00 00 00 00</code></li><li>modification time: <code>0x00 00 00 00</code></li><li>time_scale: <code>0x00 00 03 E8</code> 代表 <code>1</code> 秒的时间单位是 <code>1000</code>，即把 <code>1</code> 秒划分为 <code>1000</code> 份，这样描述的更精确</li><li>duration: <code>0x00 00 46 68</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>18024/1000</code> 即 <code>18.024</code> 秒</li><li>rate: <code>0x00 01 00 00</code> 推荐采样原始倍速播放，一般就是 <code>1</code> 倍速进行播放该视频</li><li>volume: <code>01 00</code> 推荐采样原始视频音量进行播放</li><li>next_track_id: <code>0x00 00 00 03</code> 这个值表示如果要增加下一个 <code>Track</code> 时，需要的编号是 <code>3</code>，那同时也就说明本文件里面有 <code>2</code> 个 <code>Track</code>，实际发现刚好是 <code>2</code> 个 <code>Track</code></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201224755.png" alt="mvhd Mp4Explorer"></p><h3 id="iods"><a href="#iods" class="headerlink" title="iods"></a>iods</h3><p>这个 <code>Box</code> 也是非必须 <code>Box</code>，不算核心 <code>Box</code>, 实际也是 <code>24</code> 字节的固定值，解析时直接跳过即可。封装直接给填写固定 <code>24</code> 字节即可，注意该 <code>Box</code> 也是 Full <code>Box</code> 意味这 <code>Header</code> 里面有 <code>1</code> 字节的 <code>Version</code> 和 <code>3</code> 字节的 <code>Flag</code> 字段。</p><p>定义的内容应该是 <code>Audio</code> 和 <code>Video ProfileLevel</code> 方面的描述。但是现在没有用。</p><h3 id="trak"><a href="#trak" class="headerlink" title="trak"></a>trak</h3><p><code>trak Box</code> 定义了媒体文件中媒体中一个 <code>Track</code> 的信息，视频有 <code>Video Track</code>, 音频有 <code>Audio Track</code>，媒体文件中可以有多个 <code>Track</code>，每个 <code>Track</code> 具有自己独立的时间和空间的信息，可以进行独立操作。</p><p>每个 <code>trak Box</code> 都需要有一个 <code>tkhd Box</code> 和 <code>mdia Box</code>，其它的 <code>Box</code> 都是可选择的</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201233103.png" alt="trak Box"></p><p><code>Trak Box</code> 这里自身只是一个分界符，属于 <code>Container Box</code>，它的 <code>Box Data</code> 其实是其他的 <code>Box</code> 类型。</p><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 10 1E</code> 表示该 <code>Box</code> 长度为 <code>4126</code> 字节</li><li>Box type: <code>0x74 72 61 6B</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#tkhd">第三层 - tkhd</a></li><li>参见: <a href="#edts">第三层 - edts</a></li><li>参见: <a href="#mdia">第三层 - mdia</a></li></ul></li></ul><h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><h3 id="tkhd"><a href="#tkhd" class="headerlink" title="tkhd"></a>tkhd</h3><p><code>Container</code>: <code>Track Box</code> (<code>&quot;trak&quot;</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>该 <code>Box</code> 描述了该 <code>Track</code> 的媒体整体信息包括时长、图像的宽度和高度等，实际比较重要，同时该 <code>Box</code> 是 <code>Full Box</code> 即 <code>Box Header</code> 后面有 <code>Version</code> 和 <code>Flag</code> 字段。</p><p>分析如下码流:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201234750.png" alt="tkhd Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class TrackHeaderBox extends <span class="title">FullBox</span><span class="params">(‘tkhd’, version, flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> track_ID</span>;          <span class="comment">// 唯一标识该 Track 的一个非零值</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> track_ID</span>;          <span class="comment">// 唯一标识该 Track 的一个非零值</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    const unsigned int(32)[2] reserved = 0;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> layer </span>= <span class="number">0</span>;             <span class="comment">// 视频层，值小的在上层</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> alternate_group </span>= <span class="number">0</span>;   <span class="comment">// Track 分组信息，一般默认为 0，表示该 Track 和其它 Track 没有建立群组关系</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> volume </span>= &#123;<span class="keyword">if</span> track_is_audio <span class="number">0x0100</span> <span class="keyword">else</span> <span class="number">0</span>&#125;; <span class="comment">// [8.8] 格式，1.0 表示最大音量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">    template int(32)[9] matrix=</span><br><span class="line">    &#123;<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x40000000</span>&#125;;</span><br><span class="line">    <span class="comment">// unity matrix</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">width</span></span>;     <span class="comment">// 如果该 Track 为 Video Track，则表示图像的宽度（16.16 浮点表示）</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">height</span></span>;    <span class="comment">// 如果该 Track 为 Video Track，则表示图像的高度（16.16 浮点表示）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 5c</code> 表示该 <code>Box</code> 长度为 <code>92</code> 字节</li><li>Box type: <code>0x74 6B 68 64</code> 这就是 <code>tkhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 03</code></li></ul></li><li>Box Data<ul><li>creation time: <code>0x00 00 00 00</code></li><li>modification time: <code>0x00 00 00 00</code></li><li>track_id: <code>0x00 00 00 01</code> 这是该 <code>Track</code> 的唯一标识</li><li>duration: <code>0x00 00 46 50</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>18000/1000</code> 即 <code>18</code> 秒</li><li>layer: <code>0x00 00</code></li><li>alternate_group: <code>0x00 00</code></li><li>volume: <code>00 00</code></li><li>width: <code>0x03 55 55 55</code> 表示该视频图像的宽度是 <code>853.21845</code></li><li>height: <code>0x01 e0 00 00</code> 表示该视频图像的宽度是 <code>480.0</code></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201235125.png" alt="tkhd Mp4Explorer"></p><h3 id="edts"><a href="#edts" class="headerlink" title="edts"></a>edts</h3><h3 id="mdia"><a href="#mdia" class="headerlink" title="mdia"></a>mdia</h3><ul><li><code>Container</code>: <code>Track Box</code> (<code>trak</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p>这个 <code>Box</code> 也是 <code>Container Box</code>，里面包含子 <code>Box</code>，一般必须有 <code>mdhd Box</code>、<code>hdlr Box</code>、<code>minf Box</code>。基本就是当前 <code>Track</code> 媒体头信息和媒体句柄以及媒体信息。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001301.png" alt="mdia Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;mdia&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 10 1E</code> 表示该 <code>Box</code> 长度为 <code>4126</code> 字节</li><li>Box type: <code>0x74 72 61 6B</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#hdlr">第四层 - mdhd</a></li><li>参见: <a href="#hdlr">第四层 - hdlr</a></li><li>参见: <a href="#minf">第四层 - minf</a></li></ul></li></ul><h2 id="第四层"><a href="#第四层" class="headerlink" title="第四层"></a>第四层</h2><h3 id="mdhd"><a href="#mdhd" class="headerlink" title="mdhd"></a>mdhd</h3><ul><li><code>Container</code>: <code>Media Box</code> (<code>mdia</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p>这个 <code>Box</code> 是 <code>Full Box</code>，意味这 <code>Box Header</code> 有 <code>Version</code> 和 <code>Flag</code> 字段，该 <code>Box</code> 里面主要定义了该 <code>Track</code> 的媒体头信息，其中我们最关心的两个字段是 <code>Time scale</code> 和 <code>Duration</code>，分别表示了该 <code>Track</code> 的时间戳和时长信息，这个时间戳信息也是 <code>PTS</code> 和 <code>DTS</code> 的单位。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001857.png" alt="mdhd Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;mdhd&quot;</span>, version, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 当前 Track 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 当前 Track 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 当前 Track 的时间计算单位</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 当前 Track 的播放时长，需要参考前面的 timescale 计算</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 当前 Track 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 当前 Track 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 当前 Track 的时间计算单位</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 当前 Track 的播放时长，需要参考前面的 timescale 计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">1</span>) pad = <span class="number">0</span>;</span><br><span class="line">    unsigned int(5)[3] language;            // 媒体语言码，参考 ISO-639-2/T</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> pre_defined </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 20</code> 表示该 <code>Box</code> 长度为 <code>32</code> 字节</li><li>Box type: <code>0x6d 64 68 64</code> 这就是 <code>mdhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>creation time: <code>0x00 00 00 00</code></li><li>modification time: <code>0x00 00 00 00</code></li><li>timescale: <code>0x00 00 30 00</code> 表示当前 <code>Track</code> 的时间戳单位是 <code>12288</code></li><li>duration: <code>0x00 03 60 00</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>221184/12288</code> 即 <code>18</code> 秒</li><li>language: <code>0x55 c4</code> 最高位为 <code>0</code>，后面 <code>15</code> 位代表三个字符<ul><li><code>0x55 c4</code> 转为二进制 <code>BIN: 01010101 11000100</code> 去掉首位 <code>0</code> 得到 <code>15</code> 位二进制数字</li><li>每 <code>5</code> 位二进制一组: <code>10101 01110 00100</code> 代表三个数字 <code>21</code>、<code>15</code>、<code>4</code></li><li>三个数字对应从 <code>a</code> 开始的第 <code>21</code>、<code>15</code>、<code>4</code> 个字母，即 <code>u</code>、<code>n</code>、<code>d</code>，查询 <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes">ISO 639-2/T</a> 可知其含义</li></ul></li><li>qualiiy: <code>0x00 00</code></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001924.png" alt="mdhd Mp4Explorer"></p><h3 id="hdlr"><a href="#hdlr" class="headerlink" title="hdlr"></a>hdlr</h3><p><code>Container</code>: <code>Media Box</code> (<code>mdia</code>) or <code>Meta Box</code> (<code>meta</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 <code>Box</code> 是 <code>Full Box</code>，该 <code>Box</code> 解释了媒体的播放过程信息，用来设置不同 <code>Track</code> 的处理方式，标识了该 <code>Track</code> 的类型。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202003746.png" alt="hdlr Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class HandlerBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;hdlr&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> pre_defined </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> handler_type</span>;  <span class="comment">// Handle 的类型: 视频: &#x27;vide&#x27;，音频: &#x27;soun&#x27;</span></span><br><span class="line">    const unsigned int(32)[3] reserved = 0;</span><br><span class="line">    <span class="built_in">string</span> name; <span class="comment">// 这个 component 的名字，其实这里就是你给该 Track 其的名字，打包时填写一个有意义字符串就可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 2d</code> 表示该 <code>Box</code> 长度为 <code>45</code> 字节</li><li>Box type: <code>0x68 64 6c 72</code> 这就是 <code>hdlr</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>handle type: <code>0x76 69 64 65</code> 即’vide’，代表当前 Track 为视频数据</li><li>name: <code>VideoHandler</code></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202003621.png" alt="hdlr Mp4Explorer"></p><h3 id="minf"><a href="#minf" class="headerlink" title="minf"></a>minf</h3><p><code>Container</code>: <code>Media Box</code> (<code>mdia</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 <code>Box</code> 是我认为 moov <code>Box</code> 里面最重要最复杂的 <code>Box</code>，内部还有子 <code>Box</code>。该 <code>Box</code> 建立了时间到真实音视频 <code>Sample</code> 的映射关系，对于音视频数据操作时很有帮助的。</p><p>同时该 <code>Box</code> 是 <code>Container Box</code>，下面一般含有三大必须的子 <code>Box</code>:</p><ul><li>媒体信息头 <code>Box</code>: <code>vmhd Box</code> 或者 <code>smhd Box</code>;</li><li>数据信息 <code>Box</code>: <code>dinf Box</code></li><li>采样表 <code>Box</code>:<code>stbl Box</code></li></ul><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202124113.png" alt="minf Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaInformationBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;minf&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 0f 41</code> 表示该 <code>Box</code> 长度为 <code>3905</code> 字节</li><li>Box type: <code>0x6d 69 6e 66</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#vmhd">第五层 - vmhd</a></li><li>参见: <a href="#smhd">第五层 - smhd</a></li><li>参见: <a href="#dinf">第五层 - dinf</a></li><li>参见: <a href="#stbl">第五层 - stbl</a></li></ul></li></ul><h2 id="第五层"><a href="#第五层" class="headerlink" title="第五层"></a>第五层</h2><h3 id="vmhd"><a href="#vmhd" class="headerlink" title="vmhd"></a>vmhd</h3><ul><li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p>这个 <code>Box</code> 的大小是固定的，大小是 <code>24</code> 字节，一般都是用默认值填充。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202125231.png" alt="vmhd Box"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class VideoMediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;vmhd&quot;</span>, version = <span class="number">0</span>, <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> graphicsmode </span>= <span class="number">0</span>; <span class="comment">// 视频合成模式，为 0 时拷贝原始图像，否则与 opcolor 进行合成</span></span><br><span class="line">    template unsigned int(16)[3] opcolor = &#123;0, 0, 0&#125;; // 颜色值，RGB 颜色值，&#123;R,G,B&#125; 一般默认 0x00 00 00 00 00 00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="smhd"><a href="#smhd" class="headerlink" title="smhd"></a>smhd</h3><ul><li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one specific media header shall be present</code></li></ul><p>这个 <code>Box</code> 的大小是固定的，大小是 <code>16</code> 字节，一般都是用默认值填充。</p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SoundMediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;smhd&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> balance </span>= <span class="number">0</span>;   <span class="comment">// 音频的均衡是用来控制计算机的两个扬声器的声音混合效果，一般是 0</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dinf"><a href="#dinf" class="headerlink" title="dinf"></a>dinf</h3><p><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>) or <code>Meta Box</code> (<code>meta</code>)<br><code>Mandatory</code>: <code>Yes</code> (required within <code>minf box</code>) and <code>No</code> (optional within <code>meta box</code>)<br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 <code>Box</code> 也是一个 <code>Container Box</code>，一般用来定位媒体信息。一般会包含一个 <code>dref Box</code> 即 <code>data reference box</code>，<code>dref</code> 下面会有若干个 <code>url Box</code> 或者也叫 <code>urn Box</code>，这些 <code>Box</code> 组成一个表，用来定位 <code>Track</code> 的数据。</p><p><code>Track</code> 可以被分成若干个段，每一段都可以根据 <code>Url</code> 或者 <code>Urn</code> 指向的地址来获取数据，<code>sample</code> 描述中会用这些片段的序号将这些片段组成一个完整的 <code>track</code>，一般情况下当数据完全包含在文件中，<code>Url</code> 和 <code>urn Box</code> 的字符串是空的。</p><p>这个 <code>Box</code> 存在的意义就是允许 <code>MP4</code> 文件的媒体数据分开最后还能进行恢复合并操作，但是实际上，<code>Track</code> 的数据都保存再文件中，所以该字段的重要性还体现不出来。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202130034.png" alt="dinf"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class DataInformationBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;dinf&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 24</code> 表示该 <code>Box</code> 长度为 <code>36</code> 字节</li><li>Box type: <code>0x64 69 6e 66</code> 这就是 <code>dinf</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#dref">第六层 - dref</a></li></ul></li></ul><h3 id="stbl"><a href="#stbl" class="headerlink" title="stbl"></a>stbl</h3><ul><li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li><li><code>Mandatory</code>: <code>Yes</code></li><li><code>Quantity</code>: <code>Exactly one</code></li></ul><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202215751.png" alt="stbl"></p><p>stbl Box 同样是 Container Box，使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleTableBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;stbl&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 0f 01</code> 表示该 <code>Box</code> 长度为 <code>3841</code> 字节</li><li>Box type: <code>0x73 74 62 6c</code> 这就是 <code>stbl</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li></ul></li><li>Box Data<ul><li>参见: <a href="#stsd">第六层 - stsd</a></li><li>参见: <a href="#stts">第六层 - stts</a></li><li>参见: <a href="#stss">第六层 - stss</a></li><li>参见: <a href="#stsc">第六层 - stsc</a></li><li>参见: <a href="#stsz">第六层 - stsz</a></li><li>参见: <a href="#stco">第六层 - stco</a></li></ul></li></ul><h2 id="第六层"><a href="#第六层" class="headerlink" title="第六层"></a>第六层</h2><h3 id="dref"><a href="#dref" class="headerlink" title="dref"></a>dref</h3><p><code>Container</code>: <code>Data Information Box</code> (<code>dinf</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>由于 <code>Track</code> 可以分为多个段，所以该 <code>Box</code> 是用来定义当前 <code>Track</code> 各个段的 <code>URL</code> 或 <code>URN</code>。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202130842.png" alt="dref"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">DataEntryUrlBox</span> <span class="params">(<span class="built_in">bit</span>(<span class="number">24</span>) flags)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;url&quot;</span>, version = <span class="number">0</span>, flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> location;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">DataEntryUrnBox</span> <span class="params">(<span class="built_in">bit</span>(<span class="number">24</span>) flags)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;urn&quot;</span>, version = <span class="number">0</span>, flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> location;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class DataReferenceBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;dref&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        DataEntryBox(entry_version, entry_flags) data_entry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 1c</code> 表示该 <code>Box</code> 长度为 <code>28</code> 字节</li><li>Box type: <code>0x64 72 65 66</code> 这就是 <code>dref</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>url</code> 列表数量是 <code>1</code>，只有一个 <code>url Box</code></li><li>URL Box 1<ul><li>Box Length: <code>0x00 00 00 0c</code> 表示该 <code>Box</code> 长度为 <code>12</code> 字节</li><li>Box type: <code>0x75 72 6c 20</code> 这就是 <code>&quot;url&quot;</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 01</code></li></ul></li></ul></li></ul><h3 id="stsd"><a href="#stsd" class="headerlink" title="stsd"></a>stsd</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>该 <code>Box</code> 存储了编码类型和初始化解码器需要的信息，于特定的 <code>track-type</code> 有关，根于不同的 <code>Track</code> 使用不一样的编码标准。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202220310.png" alt="stsd"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">abstract class <span class="title">SampleEntry</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) format)</span> extends <span class="title">Box</span><span class="params">(format)</span></span>&#123;</span><br><span class="line">    const unsigned int(8)[6] reserved = 0;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> data_reference_index</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">class BitRateBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;btrt&quot;</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> bufferSizeDB</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> maxBitrate</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> avgBitrate</span>;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">SampleDescriptionBox</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) handler_type)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsd&quot;</span>, version, <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;   <span class="comment">//sample description 数目, 同时不同的 Track 有不同的 sample description</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= entry_count ; i++)&#123;</span><br><span class="line">        SampleEntry(); <span class="comment">// an instance of a class derived from SampleEntry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 01 09</code> 表示该 <code>Box</code> 长度为 <code>265</code> 字节</li><li>Box type: <code>0x73 74 73 64</code> 这就是 <code>stsd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>Sample Description Box</code> 列表数量是 <code>1</code></li><li>Sample Description Box: 参见文档 ISO-IEC 14496-15 AVC file format</li></ul></li></ul><h3 id="stts"><a href="#stts" class="headerlink" title="stts"></a>stts</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 Box 是 <code>Sample number</code> 和解码时间 <code>DTS</code> 之间的映射表，通过这个表格，我们可以找到任何时间的 <code>Sample</code>，但用这个表格只是能找到当前时间的 <code>Sample</code> 的序号，<code>Sample</code> 的长度和指针还要靠其它表格获取。</p><p><code>Sample delta</code> 简单可以理解为采样点 <code>Sample</code> 的 <code>duration</code>，所有 <code>duration</code> 相加应该为总的 <code>Track</code> 的时长。大家把这个时间理解为该帧数据当前的解码时间即可，计算公式：</p><pre><code>DT(n+1) = DT(n) + STTS(n)</code></pre><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203130420.png" alt="stts"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class TimeToSampleBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stts&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_count</span>;  <span class="comment">// 连续相同时间长度 `sample delta` 的 `sample` 个数</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_delta</span>;  <span class="comment">// 每个 `sample delta` 以 `timescale` 为单位的时间长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 74 73</code> 这就是 <code>stts</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>sample conut</code> 和 <code>sample delta</code> 组成的二元组信息个数 列表数量是 <code>1</code></li><li>entry 1<ul><li>sample conut: <code>0x00 00 01 b0</code> 值为 <code>sample delta</code> 的 <code>sample</code> 个数为 <code>432</code> 个</li><li>sample delta: <code>0x00 00 02 00</code> 值为 <code>512</code>，这样我们计算出帧率就是 <code>12288/512</code> 即 <code>24fps</code>，参见 <a href="#mdhd">第四层 - mdhd</a>。</li></ul></li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203131946.png" alt="stts Mp4Explorer"></p><h3 id="ctts"><a href="#ctts" class="headerlink" title="ctts"></a>ctts</h3><h3 id="stss"><a href="#stss" class="headerlink" title="stss"></a>stss</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p><code>I</code> 帧是播放的起始位置，只有编码器拿到第一个 <code>I</code> 帧才能渲染出第一幅画面。所以后续的一些特殊随机操作，高标清切换时都需要找 <code>I</code> 帧，只有随机找到 <code>I</code> 帧才能完成这些特殊操作。</p><p>其中该 <code>Box</code> 就是存储了那些 <code>Sample</code> 是 <code>I</code> 帧，很显然音频 <code>Track</code> 也是不存在这个 <code>Box</code> 的。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203132044.png" alt="stss"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SyncSampleBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stss&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;           <span class="comment">// 关键帧的 sample 个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_number</span>;     <span class="comment">// 关键帧 sample 序号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 73 73</code> 这就是 <code>stss</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 02</code> 说明本文件有 <code>2</code> 个关键帧</li><li>sample number 1: <code>0x00 00 00 01</code> 关键帧 <code>1</code> 的 <code>Sample</code> 序号为 <code>1</code></li><li>sample number 2: <code>0x00 00 00 fb</code> 关键帧 <code>2</code> 的 <code>Sample</code> 序号为 <code>251</code></li></ul></li></ul><h3 id="stsc"><a href="#stsc" class="headerlink" title="stsc"></a>stsc</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p><p>这个 <code>Box</code> 就是说明那些 <code>Sample</code> 可以划分为一个 <code>Trunk</code></p><p>媒体数据被分为若干个 <code>Chunk</code>, <code>Chunk</code> 可以有不同的大小，同一个 <code>Chunk</code> 中的样点 <code>Sample</code> 也允许有不同的大小；通过本表可以定位一个样点的 <code>Chunk</code> 位置，并可以得知该 <code>MP4</code> 中有多少个 <code>Chunks</code>，每个 <code>Chunks</code> 有多少个 <code>Samples</code>。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203132226.png" alt="stsc"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleToChunkBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsc&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="comment">/* 具有相同采样点 sample 和 `sample_description_index 的 chunk 中，第一个 chunk 的索引值</span></span><br><span class="line"><span class="comment">        ** 也就是说该 chunk 索引值一直到下一个索引值之间的所有 chunk 都具有相同的 sample 个数</span></span><br><span class="line"><span class="comment">        ** 同时这些 sample 的描述 description 也一样； */</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> first_chunk</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> samples_per_chunk</span>;         <span class="comment">// 上面所有 chunk 的 sample 个数</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_description_index</span>;  <span class="comment">// 描述采样点的采样描述项的索引值，范围为 1 到样本描述表中的表项数目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 73 73</code> 这就是 <code>stss</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 00 01</code> 这说明三元组信息的个数只有 <code>1</code> 个</li><li>first chunk 1: <code>0x00 00 00 01</code> 具有相同 <code>Sample</code> 个数和 <code>description</code> 的 <code>Chunk</code> 起始索引是 <code>1</code></li><li>samples per chunk 1: <code>0x00 00 00 01</code> 每个 <code>Chunk</code> 具有的 <code>Sample</code> 的个数是 <code>1</code></li><li>sample description index 1 <code>0x00 00 00 01</code> 这些 <code>Sample</code> 的 <code>description index</code> 是 1，一般用默认值即可</li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203231441.png" alt="stsc Mp4Explorer"></p><h3 id="stsz"><a href="#stsz" class="headerlink" title="stsz"></a>stsz</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one variant must be present</code></p><p>前面分析了 <code>Sample</code> 的 <code>PTS</code>、<code>DTS</code> 等，也分析了 <code>Chunk</code> 里面 <code>Sample</code> 的信息，但是没有分析 <code>Sample</code> 的大小，这是我们在文件读取和解析 <code>Sample</code> 的关键。这里给出每个 <code>Sample</code> 的 <code>Size</code> 即包含的字节数。</p><p>包含了媒体中全部 <code>Sample</code> 的数目和一张给出每个 <code>Sample</code> 大小的表。这个 <code>Box</code> 相对来说体积是比较大的。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203233016.png" alt="stsz"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleSizeBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsz&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_size</span>;   <span class="comment">// 指定默认的 Sample 大小，如果每个 Sample 大小不相等，则这个字段值为 0，每个 Sample 大小存在下表中</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_count</span>;  <span class="comment">// 该 Track 中所有 Sample 的数量</span></span><br><span class="line">    <span class="keyword">if</span> (sample_size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sample_count; i++) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_size</span>;    <span class="comment">// 每个 Sample 的大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 06 d4</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 73 7a</code> 这就是 <code>stsz</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>sample size: <code>0x00 00 00 00</code> 说明 <code>Sample</code> 的具体大小在表后面项目中的 <code>entry size</code></li><li>sample count: <code>0x00 00 01 b0</code> 说明本 <code>Track</code> 的大小为 <code>432</code> 个 <code>Sample</code></li><li>entry size 1: <code>0x00 00 73 5f</code> 说明第一个 <code>Sample</code> 大小为 <code>29535</code> 字节</li><li>entry size 2: <code>0x00 00 06 e6</code> 说明第二个 <code>Sample</code> 大小为 <code>1766</code> 字节</li><li>entry size 3: <code>0x00 00 1f be</code> 说明第三个 <code>Sample</code> 大小为 <code>8126</code> 字节</li><li>entry size 4: <code>0x00 00 1b e2</code> 说明第四个 <code>Sample</code> 大小为 <code>7138</code> 字节</li><li>entry size 5: <code>0x00 00 25 eb</code> 说明第五个 <code>Sample</code> 大小为 <code>9707</code> 字节</li><li>…</li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203232256.png" alt="stsz Mp4Explorer"></p><h3 id="stco-co64"><a href="#stco-co64" class="headerlink" title="stco | co64"></a>stco | co64</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one variant must be present</code></p><p>该 <code>Box</code> 存储了 <code>Chunk Offset</code>，表示了每个 <code>Chunk</code> 在文件中的位置，这样我们就能找到了 <code>Chunk</code> 在文件的偏移量，然后根据其它表的关联关系就可以读取每个 <code>Sample</code> 的大小。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201204000004.png" alt="stco"></p><p>使用代码描述其结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class ChunkOffsetBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stco&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> chunk_offset</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class ChunkLargeOffsetBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;co64&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> chunk_offset</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Box Header<ul><li>Box Length: <code>0x00 00 06 d0</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li><li>Box type: <code>0x73 74 63 6f</code> 这就是 <code>stco</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li><li>Box version: <code>0x00</code></li><li>Box flags: <code>0x00 00 00</code></li></ul></li><li>Box Data<ul><li>entry count: <code>0x00 00 01 b0</code> 说明本 <code>Track</code> 的大小为 <code>432</code> 个 <code>Sample</code></li><li>chunk offset 1: <code>0x00 00 00 43</code> 说明本文件第一个 <code>Chunk</code> 的偏移量是 <code>67</code> 字节</li><li>chunk offset 2: <code>0x00 00 74 a2</code> 说明本文件第二个 <code>Chunk</code> 的偏移量是 <code>29858</code> 字节</li><li>chunk offset 3: <code>0x00 00 7e 35</code> 说明本文件第三个 <code>Chunk</code> 的偏移量是 <code>32309</code> 字节</li><li>chunk offset 4: <code>0x00 00 a0 53</code> 说明本文件第四个 <code>Chunk</code> 的偏移量是 <code>41043</code> 字节</li><li>chunk offset 5: <code>0x00 00 be 3f</code> 说明本文件第五个 <code>Chunk</code> 的偏移量是 <code>48703</code> 字节</li><li>…</li></ul></li></ul><p>通过 <code>Mp4Explorer</code> 验证分析结果:</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201204000821.png" alt="stco Mp4Explorer"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="/slave/MP4/ISO-IEC-14496-12-Base-Format-2015.pdf">ISO/IEC 14496-12</a></li><li>[2] <a href="/slave/MP4/ISO-IEC-14496-14-MP4-2003.pdf">ISO/IEC 14496-14</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;mp4&lt;/code&gt; 文件封装格式，对应的标准为 &lt;code&gt;ISO/IEC 14496-12&lt;/code&gt; 和 &lt;code&gt;ISO/IEC 14496-14&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ISO/IEC 14496-12&lt;/code&gt; 定义了一种封装媒体数据的基础文件格式，&lt;code&gt;mp4&lt;/code&gt;、&lt;code&gt;3gp&lt;/code&gt;、&lt;code&gt;ismv&lt;/code&gt; 等我们常见媒体封装格式都是以这种基础文件格式为基础衍生的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ISO/IEC 14496-14&lt;/code&gt; 基于 &lt;code&gt;ISO-14496-12&lt;/code&gt; 定义了 &lt;code&gt;mp4&lt;/code&gt; 文件格式。&lt;/p&gt;</summary>
    
    
    
    <category term="音视频封装" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
    <category term="MP4" scheme="http://github.hezhaojiang.io/tags/MP4/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - TS 封装解析示例</title>
    <link href="http://github.hezhaojiang.io/post/2020/a03a01c2/"/>
    <id>http://github.hezhaojiang.io/post/2020/a03a01c2/</id>
    <published>2020-11-27T08:13:10.000Z</published>
    <updated>2021-01-13T13:50:59.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章 <a href="/post/2020/c6ae0d94/" title="音视频封装 - TS 封装格式">音视频封装 - TS 封装格式</a> 中分析了 <code>TS</code> 流的结构，本文通过一段真实的码流的分析来加强对 <code>TS</code> 流结构的理解。</p><blockquote><p>注 1：本文中的 <code>TS</code> 码流截取自一段从网络下载的网络视频</p></blockquote><a id="more"></a><h2 id="PAT-包解析"><a href="#PAT-包解析" class="headerlink" title="PAT 包解析"></a>PAT 包解析</h2><p>该段码流中第一包并不是 <code>PAT</code> 包，而 TS 封装的解析需要从 <code>PAT</code> 包开始，所以我们向后寻找 PID 为 0 的第一包，该段码流中第二包 PID 为 0，是一个 <code>PAT</code> 包：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128145341.png" alt="Packet 2"></p><p>第一部分：<code>TS</code> 包头</p><pre><code>HEX 47       40       00       10BIN 01000111 01000000 00000000 00010000</code></pre><p>对比该部分结构，可代码定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_HEAD</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> sync_byte                    : <span class="number">8</span>;  <span class="comment">// 同步字节，固定为 0x47</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_error_indicator    : <span class="number">1</span>;  <span class="comment">// 传输错误指示符，0 表明在 TS 头的 adapt 域后没有无用字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> payload_unit_start_indicator : <span class="number">1</span>;  <span class="comment">// 负载单元起始标示符，一个完整的数据包开始时标记为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_priority           : <span class="number">1</span>;  <span class="comment">// 传输优先级，0 为低优先级</span></span><br><span class="line">    <span class="keyword">unsigned</span> pid                          : <span class="number">13</span>; <span class="comment">// PID 值，0 表示 TS 头后面就是 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_scrambling_controls    : <span class="number">2</span>;  <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> adaptation_field_control         : <span class="number">2</span>;  <span class="comment">// 是否包含自适应区，&#x27;01&#x27;为无自适应域，仅含有效负载</span></span><br><span class="line">    <span class="keyword">unsigned</span> continuity_counter               : <span class="number">4</span>;  <span class="comment">// 递增计数器，0-F，起始值不一定取 0，但必须是连续的</span></span><br><span class="line">&#125; TS_HEAD;</span><br></pre></td></tr></table></figure><p>第二部分：<code>TS</code> 包调整字节</p><pre><code>HEX 00BIN 00000000</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> adaptation_field_length;  <span class="comment">// 自适应域长度，后面的字节数，此包中为 7 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flag;                     <span class="comment">// 0x50 表示包含 PCR，0x40 表示不包含 PCR</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0x50</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> PCR[<span class="number">5</span>]; <span class="comment">// 节目时钟参考 40bit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字节，取值 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>adaptation_field_length</code> 为 <code>0</code>，故该部分后续字节数为 <code>0</code>。</p><p>第三部分：<code>TS</code> 包有效载荷 - 即 <code>PSI</code> 表 <code>PAT</code> 的数据：</p><pre><code>HEX 00 B0 0D 00 01 C1 00 00  00 01 F0 00 2A B1 04 B2BIN 00000000 10110000 00001101 00000000 00000001 11000001 00000000 00000000    00000000 00000001 11110000 00000000 00101010 10110001 00000100 10110010</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 固定 0x00 ，标志是该表是 PAT</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，0000 00001101 值为 13</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_stream_id          : <span class="number">16</span>; <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PAT 版本号，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 固定为 1，表示这个 PAT 表有效，如果为 0 则要等待下一个 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PAT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 最后一个分段的号码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PAT_Program&gt; program; = &#123;    <span class="comment">// 该包中仅有一个 TS_PAT_Program</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> program_number       :<span class="number">16</span>;  <span class="comment">// 节目号，为 0x0000 时表示这是 NIT，节目号为 0x0001 时, 表示这是 PMT</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved             :<span class="number">3</span>    <span class="comment">// 保留，固定为 111</span></span><br><span class="line">            <span class="keyword">if</span> (program_number == <span class="number">0x0000</span>)</span><br><span class="line">                <span class="keyword">unsigned</span> network_PID      :<span class="number">13</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (program_number == <span class="number">0x0001</span>)</span><br><span class="line">                <span class="keyword">unsigned</span> program_map_PID  :<span class="number">13</span>;  <span class="comment">// 节目号对应内容的 PID 值，该 PAT 包取值为 0x1000 = 4096</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PAT;</span><br></pre></td></tr></table></figure><h2 id="PMT-包解析"><a href="#PMT-包解析" class="headerlink" title="PMT 包解析"></a>PMT 包解析</h2><p><code>PAT</code> 信息中可知 <code>PMT</code> 表的 <code>PID</code> 为 <code>4096</code>，我们向后寻找 <code>PID</code> 为 <code>4096</code> 的 <code>TS</code> 包，发现第 <code>3</code> 包 <code>TS</code> 包即为 <code>PMT</code> 包：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128155219.png" alt="PMT"></p><p>第一部分：<code>TS</code> 包头</p><pre><code>HEX 47       50       00       10BIN 01000111 01010000 00000000 00010000</code></pre><p>从 <code>TS</code> 包头可知该 <code>TS</code> 包的 <code>PID</code> 值为 <code>4096</code>，是我们寻找的 <code>PMT</code> 包。</p><p>第二部分：<code>TS</code> 包调整字节，该部分只有一个字节 <code>0x00</code>，详见上文解析，此处不再重复。</p><p>第三部分：<code>TS</code> 包有效载荷 - <code>PMT</code></p><pre><code>HEX 02 B0 23 00 01 C1 00 00  E1 00 F0 00 24 E1 00 F0    06 05 04 48 45 56 43 03  E1 01 F0 06 0A 04 75 6E    64 00 DD 33 FC 6ABIN 00000010 10110000 00100011 00000000 00000001 11000001 00000000 00000000    11100001 00000000 11110000 00000000 00100100 11100001 00000000 11110000    00000110 00000101 00000100 01001000 01000101 01010110 01000011 00000011    11100001 00000001 11110000 00000110 00001010 00000100 01110101 01101110    01100100 00000000 11011101 00110011 11111100 01101010</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 取值随意，一般使用 0x02, 表示 PMT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，0000 00100011 = 35 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number               : <span class="number">16</span>; <span class="comment">// 当前 PMT 表映射到的节目号，1、2、3</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PMT 版本号码，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 发送的 PMT 表， 1 当前有效 PMT 有效</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PMT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 分段数</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_3                   : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> PCR_PID                      : <span class="number">13</span>; <span class="comment">// 指明 TS 包的 PID 值 (0x0100 = 256)，该 TS 包含有 PCR 同步时钟，</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_4                   : <span class="number">4</span>;  <span class="comment">// 预留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_info_length          : <span class="number">12</span>; <span class="comment">// 前 2bit 为 00，该域指出跟随其后对节目信息的描述的字节数 (0x000 = 0)。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;      <span class="comment">// 0 字节</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PMT_Stream&gt; PMT_Stream = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> stream_type          : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，H.265 编码对应 0x24</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved1            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">            <span class="keyword">unsigned</span> elementary_PID       : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值 (0x100 = 256)</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved2            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">            <span class="keyword">unsigned</span> ES_info_length       : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数 (0x006 = 6)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;   <span class="comment">// 6 字节</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> stream_type          : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，MP3 编码对应 0x03</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved1            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">            <span class="keyword">unsigned</span> elementary_PID       : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值 (0x101 = 257)</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved2            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">            <span class="keyword">unsigned</span> ES_info_length       : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数 (0x006 = 6)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;   <span class="comment">// 6 字节</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PMT;</span><br></pre></td></tr></table></figure><p><code>PMT</code> 是定义每路节目的音视频类型 <code>TYPE</code> 和编号 <code>PID</code> 的关键，该 <code>TS</code> 码流中：</p><pre><code>- 视频流格式为 `H.265`，对应 `PID` 为 `256`- 视频流格式为 `MP3`，对应 `PID` 为 `257`</code></pre><h2 id="视频包解析"><a href="#视频包解析" class="headerlink" title="视频包解析"></a>视频包解析</h2><p>第 <code>4</code> 包的 <code>PID</code> 值为 <code>256</code>，根据上述分析可知，该包为一个视频包：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128163234.png" alt="视频包"></p><p>第一部分：<code>TS</code> 包头</p><pre><code>HEX 47       41       00       30BIN 01000111 01000001 00000000 00110000</code></pre><p>从 <code>TS</code> 包头可知该 <code>TS</code> 包的 <code>PID</code> 值为 <code>256</code>，是我们寻找的视频包，另外，TS 包头中 <code>adaptation_field_control</code> 字段为 <code>11</code>，代表同时带有自适应域和有效负载。</p><p>第二部分：<code>TS</code> 包调整字节</p><pre><code>HEX 07 50 00 00 7C F7 7E 00BIN 00000111 01010000 00000000 00000000 01111100 11110111 01111110 00000000</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> adaptation_field_length;  <span class="comment">// 自适应域长度，后面的字节数，此包中为 7 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flag;                     <span class="comment">// 0x50 表示包含 PCR</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0x50</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> PCR[<span class="number">5</span>]; <span class="comment">// 节目时钟参考 40bit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字节，取值 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三部分：<code>TS</code> 包有效载荷 - <code>PES</code></p><pre><code>HEX 00 00 01 E0 00 00 80 80  05 21 00 07 E0 0DBIN 00000000 00000000 00000001 11100000 00000000 00000000 10000000 10000000    00000101 00100001 00000000 00000111 11100000 00001101</code></pre><p>对比该部分结构，代码定义分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> start_code_prefix        : <span class="number">24</span>; <span class="comment">// 包头起始码，固定为 0x000001</span></span><br><span class="line">    <span class="keyword">unsigned</span> stream_id;               : <span class="number">8</span>;  <span class="comment">// PES 包中的负载流类型，一般视频为 0xe0，音频为 0xc0</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_packet_length        : <span class="number">16</span>; <span class="comment">// PES 包长度，包括此字节后的可选包头和负载的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1               : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 10</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_scrambling_control   : <span class="number">2</span>;  <span class="comment">// 加密模式，00 未加密，01 或 10 或 11 由用户定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_priority             : <span class="number">1</span>;  <span class="comment">// 有效负载的优先级，值为 1 比值为 0 的负载优先级高</span></span><br><span class="line">    <span class="keyword">unsigned</span> Data_alignment_indicator : <span class="number">1</span>;  <span class="comment">// 数据定位指示器</span></span><br><span class="line">    <span class="keyword">unsigned</span> Copyright                : <span class="number">1</span>;  <span class="comment">// 版权信息，1 为有版权，0 无版权</span></span><br><span class="line">    <span class="keyword">unsigned</span> Original_or_copy         : <span class="number">1</span>;  <span class="comment">// 原始或备份，1 为原始，0 为备份</span></span><br><span class="line">    <span class="keyword">unsigned</span> PTS_DTS_flags            : <span class="number">2</span>;  <span class="comment">// PTS 和 DTS 标志位，10 表示首部有 PTS 字段，11 表示有 PTS 和 DTS 字段，00 表示都没有，01 被禁止</span></span><br><span class="line">    <span class="keyword">unsigned</span> ESCR_flag                : <span class="number">1</span>;  <span class="comment">// ESCR 标志，1 表示首部有 ESCR 字段，0 则无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> ES_rate_flag             : <span class="number">1</span>;  <span class="comment">// ES_rate 字段，1 表示首部有此字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> DSM_trick_mode_flag      : <span class="number">1</span>;  <span class="comment">// 1 表示有 8 位的 DSM_trick_mode_flag 字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> Additional_copy_info_flag: <span class="number">1</span>;  <span class="comment">// 1 表示首部有此字段，0 表示无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_CRC_flag             : <span class="number">1</span>;  <span class="comment">// 1 表示 PES 分组有 CRC 字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_extension_flag       : <span class="number">1</span>;  <span class="comment">// 扩展标志位，置 1 表示有扩展字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_header_data_length   : <span class="number">8</span>;  <span class="comment">// PES 首部中可选字段和填充字段的长度，可选字段的内容由上面 7 个 flags 来进行控制</span></span><br><span class="line">    if (PTS_DTS_flags == &#x27;10&#x27;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> reserved_1           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0010</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_32_30            : <span class="number">3</span>;  <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_29_15            : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_14_0             : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (PTS_DTS_flags == &#x27;11&#x27;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> reserved_1           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0011</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_32_30            : <span class="number">3</span>;  <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_29_15            : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_14_0             : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> reserved_2           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0001</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_32_30            : <span class="number">3</span>;  <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_29_15            : <span class="number">15</span>; <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_14_0             : <span class="number">15</span>; <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ESCR_flag) ...</span><br><span class="line">    <span class="keyword">if</span> (ES_rate_flag) ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (PES_extension_flag) ...</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字段，固定为 0xFF，不得超过 32 字节</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; PES_packet_data_byte <span class="comment">// PES 包的负载数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比代码和码流数据，发现码流中 <code>PES_packet_length</code> 值为 <code>0</code>，其表示 <code>PES</code> 分组长度要么没有规定要么没有限制。这种情况只允许出现在有效负载包含来源于传输流分组中某个视频基本流的字节的 <code>PES</code> 分组中。</p><p>该段视频流中 <code>PTS_DTS_flags == &#39;10&#39;</code>，故其还有 <code>5</code> 字节的 <code>PTS</code> 信息，我们尝试解析 <code>PTS</code> 信息：</p><ol><li><code>PTS</code> 的 <code>5</code> 字节信息为 <code>21 00 07 E0 0D</code>，对应二进制 <code>00100001 00000000 00000111 11100000 00001101</code></li><li>除去 <code>reserved</code> 和 <code>marker</code> 字段为 <code>000 00000000 0000011 11100000 0000110</code></li><li>整理可得 <code>0 00000000 00000001 11110000 00000110</code>，即 <code>0x001F006</code></li><li>转为十进制为 <code>126982</code>，与工具计算结果一致</li></ol><p><code>PES</code> 包头数据分析完，剩下的数据就是帧视频数据的一部分了。</p><h2 id="音频包解析"><a href="#音频包解析" class="headerlink" title="音频包解析"></a>音频包解析</h2><p>音频包与视频包均使用 <code>PES</code> 格式封装，解析方式基本一致，比如：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128192950.png" alt="音频包"></p><p>音频包中第三部分：<code>TS</code> 包有效载荷 - <code>PES</code></p><pre><code>HEX 00 00 01 C0 09 D3 80 80 05 21 00 07 D8 61 FFBIN 00000000 00000000 00000001 11000000 00001001 11010011 10000000 10000000    00000101 00100001 00000000 00000111 11011000 01010001 11111111</code></pre><p>该段视频流中 <code>PTS_DTS_flags == &#39;10&#39;</code>，故其也有 <code>5</code> 字节的 <code>PTS</code> 信息，我们尝试解析 <code>PTS</code> 信息：</p><ol><li><code>PTS</code> 的 <code>5</code> 字节信息为 <code>21 00 07 D8 61</code>，对应二进制 <code>00100001 00000000 00000111 11011000 01100001</code></li><li>除去 <code>reserved</code> 和 <code>marker</code> 字段为 <code>000 00000000 0000011 11011000 0110000</code></li><li>整理可得 <code>0 00000000 00000001 11101100 00110000</code>，即 <code>0x001EC30</code></li><li>转为十进制为 <code>126000</code>，与工具计算结果一致</li></ol><p><code>PES</code> 包头数据分析完，剩下的数据就音频数据的一部分了。</p><ul><li>[1] <a href="https://cloud.tencent.com/developer/article/1746983">音视频封装：MPTG2-TS 媒体封装实例解析和说明 - 云 + 社区 - 腾讯云</a></li><li>[2] <a href="/post/2020/c6ae0d94/" title="音视频封装 - TS 封装格式">音视频封装 - TS 封装格式</a></li><li>[3] <a href="https://github.com/daniep01/MPEG-2-Transport-Stream-Packet-Analyser">daniep01/MPEG-2-Transport-Stream-Packet-Analyser: MPEG-2 Transport Stream packet analyser…</a></li><li>[4] 文中 <code>TS</code> 码流视频源文件：<a href="/slave/TS/TestVideoTS.7z" title="密码：github.com">点击下载</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章 &lt;a href=&quot;/post/2020/c6ae0d94/&quot; title=&quot;音视频封装 - TS 封装格式&quot;&gt;音视频封装 - TS 封装格式&lt;/a&gt; 中分析了 &lt;code&gt;TS&lt;/code&gt; 流的结构，本文通过一段真实的码流的分析来加强对 &lt;code&gt;TS&lt;/code&gt; 流结构的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注 1：本文中的 &lt;code&gt;TS&lt;/code&gt; 码流截取自一段从网络下载的网络视频&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="音视频封装" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
    <category term="MPEG2-TS" scheme="http://github.hezhaojiang.io/tags/MPEG2-TS/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - TS 封装格式</title>
    <link href="http://github.hezhaojiang.io/post/2020/c6ae0d94/"/>
    <id>http://github.hezhaojiang.io/post/2020/c6ae0d94/</id>
    <published>2020-11-27T06:47:00.000Z</published>
    <updated>2021-01-13T13:50:55.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>TS</code> 全称是 <code>MPEG2-TS</code>，<code>MPEG2-TS</code> 是一种标准容器格式，传输与存储音视频、节目与系统信息协议数据，广泛应用于数字广播系统，我们日常数字机顶盒接收到的就是 <code>TS</code>（<code>Transport Stream</code>，传输流）流。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先需要先分辨 <code>TS</code> 传输流中几个基本概念：</p><ul><li><code>ES</code> (<code>Elementary Stream</code>)：基本流，直接从编码器出来的数据流，可以是编码过的音频、视频或其他连续码流</li><li><code>PES</code> (<code>Packetized Elementary Streams</code>)：<code>PES</code> 流是 <code>ES</code> 流经过 <code>PES</code> 打包器处理后形成的数据流，在这个过程中完成了将 <code>ES</code> 流分组、加入包头信息（<code>PTS</code>、<code>DTS</code> 等）操作。<code>PES</code> 流的基本单位是 <code>PES</code> 包，<code>PES</code> 包由包头和 payload 组成</li><li><code>PS</code> 流 (<code>Program Stream</code>)：节目流，PS 流由 PS 包组成，而一个 PS 包又由若干个 <code>PES</code> 包组成。一个 PS 包由具有同一时间基准的一个或多个 <code>PES</code> 包复合合成。</li><li><code>TS</code> 流 (<code>Transport Stream</code>)：传输流，<code>TS</code> 流由固定长度（<code>188</code> 字节）的 <code>TS</code> 包组成，<code>TS</code> 包是对 <code>PES</code> 包的另一种封装方式，同样由具有同一时间基准的一个或多个 <code>PES</code> 包复合合成。PS 包是不固定长度，而 <code>TS</code> 包为固定长度。</li></ul><h2 id="TS-文件"><a href="#TS-文件" class="headerlink" title="TS 文件"></a>TS 文件</h2><p><code>TS</code> 文件分为三次：<code>TS</code> 层、<code>PES</code> 层、<code>ES</code> 层。<code>ES</code> 层就是音视频数据，<code>PES</code> 层是在音视频数据上加了时间戳等数据帧的说明信息，<code>TS</code> 层是在 <code>PES</code> 层上加入了数据流识别和传输的必要信息。</p><pre><code>+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  TS   |  =  |  Packet 1 |  Packet 2 |  Packet 3 |    ...    | Packet n-1|  Packet n |+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+One Packet:          4bytes              184bytes+-+-+-+-+-+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Packet  | =  | Packet header |       Packet data       |+-+-+-+-+-+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><h2 id="TS-层"><a href="#TS-层" class="headerlink" title="TS 层"></a>TS 层</h2><p><code>TS</code> 包大小固定为 <code>188</code> 字节，<code>TS</code> 层分为三个部分：<code>TS header</code>、<code>adaptation field</code>、<code>payload</code>：</p><ul><li><code>TS header</code> 固定 <code>4</code> 个字节</li><li><code>adaptation field</code> 可能存在也可能不存在，主要作用是给不足 <code>188</code> 字节的数据做填充</li><li><p><code>payload</code> 是 <code>PES</code> 数据</p><p>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>  | TS header |  adaptation field |          payload(PES)       |<br>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p></li></ul><h3 id="TS-header"><a href="#TS-header" class="headerlink" title="TS header"></a>TS header</h3><pre><code>|0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|       ①       |②|③|④|             ⑤           | ⑥ | ⑦ |   ⑧   |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><div class="table-container"><table><thead><tr><th>序号</th><th>名称</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>sync_byte</td><td>8bit</td><td>同步字节，固定为 0x47</td></tr><tr><td>2</td><td>transport_error_indicator</td><td>1bit</td><td>传输错误指示符，表明在 TS 头的 adapt 域后由一个无用字节，通常都为 0，这个字节算在 adapt 域长度内</td></tr><tr><td>3</td><td>payload_unit_start_indicator</td><td>1bit</td><td>负载单元起始标示符，一个完整的数据包开始时标记为 1</td></tr><tr><td>4</td><td>transport_priority</td><td>1bit</td><td>传输优先级，0 为低优先级，1 为高优先级，通常取 0</td></tr><tr><td>5</td><td>PID</td><td>13bit</td><td>PID 值</td></tr><tr><td>6</td><td>transport_scrambling_control</td><td>2bit</td><td>传输加扰控制，00 表示未加密</td></tr><tr><td>7</td><td>adaptation_field_control</td><td>2bit</td><td>是否包含自适应区，’00’保留；’01’为无自适应域，仅含有效负载；’10’为仅含自适应域，无有效负载；’11’为同时带有自适应域和有效负载。</td></tr><tr><td>8</td><td>continuity_counter</td><td>4bit</td><td>递增计数器，从 0-f，起始值不一定取 0，但必须是连续的</td></tr></tbody></table></div><p><code>TS</code> 层的内容是通过 <code>PID</code> 值来标识的，主要内容包括：<code>PAT</code> 表、<code>PMT</code> 表、音频流、视频流。解析 <code>TS</code> 流要先找到 <code>PAT</code> 表，只要找到 <code>PAT</code> 就可以找到 <code>PMT</code>，然后就可以找到音视频流了。<code>PAT</code> 表和 <code>PMT</code> 表需要定期插入 <code>TS</code> 流，因为用户随时可能加入 <code>TS</code> 流，这个间隔比较小，通常每隔几个视频帧就要加入 <code>PAT</code> 和 <code>PMT</code>。<code>PAT</code> 和 <code>PMT</code> 表是必须的，还可以加入其它表如 <code>SDT</code>（业务描述表）等，不过 <code>HLS</code> 流只要有 <code>PAT</code> 和 <code>PMT</code> 就可以播放了。</p><ul><li><code>PAT</code> 表：他主要的作用就是指明了 <code>PMT</code> 表的 <code>PID</code> 值。</li><li><code>PMT</code> 表：他主要的作用就是指明了音视频流的 <code>PID</code> 值。</li><li>音频流 / 视频流：承载音视频内容。</li></ul><p><code>PID</code> 是 <code>TS</code> 流中唯一识别标志，<code>Packet Data</code> 是什么内容就是由 <code>PID</code> 决定的。下表给出了一些表的 PID 值：</p><div class="table-container"><table><thead><tr><th>表类型</th><th><code>PID</code> 值</th></tr></thead><tbody><tr><td>PAT</td><td>0x0000</td></tr><tr><td>CAT</td><td>0x0001</td></tr><tr><td>TSDT</td><td>0x0002</td></tr><tr><td>EIT,ST</td><td>0x0012</td></tr><tr><td>RST,ST</td><td>0x0013</td></tr></tbody></table></div><h3 id="adaptation-field"><a href="#adaptation-field" class="headerlink" title="adaptation field"></a>adaptation field</h3><div class="table-container"><table><thead><tr><th>名称</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td>adaptation_field_length</td><td>8bit</td><td>自适应域长度，后面的字节数（从 flag 开始）</td></tr><tr><td>flag</td><td>8bit</td><td>取 0x50 表示包含 PCR 或 0x40 表示不包含 PCR</td></tr><tr><td>PCR</td><td>40bit</td><td>Program Clock Reference，节目时钟参考，用于恢复出与编码端一致的系统时序时钟 STC（System Time Clock）。</td></tr><tr><td>stuffing_bytes</td><td>xbit</td><td>填充字节，取值 0xFF</td></tr></tbody></table></div><p>自适应区的长度要包含传输错误指示符标识的一个字节。<code>PCR</code> 是节目时钟参考，<code>PCR</code>、<code>DTS</code>、<code>PTS</code> 都是对同一个系统时钟的采样值，pcr 是递增的，因此可以将其设置为 <code>DTS</code> 值，音频数据不需要 <code>PCR</code>。如果没有字段，打包 <code>TS</code> 流时 <code>PAT</code> 和 <code>PMT</code> 表是没有 <code>adaptation field</code> 的，不够的长度直接补 <code>0xFF</code> 即可。视频流和音频流都需要加 <code>adaptation field</code>，通常加在一个帧的第一个 <code>TS</code> 包和最后一个 <code>TS</code> 包里，中间的 <code>TS</code> 包不加。</p><h3 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h3><p><code>Program Association Table</code> 节目关联表，每个 <code>TS</code> 流对应一张，用来描述该 <code>TS</code> 流中有多少个节目。</p><ul><li><code>TS</code> 流中中，<code>PAT</code> 包重复实现，大约 <code>0.5</code> 秒出现一个，保证实时解码性</li><li>表示 <code>PAT</code> 表的 <code>TS</code> 包 <code>PID</code> 值为 <code>0</code>，便于识别</li><li><code>PAT</code> 的 payload 中传送特殊 <code>PID</code> 的列表，每个 <code>PID</code> 对应一个节目（对应一张 <code>PMT</code> 表）</li><li><code>PAT</code> 表是 <code>TS</code> 流的基础，任何一个 <code>TS</code> 流解析寻找节目都是从 <code>PAT</code> 表开始查找</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT_Program</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number       :<span class="number">16</span>;  <span class="comment">// 节目号，为 0x0000 时表示这是 NIT，节目号为 0x0001 时, 表示这是 PMT</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved             :<span class="number">3</span>    <span class="comment">// 保留，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_map_PID      :<span class="number">13</span>;  <span class="comment">// 节目号对应内容的 PID 值</span></span><br><span class="line">&#125; TS_PAT_Program;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 固定 0x00 ，标志是该表是 PAT</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，表示从下一个字段开始到 CRC32(含) 之间有用的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_stream_id          : <span class="number">16</span>; <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PAT 版本号，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 固定为 1，表示这个 PAT 表有效，如果为 0 则要等待下一个 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PAT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 最后一个分段的号码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PAT_Program&gt; program;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PAT;</span><br></pre></td></tr></table></figure><h3 id="PMT"><a href="#PMT" class="headerlink" title="PMT"></a>PMT</h3><p><code>Program Map Table</code>，节目映射表，该表的 <code>PID</code> 是由 <code>PAT</code> 表 提供给出的。表征一路节目所有流信息。包含：</p><ol><li>当前节目中包含的所有 <code>Video</code> 数据的 <code>PID</code></li><li>当前节目中包含的所有 <code>Audio</code> 数据的 <code>PID</code></li><li>与当前节目关联在一起的其他数据的 <code>PID</code>（如数字广播, 数据通讯等使用的 <code>PID</code>）</li></ol><p>如果 <code>TS</code> 流中包含多个节目，那么就会有多个 <code>PMT</code> 表。只要我们处理了 <code>PMT</code> 表，那么我们就可以获取该节目中所有的流信息，如当前节目包含多少个 Video、多少个 <code>Audio</code> 和其他数据及每种数据对用的流 <code>PID</code> 分别是多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT_Stream</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> stream_type              : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，H.264 编码对应 0x1b，AAC 编码对应 0x0f，MP3 编码对应 0x03</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved1                : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> elementary_PID           : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved2                : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> ES_info_length           : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; descriptor;</span><br><span class="line">&#125; TS_PMT_Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 取值随意，一般使用 0x02, 表示 PMT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 固定为 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，表示从下一个字段开始到 CRC32(含) 之间有用的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number               : <span class="number">16</span>; <span class="comment">// 当前 PMT 表映射到的节目号，1、2、3</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PMT 版本号码，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 发送的 PMT 表 是当前有效还是下一个 PMT 有效</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PMT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 分段数</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_3                   : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> PCR_PID                      : <span class="number">13</span>; <span class="comment">// 指明 TS 包的 PID 值，该 TS 包含有 PCR 同步时钟，</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_4                   : <span class="number">4</span>;  <span class="comment">// 预留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_info_length          : <span class="number">12</span>; <span class="comment">// 前 2bit 为 00，该域指出跟随其后对节目信息的描述的字节数。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PMT_Stream&gt; PMT_Stream;</span><br><span class="line">    <span class="keyword">unsigned</span> reserved_5                   : <span class="number">3</span>;  <span class="comment">// 保留位，0x07</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_6                   : <span class="number">4</span>;  <span class="comment">// 保留位，0x0F</span></span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PMT;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;TS&lt;/code&gt; 全称是 &lt;code&gt;MPEG2-TS&lt;/code&gt;，&lt;code&gt;MPEG2-TS&lt;/code&gt; 是一种标准容器格式，传输与存储音视频、节目与系统信息协议数据，广泛应用于数字广播系统，我们日常数字机顶盒接收到的就是 &lt;code&gt;TS&lt;/code&gt;（&lt;code&gt;Transport Stream&lt;/code&gt;，传输流）流。&lt;/p&gt;</summary>
    
    
    
    <category term="音视频封装" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
    <category term="MPEG2-TS" scheme="http://github.hezhaojiang.io/tags/MPEG2-TS/"/>
    
  </entry>
  
  <entry>
    <title>善用佳软 - Vim 使用教程</title>
    <link href="http://github.hezhaojiang.io/post/2020/436448e4/"/>
    <id>http://github.hezhaojiang.io/post/2020/436448e4/</id>
    <published>2020-11-26T08:03:54.000Z</published>
    <updated>2021-01-13T14:01:53.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vim 是从 vi 发展出来的一个文本编辑器，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p><a id="more"></a><h2 id="Vim-模式介绍"><a href="#Vim-模式介绍" class="headerlink" title="Vim 模式介绍"></a>Vim 模式介绍</h2><p>Vim 具有 6 种基本模式和 5 种派生模式，我们这里只简单介绍下 6 种基本模式：</p><ul><li>普通模式 (Normal mode)</li></ul><p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是 Vim 启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p><ul><li>插入模式 (Insert mode)</li></ul><p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p><blockquote><p>在插入模式中，可以按 ESC 键回到普通模式。</p></blockquote><ul><li>可视模式 (Visual mode)</li></ul><blockquote><p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim 的 “文本对象” 也能和移动命令一样用在这个模式中。</p></blockquote><ul><li>选择模式 (Select mode)</li></ul><blockquote><p>这个模式和无模式编辑器的行为比较相似（Windows 标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim 会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p></blockquote><ul><li>命令行模式 (Command line mode)</li></ul><blockquote><p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（: 键），搜索（/ 和? 键）或者过滤命令（! 键）。在命令执行之后，Vim 返回到命令行模式之前的模式，通常是普通模式。</p></blockquote><ul><li>Ex 模式 (Ex mode)</li></ul><p>这和命令行模式比较相似，在使用 :visual 命令离开 Ex 模式前，可以一次执行多条命令。</p><blockquote><p>这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容</p></blockquote><h2 id="三种常用模式的切换"><a href="#三种常用模式的切换" class="headerlink" title="三种常用模式的切换"></a>三种常用模式的切换</h2><p>vim 启动进入普通模式，处于插入模式或命令行模式时只需要按 Esc 或者 Ctrl+[（这在 vim 课程环境中不管用）即可进入普通模式。普通模式中按 i（插入）或 a（附加）键都可以进入插入模式，普通模式中按 : 进入命令行模式。命令行模式中输入 wq 回车后保存并退出 vim。</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="游标移动"><a href="#游标移动" class="headerlink" title="游标移动"></a>游标移动</h3><p>普通模式，在该模式下使用方向键或者 h，j，k，l 键可以移动游标。</p><div class="table-container"><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右（小写 L）</td></tr><tr><td>j</td><td>下</td></tr><tr><td>k</td><td>上</td></tr><tr><td>w</td><td>移动到下一个单词</td></tr><tr><td>b</td><td>移动到上一个单词</td></tr></tbody></table></div><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><p>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在当前光标处进行编辑</td></tr><tr><td>I</td><td>在行首插入</td></tr><tr><td>A</td><td>在行末插入</td></tr><tr><td>a</td><td>在光标后插入编辑</td></tr><tr><td>o</td><td>在当前行后插入一个新行</td></tr><tr><td>O</td><td>在当前行前插入一个新行</td></tr><tr><td>cw</td><td>替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table></div><h3 id="保存文档"><a href="#保存文档" class="headerlink" title="保存文档"></a>保存文档</h3><p>从普通模式输入 : 进入命令行模式，输入 w 回车，保存文档。输入 :w <filename> 可以将文档另存为其他文件名或存到其它路径下。</p><h3 id="退出-vim"><a href="#退出-vim" class="headerlink" title="退出 vim"></a>退出 vim</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:q!</td><td>强制退出，不保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:wq!</td><td>强制保存并退出</td></tr><tr><td>:w <filename></td><td>另存为</td></tr><tr><td>:saveas 文件路径</td><td>另存为</td></tr><tr><td>:x</td><td>保存并退出</td></tr><tr><td>:wq</td><td>保存并退出</td></tr></tbody></table></div><p>普通模式下按下 Shift+zz 即可保存退出 vim。</p><h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除游标所在的字符</td></tr><tr><td>X</td><td>删除游标所在前一个字符</td></tr><tr><td>Delete</td><td>同 x</td></tr><tr><td>dd</td><td>删除整行</td></tr><tr><td>dw</td><td>删除一个单词（不适用中文）</td></tr><tr><td>d$ 或 D</td><td>删除至行尾</td></tr><tr><td>d^</td><td>删除至行首</td></tr><tr><td>dG</td><td>删除到文档结尾处</td></tr><tr><td>d1G</td><td>删至文档首部</td></tr></tbody></table></div><p>除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：2dd 表示一次删除 2 行。</p><h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><h3 id="游标的快速跳转"><a href="#游标的快速跳转" class="headerlink" title="游标的快速跳转"></a>游标的快速跳转</h3><h4 id="行间跳转"><a href="#行间跳转" class="headerlink" title="行间跳转"></a>行间跳转</h4><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>nG(n Shift+g) | 游标移动到第 n 行 (如果默认没有显示行号，请先进入命令模式，输入 :set nu 以显示行号)<br>gg | 游标移动到到第一行<br>G(Shift+g) | 到最后一行</p><blockquote><p>小技巧：你在完成依次跳转后，可以使用 Ctrl+o 快速回到上一次 (跳转前) 光标所在位置。</p></blockquote><h4 id="行内跳转"><a href="#行内跳转" class="headerlink" title="行内跳转"></a>行内跳转</h4><p>普通模式下使用下列命令在行内按照单词为单位进行跳转：</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>到下一个单词的开头</td></tr><tr><td>e</td><td>到当前单词的结尾</td></tr><tr><td>b</td><td>到前一个单词的开头</td></tr><tr><td>ge</td><td>到前一个单词的结尾</td></tr><tr><td>0 或 ^</td><td>到行头</td></tr><tr><td>$</td><td>到行尾</td></tr><tr><td>f &lt;字母&gt;</td><td>向后搜索 &lt; 字母 &gt; 并跳转到第一个匹配的位置 (非常实用)</td></tr><tr><td>F &lt;字母&gt;</td><td>向前搜索 &lt; 字母 &gt; 并跳转到第一个匹配的位置</td></tr><tr><td>t &lt;字母&gt;</td><td>向后搜索 &lt; 字母 &gt; 并跳转到第一个匹配位置之前的一个字母 (不常用)</td></tr><tr><td>T &lt;字母&gt;</td><td>向前搜索 &lt; 字母 &gt; 并跳转到第一个匹配位置之后的一个字母 (不常用)</td></tr></tbody></table></div><h3 id="复制粘贴和剪切"><a href="#复制粘贴和剪切" class="headerlink" title="复制粘贴和剪切"></a>复制粘贴和剪切</h3><h4 id="复制及粘贴文本"><a href="#复制及粘贴文本" class="headerlink" title="复制及粘贴文本"></a>复制及粘贴文本</h4><p>普通模式中使用 y 复制：</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>yy</td><td>复制游标所在的整行（3yy 表示复制 3 行）</td></tr><tr><td>y^</td><td>复制至行首，或 y0。不含光标所在处字符</td></tr><tr><td>y$</td><td>复制至行尾。含光标所在处字符</td></tr><tr><td>yw</td><td>复制一个单词</td></tr><tr><td>y2w</td><td>复制两个单词</td></tr><tr><td>yG</td><td>复制至文本末</td></tr><tr><td>y1G</td><td>复制至文本开头</td></tr></tbody></table></div><p>普通模式中使用 p 粘贴：</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>p</td><td>粘贴至光标后（下）</td></tr><tr><td>P</td><td>粘贴至光标前（上）</td></tr></tbody></table></div><h4 id="剪切及粘贴"><a href="#剪切及粘贴" class="headerlink" title="剪切及粘贴"></a>剪切及粘贴</h4><p>其实前面讲得 dd 删除命令就是剪切，你每次 dd 删除文档内容后，便可以使用 p 来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行。</p><p>ddp，就这么简单，即实现了快速交换光标所在行与它下面的行。</p><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="替换和撤销命令"><a href="#替换和撤销命令" class="headerlink" title="替换和撤销命令"></a>替换和撤销命令</h3><p>替换和撤销命令都是针对普通模式下的操作：</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>r+&lt;待替换字母&gt;</td><td>将游标所在字母替换为指定字母</td></tr><tr><td>R</td><td>连续替换，直到按下 Esc</td></tr><tr><td>cc</td><td>替换整行，即删除游标所在行，并进入插入模式</td></tr><tr><td>cw</td><td>替换一个单词，即删除一个单词，并进入插入模式</td></tr><tr><td>C(大写)</td><td>替换游标以后至行末</td></tr><tr><td>~</td><td>反转游标所在字母大小写</td></tr><tr><td>u{n}</td><td>撤销一次或 n 次操作</td></tr><tr><td>U(大写)</td><td>撤销当前行的所有修改</td></tr><tr><td>Ctrl+r</td><td>redo，即撤销 undo 的操作</td></tr></tbody></table></div><h3 id="快速缩进"><a href="#快速缩进" class="headerlink" title="快速缩进"></a>快速缩进</h3><h4 id="调整缩进"><a href="#调整缩进" class="headerlink" title="调整缩进"></a>调整缩进</h4><ul><li>普通模式下输入 &gt;&gt; 整行将向右缩进（使用，用于格式化代码超爽）</li><li>普通模式下输入 &lt;&lt; 整行向左回退</li><li>普通模式下输入 : 进入命令行模式下对 <code>shiftwidth</code> 值进行设置可以控制缩进和回退的字符数<ul><li>获取目前的设定值 <code>:set shiftwidth?</code></li><li>设置缩进为 10 个字符 <code>:set shiftwidth=10</code></li></ul></li></ul><h4 id="调整文本位置"><a href="#调整文本位置" class="headerlink" title="调整文本位置"></a>调整文本位置</h4><ul><li>命令行模式下输入 :ce(center) 命令使本行内容居中：</li><li>命令行模式下输入 :ri(right) 命令使本行文本靠右：</li><li>命令行模式下输入 le(left) 命令使本行内容靠左：</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h4><p>普通模式下输入 / 然后键入需要查找的字符串，按回车后就会进行查找。? 与 / 功能相同，只不过 ? 是向上而 / 是向下查找。</p><p>进入查找之后，输入 n 和 N 可以继续查找。n 是查找下一个内容，N 查找上一个内容。</p><h4 id="高级查找"><a href="#高级查找" class="headerlink" title="高级查找"></a>高级查找</h4><ul><li>普通模式下输入 * 寻找游标所在处的单词</li><li>普通模式下输入 # 同上，但 # 是向前（上）找，* 则是向后（下）找</li><li>普通模式下输入 g* 同 *，但部分符合该单词即可</li><li>普通模式下输入 g# 同 #，但部分符合该单词即可</li></ul><p>以上查找 n，N 的继续查找命令依然可以用。</p><h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="视窗操作"><a href="#视窗操作" class="headerlink" title="视窗操作"></a>视窗操作</h3><div class="table-container"><table><thead><tr><th>模式</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>命令行模式</td><td>:sp 1.txt</td><td>打开新的水平分屏视窗来编辑 1.txt</td></tr><tr><td>命令行模式</td><td>:vsp 2.txt</td><td>打开新的垂直分屏视窗来编辑 2.txt</td></tr><tr><td>普通模式</td><td>Ctrl+w s</td><td>将当前窗口分割成两个水平的窗口</td></tr><tr><td>普通模式</td><td>Ctrl+w v</td><td>将当前窗口分割成两个垂直的窗口</td></tr><tr><td>普通模式</td><td>Ctrl+w q</td><td>即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</td></tr><tr><td>普通模式</td><td>Ctrl+w o</td><td>打开一个视窗并且隐藏之前的所有视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w j</td><td>移至下面视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w k</td><td>移至上面视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w h</td><td>移至左边视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w l</td><td>移至右边视窗</td></tr><tr><td>普通模式</td><td>Ctrl+w J</td><td>将当前视窗移至下面</td></tr><tr><td>普通模式</td><td>Ctrl+w K</td><td>将当前视窗移至上面</td></tr><tr><td>普通模式</td><td>Ctrl+w H</td><td>将当前视窗移至左边</td></tr><tr><td>普通模式</td><td>Ctrl+w L</td><td>将当前视窗移至右边</td></tr><tr><td>普通模式</td><td>Ctrl+w -</td><td>减小视窗的高度</td></tr><tr><td>普通模式</td><td>Ctrl+w +</td><td>增加视窗的高度</td></tr></tbody></table></div><h3 id="文档加密"><a href="#文档加密" class="headerlink" title="文档加密"></a>文档加密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建加密文档</span></span><br><span class="line">vim -x filename</span><br></pre></td></tr></table></figure><p>输入您的密码，确认密码，这样在下一次打开时，vim 就会要求你输入密码。</p><h3 id="在-vim-执行外部命令"><a href="#在-vim-执行外部命令" class="headerlink" title="在 vim 执行外部命令"></a>在 vim 执行外部命令</h3><p>在命令行模式中输入 ! 可以执行外部的 shell 命令，如：</p><ul><li>:!ls 用于显示当前目录的内容</li><li>:!rm filename 用于删除名为 filename 的文件</li><li>:w filename 可将当前 vim 中正在编辑的文件另存为 filename 文件</li></ul><h3 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h3><ul><li>普通模式下按 F1 打开 vim 自己预设的帮助文档</li><li>命令行模式下输入 :h shiftwidth 打开名为 shiftwidth 的帮助文件</li><li>命令行模式下输入 :ver 显示版本及参数</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.lanqiao.cn/courses/2">Vim 基础入门 - 蓝桥</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vim 是从 vi 发展出来的一个文本编辑器，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。&lt;/p&gt;</summary>
    
    
    
    <category term="工具软件" scheme="http://github.hezhaojiang.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Vim" scheme="http://github.hezhaojiang.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>流媒体传输 - HLS 协议</title>
    <link href="http://github.hezhaojiang.io/post/2020/f5bbcc60/"/>
    <id>http://github.hezhaojiang.io/post/2020/f5bbcc60/</id>
    <published>2020-11-22T06:41:05.000Z</published>
    <updated>2021-01-13T13:57:46.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>HLS</code> 全称是 <code>HTTP Live Streaming</code>，是一个由 <code>Apple</code> 公司提出的基于 <code>HTTP</code> 的媒体流传输协议，用于实时音视频流的传输。目前 <code>HLS</code> 协议被广泛的应用于视频点播和直播领域。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>通过将整条流切割成一个小的可以通过 <code>HTTP</code> 下载的媒体文件, 然后提供一个配套的媒体列表文件, 提供给客户端, 让客户端顺序地拉取这些媒体文件播放, 来实现看上去是在播放一条流的效果. 由于传输层协议只需要标准的 <code>HTTP</code> 协议, HLS 可以方便的透过防火墙或者代理服务器, 而且可以很方便的利用 CDN 进行分发加速, 并且客户端实现起来也很方便.</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><code>HLS</code> 的架构分为三部分：Server，CDN，Client 。即服务器、分发组件和客户端。</p><p>下面是 <code>HLS</code> 整体架构图：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201122225230.png" alt="HLS 整体架构图"></p><p>服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。</p><p>分发组件为标准的 Web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。</p><p>客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。</p><h2 id="HLS-协议分析"><a href="#HLS-协议分析" class="headerlink" title="HLS 协议分析"></a>HLS 协议分析</h2><h3 id="HLS-Playlist"><a href="#HLS-Playlist" class="headerlink" title="HLS Playlist"></a>HLS Playlist</h3><p>其实, <code>HLS</code> 协议的主要内容是关于 <code>M3U8</code> 这个文本协议的, 其实生成与解析都非常简单. 为了更加直接地说明这一点, 我下面举两个简单的例子:</p><p>简单的 <code>Media Playlist</code>：</p><pre><code>#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:8#EXT-X-MEDIA-SEQUENCE:2680#EXTINF:7.975,https://priv.example.com/fileSequence2680.ts#EXTINF:7.941,https://priv.example.com/fileSequence2681.ts#EXTINF:7.975,https://priv.example.com/fileSequence2682.ts</code></pre><p>包含多种比特率的 <code>Master Playlist</code>：</p><pre><code>#EXTM3U#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1280000http://example.com/low.m3u8#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2560000http://example.com/mid.m3u8#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=7680000http://example.com/hi.m3u8#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=65000,CODECS=&quot;mp4a.40.5&quot;http://example.com/audio-only.m3u8</code></pre><ul><li><code>HLS</code> 通过 <code>URI(RFC3986)</code> 指向的一个 <code>Playlist</code> 来表示一个媒体流</li><li>一个 <code>Playlist</code> 可以是一个 <code>Media Playlist</code> 或者 <code>Master Playlist</code>, 使用 <code>UTF-8</code> 编码的文本文件, 包含一些 <code>URI</code> 跟描述性的 <code>tags</code></li><li>一个 <code>Media Playlist</code> 包含一个 <code>Media Segments</code> 列表,当顺序播放时, 能播放整个完整的流</li><li>要想播放这个 <code>Playlist</code>, 客户端需要首先下载他, 然后播放里面的每一个 <code>Media Segment</code></li><li><p>更加复杂的情况是, <code>Playlist</code> 是一个 <code>Master Playlist</code>, 包含一个 <code>Variant Stream</code> 集合, 通常每个 <code>Variant Stream</code> 里面是同一个流的多个不同版本(如: 分辨率, 码率不同)</p></li><li><p>一个 <code>Playlist</code> 文件必须通过 <code>URI(.m3u8 或 m3u)</code> 或者 <code>HTTP Content-Type</code> 来识别 (<code>application/vnd.apple.mpegurl</code> 或 <code>audio/mpegurl</code>)</p></li><li>换行符可以用 <code>\n</code> 或者 <code>\r\n</code></li><li>以 <code>#</code> 开头的是 <code>tag</code> 或者注释, 以 <code>#EXT</code> 开头的是 <code>tag</code>, 其余的为注释, 在解析时应该忽略</li><li><code>Playlist</code> 里面的 <code>URI</code> 可以用绝对地址或者相对地址, 如果使用相对地址, 那么是相对于 <code>Playlist</code> 文件的地址</li></ul><h3 id="HLS-Media-Segments"><a href="#HLS-Media-Segments" class="headerlink" title="HLS Media Segments"></a>HLS Media Segments</h3><ul><li>每一个 <code>Media Segment</code> 通过一个 <code>URI</code> 指定, 可能包含一个 <code>byte range</code></li><li>每一个 <code>Media Segment</code> 的 <code>duration</code> 通过 <code>EXTINF</code> <code>tag</code> 指定</li><li>每一个 <code>Media Segment</code> 有一个唯一的整数 <code>Media Segment Number</code></li><li>有些媒体格式需要一个 <code>format-specific sequence</code> 来初始化一个 <code>parser</code>, 在 <code>Media Segment</code> 被 <code>parse</code> 之前. 这个字段叫做 <code>Media Initialization Section</code>, 通过 <code>EXT-X-MAP</code> <code>tag</code> 来指定. 支持的 <code>Media Segment</code> 格式</li></ul><h3 id="HLS-TAGS"><a href="#HLS-TAGS" class="headerlink" title="HLS TAGS"></a>HLS TAGS</h3><ul><li><code>Basic Tags</code> : 用在 <code>Media Playlist</code> 和 <code>Master Playlist</code> 里面<ul><li><code>EXTM3U</code>: 必须在文件的第一行, 标识是一个 <code>Extended M3U Playlist</code> 文件</li><li><code>EXT-X-VERSION</code>: 表示 <code>Playlist</code> 兼容的版本</li></ul></li><li><code>Media Segment Tags</code> : 只能出现在 <code>Media Playlist</code> 里面<ul><li><code>EXTINF</code>: 用于指定 <code>Media Segment</code> 的 <code>duration</code></li><li><code>EXT-X-BYTERANGE</code>: 用于指定 <code>URI</code> 的 <code>sub-range</code></li><li><code>EXT-X-DISCONTINUITY</code>: 表示不连续</li><li><code>EXT-X-KEY</code>: 表示 <code>Media Segment</code> 已加密, 该值用于解密</li><li><code>EXT-X-MAP</code>: 用于指定 <code>Media Initialization Section</code></li><li><code>EXT-X-PROGRAM-DATE-TIME</code>: 和 <code>Media Segment</code> 的第一个 <code>sample</code> 一起来确定时间戳</li><li><code>EXT-X-DATERANGE</code>: 将一个时间范围和一组属性键值对结合到一起</li></ul></li><li><code>Media Playlist tags</code> : 只能出现在 <code>Media Playlist</code> 里面<ul><li><code>EXT-X-TARGETDURATION</code>: 用于指定最大的 <code>Media Segment duration</code></li><li><code>EXT-X-MEDIA-SEQUENCE</code>: 用于指定第一个 <code>Media Segment</code> 的 <code>Media Sequence Number</code></li><li><code>EXT-X-DISCONTINUITY-SEQUENCE</code>: 用于不同 <code>Variant Stream</code> 之间同步</li><li><code>EXT-X-ENDLIST</code>: 表示结束</li><li><code>EXT-X-PLAYLIST-TYPE</code>: 可选, 指定整个 <code>Playlist</code> 的类型</li><li><code>EXT-X-I-FRAMES-ONLY</code>: 表示每个 <code>Media Segment</code> 描述一个单一的 <code>I-frame</code></li></ul></li><li><code>Master Playlist tags</code> : 只能出现在 <code>Master Playlist</code> 中<ul><li><code>EXT-X-MEDIA</code>: 用于关联同一个内容的多个 <code>Media Playlist</code> 的多种 <code>renditions</code></li><li><code>EXT-X-STREAM-INF</code>: 用于指定一个 <code>Variant Stream</code></li><li><code>EXT-X-I-FRAME-STREAM-INF</code>: 用于指定一个 <code>Media Playlist</code> 包含媒体的 <code>I-frames</code></li><li><code>EXT-X-SESSION-DATA</code>: 存放一些 <code>session</code> 数据</li><li><code>EXT-X-SESSION-KEY</code>: 用于解密</li></ul></li><li><code>Media or Master Playlist Tags</code> : 可以出现在 <code>Media Playlist</code> 或者 <code>Master Playlist</code> 中，但是如果同时出现在同一个 <code>Master Playlist</code> 和 <code>Media Playlist</code> 中时，必须为相同值<ul><li><code>EXT-X-INDEPENDENT-SEGMENTS</code>: 表示每个 <code>Media Segment</code> 可以独立解码</li><li><code>EXT-X-START</code>: 标识一个优选的点来播放这个 <code>Playlist</code></li></ul></li></ul><h2 id="HLS-播放"><a href="#HLS-播放" class="headerlink" title="HLS 播放"></a>HLS 播放</h2><h3 id="播放未加密-HLS"><a href="#播放未加密-HLS" class="headerlink" title="播放未加密 HLS"></a>播放未加密 HLS</h3><p>我们通过 <code>VLC</code> 播放器播放苹果官方提供的一个例子：<code>http://devimages.apple.com/iphone/samples/bipbop/gear1/prog_index.m3u8</code>，并使用 <code>Wirshark</code> 对其中交互进行抓包。</p><pre><code>GET /iphone/samples/bipbop/gear1/prog_index.m3u8 HTTP/1.1Host: devimages.apple.comAccept: */*Accept-Language: zh_CNUser-Agent: VLC/3.0.8 LibVLC/3.0.8Range: bytes=0-    HTTP/1.1 206 Partial Content    Accept-Ranges: bytes    Content-Type: audio/x-mpegurl    ETag: &quot;50117c8233644c19b5ab49551b72507f:1239907352&quot;    Last-Modified: Thu, 16 Apr 2009 18:42:32 GMT    Server: AkamaiNetStorage    Date: Sun, 22 Nov 2020 15:01:49 GMT    Content-Range: bytes 0-7018/7019    Content-Length: 7019    X-Cache: TCP_MEM_HIT from a184-26-91-45.deploy.akamaitechnologies.com (AkamaiGHost/10.2.0.2-31441410) (-)    Connection: keep-alive    #EXTM3U    #EXT-X-TARGETDURATION:10    #EXT-X-MEDIA-SEQUENCE:0    #EXTINF:10, no desc    fileSequence0.ts    #EXTINF:10, no desc    fileSequence1.ts    #EXTINF:10, no desc    fileSequence2.ts    #EXTINF:10, no desc    ......    #EXTINF:1, no desc    fileSequence180.ts    #EXT-X-ENDLIST</code></pre><p>我们可以看到返回的 <code>M3U8</code> 里面他有一个一个 <code>ts</code> 视频片段，这个一个一个视频片段就是我们需要的播放的视频片段。</p><p><code>#EXTINF</code> 表示每个 <code>ts</code> 切片视频文件的时长。<br><code>#EXT-X-TARGETDURATION</code> 指定当前视频流中的切片文件的最大时长，也就是说这些 <code>ts</code> 切片的时长不能大于 <code>#EXT-X-TARGETDURATION</code> 的值。<br><code>#EXT-X-MEDIA-SEQUENCE</code> 第一个 <code>ts</code> 分片的序列号<br><code>#EXT-X-ENDLIST</code> 这个表示视频结束，有这个标志同时也说明当前的流是一个非直播流。<br><code>#EXT-X-PLAYLIST-TYPE:VOD</code> 的意思是当前的视频流并不是一个直播流，而是点播流，换句话说就是该视频的全部的 <code>ts</code> 文件已经被生成好了<br><code>#EXT-X-ALLOW-CACHE</code> 是否允许 <code>cache</code></p><h3 id="播放加密-HLS"><a href="#播放加密-HLS" class="headerlink" title="播放加密 HLS"></a>播放加密 HLS</h3><h2 id="HLS-协议总结"><a href="#HLS-协议总结" class="headerlink" title="HLS 协议总结"></a>HLS 协议总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>客户端支持简单, 只需要支持 <code>HTTP</code> 请求即可, <code>HTTP</code> 协议无状态, 只需要按顺序下载媒体片段即可。</li><li>使用 <code>HTTP</code> 协议网络兼容性好, <code>HTTP</code> 数据包也可以方便地通过防火墙或者代理服务器, <code>CDN</code> 支持良好。</li><li><code>Apple</code> 的全系列产品支持，不需要安装任何插件就可以原生支持播放 <code>HLS</code>, 目前 <code>Android</code> 也加入了对 <code>HLS</code> 的支持。</li><li>自带多码率自适应机制。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相比 <code>RTMP</code> 这类长连接协议, 延时较高, 难以用到互动直播场景。</li><li>对于点播服务来说, 由于 <code>TS</code> 切片通常较小, 海量碎片在文件分发, 一致性缓存, 存储等方面都有较大挑战。</li></ul><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li>由于客户端每次请求 <code>TS</code> 或 <code>M3U8</code> 有可能一个新的连接请求, 无法有效的标识客户端, 一旦出现问题, 基本无法有效的定位问题。</li><li>一般工业级的服务器都会对传统的 <code>HLS</code> 做一些改进，常见优化是对每个 <code>M3U8</code> 文件增加 <code>Session</code> 来标识一条 <code>HLS</code> 连接。</li><li>不管通过哪种方式, 最终我们都能通过一个唯一的 <code>id</code> 来标识一条流, 这样在排查问题时就可以根据这个 <code>id</code> 来定位播放过程中的问题。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.cnblogs.com/renhui/p/8081869.html">流媒体协议（一）：HLS 协议 - 灰色飘零 - 博客园</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;HLS&lt;/code&gt; 全称是 &lt;code&gt;HTTP Live Streaming&lt;/code&gt;，是一个由 &lt;code&gt;Apple&lt;/code&gt; 公司提出的基于 &lt;code&gt;HTTP&lt;/code&gt; 的媒体流传输协议，用于实时音视频流的传输。目前 &lt;code&gt;HLS&lt;/code&gt; 协议被广泛的应用于视频点播和直播领域。&lt;/p&gt;</summary>
    
    
    
    <category term="流媒体传输" scheme="http://github.hezhaojiang.io/categories/%E6%B5%81%E5%AA%92%E4%BD%93%E4%BC%A0%E8%BE%93/"/>
    
    
    <category term="HLS" scheme="http://github.hezhaojiang.io/tags/HLS/"/>
    
  </entry>
  
  <entry>
    <title>后端开发日记 - 检查内存泄漏</title>
    <link href="http://github.hezhaojiang.io/post/2020/f517d3b0/"/>
    <id>http://github.hezhaojiang.io/post/2020/f517d3b0/</id>
    <published>2020-11-19T07:54:19.000Z</published>
    <updated>2021-01-13T14:03:33.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内存泄漏一般是由于程序在堆上分配了内存而没有释放，随着程序的运行占用的内存越来越大，一方面会影响程序的稳定性，可能让运行速度越来越慢，或者造成 <code>OOM</code>，甚至会影响程序所运行的机器的稳定性，造成宕机。</p><p>而分析内存问题的常用工具有 <code>valgrind</code> 和 <code>gperftools</code> 等，当然也可以自行开发钩子函数，本文主要介绍 <code>gperftools</code> 来进行内存泄漏的分析。</p><a id="more"></a><h2 id="安装-gperftools"><a href="#安装-gperftools" class="headerlink" title="安装 gperftools"></a>安装 gperftools</h2><p>首先是一些依赖环境的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## libunwind 64 位系统必选</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libunwind/libunwind.git</span><br><span class="line"><span class="built_in">cd</span> libunwind</span><br><span class="line">sh ./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成 PDF 可视化必选</span></span><br><span class="line">sudo apt-get install graphviz graphviz-doc</span><br><span class="line">sudo yum install graphviz graphviz-doc</span><br><span class="line">sudo yum install ghostscript</span><br></pre></td></tr></table></figure><p>然后就可以安装 <code>gperftools</code> 工具了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gperftools/gperftools.git</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完成后，如果程序运行环境与编译环境不是同一台主机，需要拷贝出一些成果物放置到合适的位置，主要成果物包括：</p><ol><li><code>lib</code> 文件，需要放在运行环境中<ul><li><code>libunwind.so.8</code></li><li><code>libtcmalloc.so.4</code></li></ul></li><li>头文件，需要放在代码中方便集中管理<ul><li><code>heap-checker.h</code></li><li><code>heap-profiler.h</code></li></ul></li><li>工具文件，可以放在编译环境中使用，也可以拷贝到其他主机上使用<ul><li><code>pprof</code></li></ul></li></ol><h2 id="使用-gperftools"><a href="#使用-gperftools" class="headerlink" title="使用 gperftools"></a>使用 gperftools</h2><p><code>gperftools</code> 提供了 <code>4</code> 个工具：</p><ul><li><code>thread-caching malloc</code> : 简称 <code>tcmalloc</code>，可以用来替代 <code>glibc</code> 中原有的 <code>malloc/free</code>、<code>new/delete</code> 等函数</li><li><code>heap-checking using tcmalloc</code> : 用来检查程序中的内存泄漏位置，适用于 <code>C++</code></li><li><code>heap-profiling using tcmalloc</code> : 用来统计程序中的内存申请、释放情况，可用于检查内存使用情况和泄漏情况，适用于 <code>C/C++</code>，可应用于所有可执行文件</li><li><code>CPU profiler</code> : 用来统计程序中每个部分占用 CPU 性能情况，用于程序 CPU 性能的观察和优化</li></ul><p>以上 <code>4</code> 个工具中，用于分析内存泄漏的有两个工具：<code>heap-checking using tcmalloc</code> 和 <code>heap-profiling using tcmalloc</code></p><h3 id="使用-heap-checking"><a href="#使用-heap-checking" class="headerlink" title="使用 heap-checking"></a>使用 heap-checking</h3><p>使用 <code>heap-checking</code> 有两种方式，一种是设置环境变量的方法，一种是修改代码的方法</p><h4 id="设置环境变量来使用-heap-checking"><a href="#设置环境变量来使用-heap-checking" class="headerlink" title="设置环境变量来使用 heap-checking"></a>设置环境变量来使用 heap-checking</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env LD_PRELOAD=<span class="string">&quot;/usr/lib/libtcmalloc.so&quot;</span></span><br><span class="line"><span class="comment">## 假设我们要检查的程序是 /usr/local/bin/my_binary_compiled_with_tcmalloc</span></span><br><span class="line">env HEAPCHECK=normal /usr/<span class="built_in">local</span>/bin/my_binary_compiled_with_tcmalloc</span><br></pre></td></tr></table></figure><ol><li>minimal</li><li>normal</li><li>strict</li><li>draconian</li></ol><p>“minimal”：堆检查在初始化中尽可能晚地开始，这意味着您可以在初始化例程中泄漏一些内存，并且不会触发泄漏消息。如果您经常在一次全局初始化中故意泄漏数据，则 “minimal” 模式对您非常有用。否则，应使用更严格的模式。</p><p>“normal” 堆检查跟踪活动对象，并报告程序退出时无法通过活动对象访问的任何数据的泄漏，是谷歌最常用的模式，适用于日常堆检查使用。</p><p>“strict” 堆检查很像 “normal”，但有一些额外的检查，即内存不会丢失在全局析构函数中。特别是，如果您有一个全局变量，该变量在程序执行期间分配内存，然后在全局析构函数中 “forgets” 内存（例如，将指针设置为 NULL），这将在 “strict” 模式下提示泄漏消息，而在 “normal” 模式下并不会进行提示。</p><p>“draconian” 堆检查适合那些喜欢非常精确地了解其内存管理，并且希望堆检查器帮助他们实施它的人。在 “draconian” 模式下，堆检查器不会执行 “live object” 检查，因此除非在程序退出之前释放了所有分配的内存，它都会报告泄漏。</p><h4 id="修改代码来使用-heap-checking"><a href="#修改代码来使用-heap-checking" class="headerlink" title="修改代码来使用 heap-checking"></a>修改代码来使用 heap-checking</h4><blockquote><p>可参考：<a href="https://gperftools.github.io/gperftools/heap_checker.html">https://gperftools.github.io/gperftools/heap_checker.html</a></p></blockquote><h3 id="分析-heap-checking-输出"><a href="#分析-heap-checking-输出" class="headerlink" title="分析 heap-checking 输出"></a>分析 heap-checking 输出</h3><h3 id="使用-heap-profiling"><a href="#使用-heap-profiling" class="headerlink" title="使用 heap-profiling"></a>使用 heap-profiling</h3><p>与 <code>heap-checking</code> 一样，<code>heap-profiling</code> 也有同样的两种方法来使用</p><h4 id="设置环境变量来使用-heap-profiling"><a href="#设置环境变量来使用-heap-profiling" class="headerlink" title="设置环境变量来使用 heap-profiling"></a>设置环境变量来使用 heap-profiling</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env LD_PRELOAD=<span class="string">&quot;/usr/lib/libtcmalloc.so&quot;</span></span><br><span class="line"><span class="comment">## 假设我们要检查的程序是 /usr/local/bin/my_binary_compiled_with_tcmalloc</span></span><br><span class="line">env HEAPPROFILE=/tmp/mybin.hprof /usr/<span class="built_in">local</span>/bin/my_binary_compiled_with_tcmalloc</span><br></pre></td></tr></table></figure><p>除了以上环境变量，还有一些环境变量可以设置：</p><div class="table-container"><table><thead><tr><th>环境变量</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>HEAP_PROFILE_ALLOCATION_INTERVAL</td><td>1073741824 (1GB)</td><td>每次程序分配指定字节数时，转储堆分析信息。</td></tr><tr><td>HEAP_PROFILE_INUSE_INTERVAL</td><td>104857600(100M)</td><td>每当高水位内存使用标记增加指定字节数时，转储堆分析信息。</td></tr><tr><td>HEAP_PROFILE_TIME_INTERVAL</td><td>0</td><td>每次经过指定的秒数时转储堆分析信息。</td></tr><tr><td>HEAPPROFILESIGNAL</td><td>已禁用</td><td>每当将指定的信号发送到进程时，转储堆分析信息。</td></tr></tbody></table></div><h4 id="修改代码来使用-heap-profiling"><a href="#修改代码来使用-heap-profiling" class="headerlink" title="修改代码来使用 heap-profiling"></a>修改代码来使用 heap-profiling</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/heap-profiler.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 启动堆分析器 */</span></span><br><span class="line">HeapProfilerStart()</span><br><span class="line"><span class="comment">/* 停止堆分析器 */</span></span><br><span class="line">HeapProfilerStop()</span><br><span class="line"><span class="comment">/* 转储堆分析器分析结果 */</span></span><br><span class="line">HeapProfilerDump()</span><br><span class="line">GetHeapProfile()</span><br><span class="line"><span class="comment">/* 检查堆分析器是否启动 */</span></span><br><span class="line">IsHeapProfilerRunning()</span><br></pre></td></tr></table></figure><p>示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/heap-profiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAIT_FOREVER(t) do &#123; while(1) &#123; sleep(t); &#125; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">leek_malloc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ptr = <span class="built_in">malloc</span>(<span class="number">1024</span>); <span class="comment">/* 1024 Byte */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc 1024 byte success.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (time(<span class="literal">NULL</span>) % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">free</span>(ptr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">leek_check</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        HeapProfilerDump(<span class="string">&quot;check&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidmalloc;</span><br><span class="line">    <span class="keyword">pthread_t</span> tiddump;</span><br><span class="line">    HeapProfilerStart(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tidmalloc, <span class="literal">NULL</span>, leek_malloc, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tidmalloc, <span class="literal">NULL</span>, leek_check, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WAIT_FOREVER(<span class="number">10</span>);</span><br><span class="line">    HeapProfilerStop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-heap-profiling-输出"><a href="#分析-heap-profiling-输出" class="headerlink" title="分析 heap-profiling 输出"></a>分析 heap-profiling 输出</h4><p>如果在程序中打开堆分析，程序将定期将配置文件写入文件系统。配置文件序列将命名为：</p><pre><code>    &lt;prefix&gt;.0000.heap    &lt;prefix&gt;.0001.heap    &lt;prefix&gt;.0002.heap    ...</code></pre><p><code>&lt;prefix&gt;</code> 是运行代码时提供的文件名前缀（或者通过环境变量 <code>HEAPPROFILE</code> 提供）的位置。请注意，如果提供的前缀不是以 ‘/‘ 开头，则配置文件将写入程序的工作目录。</p><p>通过将配置文件输出传递到工具 <code>pprof</code> 可以查看配置文件输出。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://gperftools.github.io/gperftools/heap_checker.html">Gperftools Heap Leak Checker</a></li><li>[2] <a href="https://gperftools.github.io/gperftools/heapprofile.html">Gperftools Heap Profiler</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存泄漏一般是由于程序在堆上分配了内存而没有释放，随着程序的运行占用的内存越来越大，一方面会影响程序的稳定性，可能让运行速度越来越慢，或者造成 &lt;code&gt;OOM&lt;/code&gt;，甚至会影响程序所运行的机器的稳定性，造成宕机。&lt;/p&gt;
&lt;p&gt;而分析内存问题的常用工具有 &lt;code&gt;valgrind&lt;/code&gt; 和 &lt;code&gt;gperftools&lt;/code&gt; 等，当然也可以自行开发钩子函数，本文主要介绍 &lt;code&gt;gperftools&lt;/code&gt; 来进行内存泄漏的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发日记" scheme="http://github.hezhaojiang.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="内存管理" scheme="http://github.hezhaojiang.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>音视频封装 - PS 封装解析示例</title>
    <link href="http://github.hezhaojiang.io/post/2020/1472cc3/"/>
    <id>http://github.hezhaojiang.io/post/2020/1472cc3/</id>
    <published>2020-11-17T05:03:07.000Z</published>
    <updated>2021-01-13T13:50:49.982Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章 <a href="/post/2020/9064839e/" title="音视频封装 - PS 封装格式">音视频封装 - PS 封装格式</a> 中分析了 <code>PS</code> 流的结构，但文章中中涉及到的元素过多，难以理解，故通过一段真实的码流的分析来加强对 <code>PS</code> 流结构的理解。</p><blockquote><p>注 1：本文中的 <code>PS</code> 码流 A 截取自一段经 <code>ffmpeg</code> 转码的网络视频，码流 B 截取自海康摄像机的 <code>GB28181</code> 码流。<br>注 2：本文中的数字一般为十进制表示，如果是其他进制数据，会在数字后携带 <code>(2)</code> 代表二进制，在数字前添加 <code>0x</code> 代表十六进制<br>注 3：截图中的码流信息均使用十六进制</p></blockquote><a id="more"></a><h2 id="PS-Stream-A"><a href="#PS-Stream-A" class="headerlink" title="PS Stream A"></a>PS Stream A</h2><h3 id="PS-Header"><a href="#PS-Header" class="headerlink" title="PS Header"></a>PS Header</h3><p><code>PS</code> 码流由多个 <code>PS Pack</code> 组成，而 <code>PS Pack</code> 的起始符为 <code>0x00 00 01 ba</code>。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117214228.png" alt="PS Header"></p><p>接下来跳过 <code>9</code> 个字节，看第 <code>10</code> 个字节，其最后三位数字代表拓展内容的长度，此包中该位置后三位为 <code>0</code>，代表无拓展内容。</p><blockquote><p>如果该位置后三位非 0，参见 <a href="#PS-Header-Extern">PS Header Extern</a></p></blockquote><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117215716.png" alt="拓展内容"></p><p>继续读取数据，如果遇到了 <code>0x00 00 01 bb</code>，就代表到了码流中 <code>PS System Header</code> 部分。</p><blockquote><p>码流中有可能会读取到 <code>0x00 00 01 bc</code>，参见 <a href="#Program-Stream-Map">Program Stream Map</a></p></blockquote><h3 id="PS-System-Header"><a href="#PS-System-Header" class="headerlink" title="PS System Header"></a>PS System Header</h3><p><code>System Header</code> 当且仅当数据包为第一个数据包时才存在，以 <code>0x00 00 01 bb</code> 的开始。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220401.png" alt="PS System Header"></p><p>之后紧跟着的 <code>0x00 0c</code> 两个字节表示 <code>System Header</code> 的长度，换算为十进制，即为 <code>12</code> 个字节。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220711.png" alt="PS System Header Length"></p><p>之后跳过 <code>6</code> 字节数据，之后如果 <code>nextbit == 1</code>，则该位置为一个 <code>stream_id</code>，<code>stream_id</code> 为 <code>0xe0</code>，指示该 <code>PS</code> 码流中包含视频流。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117221430.png" alt="Stream id e0"></p><p>该部分内容 <code>3</code> 字节一个循环，下一个循环中 <code>nextbit == 1</code>，则该位置也为一个 <code>stream_id</code>，<code>stream_id</code> 为 <code>0xc0</code>，指示该 <code>PS</code> 码流中包含音频流。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117221746.png" alt="Stream id c0"></p><p>至此 <code>nextbit == 0</code>，说明该循环结束，读取的长度也与上述 <code>PS System Header</code> 的长度值 <code>12</code> 一致。</p><p>继续读取数据，遇到了 <code>0x00 00 01</code>，<code>PS</code> 流中这三个字符可视为不同数据的分隔符，而其下一位数据指示了后续数据的类型。</p><h3 id="PES-Pack"><a href="#PES-Pack" class="headerlink" title="PES Pack"></a>PES Pack</h3><p>如果读取 PS 流中遇到了 <code>0x00 00 01 e0</code> 或 <code>0x00 00 01 c0</code>，就代表读取到了 <code>PES Pack</code>。</p><p><code>PES Pack</code> 分为两个部分，一部分是 <code>Header</code>，一部分是 <code>Payload</code>，<code>Header</code> 用于存储一些描述信息，而 <code>Payload</code> 部分为其存储的原始数据，<code>PES</code> 可能有多个。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117234659.png" alt="PES Pack"></p><p><code>0x00 00 01 e0</code> 代表遇到的是一个 <code>PES Video Pack</code>，如果是 <code>0x00 00 01 c0</code>，代表遇到的是一个 <code>PES Audio Pack</code>。</p><p>再之后的 <code>0x07 dc</code> 表示长度，即其后的 <code>2012</code> 字节为数据内容长度。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117235040.png" alt="PES Pack Length"></p><p>之后参考 <code>PES Pack</code> 结构来解析数据，可参见 <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a>。</p><p>跳过 1 字节字段后，下一个字段为 <code>PTS_DTS_flags</code> 字段，占位 2bits。</p><blockquote><p><code>PTS_DTS_flags</code>：<code>PTS</code> 和 <code>DTS</code> 标志位，占位 2bit；<code>10(2)</code> 表示首部有 <code>PTS</code> 字段，<code>11(2)</code> 表示有 <code>PTS</code> 和 <code>DTS</code> 字段，<code>00(2)</code> 表示都没有，<code>01(2)</code> 被禁止。<br><code>PTS</code> - 显示时间戳（Presentation Time Stamp），用来表示显示单元出现在系统目标解码器的时间。<br><code>DTS</code> - 解码时间戳（Decoding Time Stamp），用来表示将存取单元全部字节从解码缓存取走的时间。<br>如果 <code>PTS_DTS_flags</code> 不是 <code>00(2)</code>，就代表存在 <code>PTS</code> 或 <code>DTS</code> 参见 <a href="#PTS_DTS_flags">PTS_DTS_flags</a></p></blockquote><p>故该 <code>PES Pack</code> 中无 <code>PTS</code> 和 <code>DTS</code> 字段</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117235708.png" alt="PTS_DTS_flags"></p><p>后面 6bits 也是 <code>PES</code> 包中可选字段的 <code>Flag</code> 参数，由上图可知，该 <code>PES Pack</code> 无这些可选字段。</p><p>继续读取数据，下一个字段就为 <code>PES_header_data_length</code>，代表 <code>PES Header</code> 中可选字段和填充字段的长度，占位 <code>8bit</code>，该 <code>PES Pack</code> 中该值为 <code>03</code>，即该 <code>PES Pack</code> 中，该字段之后 <code>3</code> 个字节为 <code>PES Header</code> 字段，剩余数据均为数据 <code>Payload</code>。</p><h2 id="PS-Stream-B"><a href="#PS-Stream-B" class="headerlink" title="PS Stream B"></a>PS Stream B</h2><h3 id="PS-Header-Extern"><a href="#PS-Header-Extern" class="headerlink" title="PS Header Extern"></a>PS Header Extern</h3><p>如果 <code>PS Pack</code> 第 <code>10</code> 字节后三位不是 <code>000(2)</code>，则代表其后有相应长度的拓展内容，比如下图码流中就有 <code>6</code> 字节拓展内容：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220016.png" alt="拓展内容 2"></p><h3 id="Program-Stream-Map"><a href="#Program-Stream-Map" class="headerlink" title="Program Stream Map"></a>Program Stream Map</h3><p>如果码流中遇到了 <code>0x00 00 01 bc</code>，则之后的数据为 <code>Program Stream Map</code> 数据。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223419.png" alt="Program Stream Map"></p><p><code>Program Stream Map</code>，即 <code>PSM</code>，其格式如下图所示：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223519.png" alt="Program Stream Map 格式"></p><p>可以看出，<code>0x00 00 01 bc</code> 后两位代表该部分数据长度，该 <code>PSM</code> 数据长度为 <code>0x62</code>，转化为十进制，即 <code>98</code> 字节。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223909.png" alt="Program Stream Map length"></p><p>结合上边的 <code>PSM</code> 结构，自 <code>0x00 62</code> 后，跳过两个字节的固定内容，就到了两个字节的 <code>program_stream_info_length</code>，其值为 <code>0x00 2c</code>，说明其后跟着的 <code>descriptor</code> 共占 <code>44</code> 字节。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117230813.png" alt="descriptor"></p><p>跳过该长度信息和 <code>44</code> 字节后，接下来的值 <code>0x00 2c</code> 为 <code>element_stream_map_length</code>（基本流映射长度），也就是 <code>44</code> 字节，它表示接下来的 <code>44</code> 字节都是用来描述原始流信息的。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117231212.png" alt="c"></p><p>接下来进入了原始流描述的第一次循环，第一个字节 <code>stream_type</code> 值为 <code>0x24</code>，根据《GB/T 28181-2016 修改补充文件》可知其为 <code>H.265</code> 码流。</p><pre><code>    a)  MPEG-4  视频流：    0x10    b)  H.264   视频流：    0x1B    c)  SVAC    视频流：    0x80    d)  H.265   视频流：    0x24    e)  G.711A  音频流：    0x90    f)  G.711U  音频流：    0x91    g)  G.722.1 音频流：    0x92    h)  G.723.1 音频流：    0x93    i)  G.729   音频流：    0x99    j)  SVAC    音频流：    0x9B</code></pre><p>之后的 <code>0xe0</code> 表示其为视频流。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232429.png" alt="stream_type"></p><p>之后的 <code>0x00 10</code> 代表该视频流描述 <code>element_stream_info_length</code> 占 <code>16</code> 字节。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232540.png" alt="element_stream_info_length"></p><p>同理，接着循环下去，接下来的字段 <code>0x91</code> 和 <code>0xc0</code>，代表着其为 <code>G.711U</code> 编码的音频流，并携带有 <code>0x0c</code> 即 <code>12</code> 字节的描述信息。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232848.png" alt="stream_type Audio"></p><p>继续循环，接下来的字段 <code>0xbd bd</code>，是海康的私有数据，携带有 <code>0</code> 字节的描述信息。</p><p>继续循环，接下来的字段 <code>0xbf bf</code>，也是海康的私有数据，携带有 <code>0</code> 字节的描述信息。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117233803.png" alt="私有数据 PSM"></p><p>以上四次循环后，他们占用的字节数已经等于 <code>44</code>，跟 <code>element_stream_map_length</code> 值相等。</p><p>接下来的内容就是 <code>CRC_32</code>，<code>4bits</code>，从以下码流中可以看出，海康 IPC 中没有对这些字节进行计算。</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118211141.png" alt="CRC_32"></p><h3 id="PTS-DTS-flags"><a href="#PTS-DTS-flags" class="headerlink" title="PTS_DTS_flags"></a>PTS_DTS_flags</h3><p>在很多码流中，都会存在 <code>PTS</code> 或 <code>DTS</code> 字段，此时 <code>PTS_DTS_flags</code> 字段就会置位，比如以下码流中，<code>PTS_DTS_flags</code> 为 <code>00(2)</code></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118212717.png" alt="PTS_DTS_flags"></p><p>对比 <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a> 中 <code>PES</code> 码流结构可知，之后由 <code>5</code> 字节的 <code>PTS</code> 数据</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118213841.png" alt="PES Struct"></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118214049.png" alt="PTS Data"></p><h3 id="ES-Stream"><a href="#ES-Stream" class="headerlink" title="ES Stream"></a>ES Stream</h3><p>经过以上步骤分析出 <code>PS</code> 的各层封装后，就能将封装中的 <code>ES</code> 码流提取出来：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118212109.png" alt="ES"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] 文中 <code>PS</code> 码流 <code>A</code> 视频源文件：<a href="/slave/PS/TestVideoA.7z" title="密码：github.com">点击下载</a></li><li>[2] 文中 <code>PS</code> 码流 <code>B</code> 视频源文件：<a href="/slave/PS/TestVideoB.7z" title="密码：github.com">点击下载</a></li><li>[3] <a href="/post/2020/9064839e/" title="音视频封装 - PS 封装格式">音视频封装 - PS 封装格式</a></li><li>[4] <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章 &lt;a href=&quot;/post/2020/9064839e/&quot; title=&quot;音视频封装 - PS 封装格式&quot;&gt;音视频封装 - PS 封装格式&lt;/a&gt; 中分析了 &lt;code&gt;PS&lt;/code&gt; 流的结构，但文章中中涉及到的元素过多，难以理解，故通过一段真实的码流的分析来加强对 &lt;code&gt;PS&lt;/code&gt; 流结构的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注 1：本文中的 &lt;code&gt;PS&lt;/code&gt; 码流 A 截取自一段经 &lt;code&gt;ffmpeg&lt;/code&gt; 转码的网络视频，码流 B 截取自海康摄像机的 &lt;code&gt;GB28181&lt;/code&gt; 码流。&lt;br&gt;注 2：本文中的数字一般为十进制表示，如果是其他进制数据，会在数字后携带 &lt;code&gt;(2)&lt;/code&gt; 代表二进制，在数字前添加 &lt;code&gt;0x&lt;/code&gt; 代表十六进制&lt;br&gt;注 3：截图中的码流信息均使用十六进制&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="音视频封装" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
    <category term="MPEG2-PS" scheme="http://github.hezhaojiang.io/tags/MPEG2-PS/"/>
    
  </entry>
  
</feed>
